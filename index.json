[{"content":"1. 요구사항 아주 간단한 웹 기반 ITunes 주요 데이터는 다음과 같다. 가수 (Singer) 이름 정보를 가진다. 앨범 (Album) 발매 날짜, 앨범 제목 정보를 가진다. 노래 (Song) 노래 제목과 재생 시간 정보를 가진다. 공통 데이터 생성 시간 업데이트 시간 생성한 사람 업데이트한 사람 주요 기능 가수를 등록할 수 있다. 앨범을 등록할 수 있다. 노래를 등록할 수 있다. 노래 목록들을 조회할 수 있다. 노래를 조회할 수 있다. 노래를 업데이트 할 수 있다. 노래를 삭제할 수 있다. 엔티티 Class 2. 프로젝트 scaffolding 섀시 패턴 아래와 같은 프로젝트들의 공통 관심사를 편리하게 설정할 수 있다. health check 패턴: actuator 개발 생산성 확보: spring-configuration-processor, lombok, mapstruct: 로깅 패턴: logback, request - response 로깅 추적 패턴: B3 Propagation(Sleuth), Sentry 적용 로컬 개발 환경: docker-compose를 이용한 local cluster 구성 (UAA + MySQL + Kafka + …) Persistence: QueryDSL, JPA Specification integration API-First: OpenApi Generator 및 Zalando problem details 연동 Scheduler: ShedLock 연동 Security: UAA 및 리소스 서버 통합 CI / CD: 도커 이미지 빌드, 젠킨스 연동 msa-bootcamp 프로젝트 세팅 (Meshkorea) git clone https://github.com/meshkorea/msa-starter.git\nstarter project를 clone한다. cd msa-starter \u0026amp;\u0026amp; ./gradlew generate\n위 명령어를 수행하면 아래와 같은 세팅 메세지가 나온다. Starting a Gradle Daemon (subsequent builds will be faster) \u0026gt; Task :getBuildInfo \u0026gt; WebMVC/JPA 프로젝트인가요(m)? WebFlux/R2DBC 프로젝트인가요(f) (default: m)? \u0026lt;====---------\u0026gt; 33% EXECUTING [17s] \u0026gt; 부릉 프로젝트입니까(y/n, default: n)?: \u0026lt;====---------\u0026gt; 33% EXECUTING [27s] \u0026gt; 사용하려는 자바 버전은 무엇입니까(1.8/11, default: 11)?: \u0026lt;====---------\u0026gt; 33% EXECUTING [31s] 11 \u0026gt; 프로젝트 이름은 무엇입니까(default: example)? \u0026lt;====---------\u0026gt; 33% EXECUTING [35s] \u0026gt; 그룹 이름은 무엇입니까(default: com.vroong)? \u0026lt;====---------\u0026gt; 33% EXECUTING [38s] \u0026gt; 웹 서버 포트는 무엇입니까(default: 8080)? \u0026lt;====---------\u0026gt; 33% EXECUTING [42s] \u0026gt; 웹 요청 및 응답에 사용할 미디어 타입은 무엇입니까(default: application/vnd.vroong.private.v1+json)? \u0026lt;====---------\u0026gt; 33% EXECUTING [47s] 진행할까요(\u0026#39;n\u0026#39; to quit)? [osArch:intel, projectType:v, projectName:example, groupName:com.vroong, packageName:com.vroong.example, portNumber:8080, mediaType:application/vnd.vroong.private.v1+json, javaVersion:11, dockerImage:amazoncorretto:11-alpine-jdk, skipTokens:[.DS_Store]] \u0026lt;====---------\u0026gt; 33% EXECUTING [50s] \u0026gt; Task :generate cp -r build {path-to-your-project}\ncd {path-to-your-project} \u0026amp;\u0026amp; ./gradlew clean build\ngit init\n로컬 개발 환경 구동 방법 JDK 설치 corretto11 jhipster-uaa 세팅 msa-starter 디렉토리의 jhipster-uaa.zip을 해제한다. cd jhipster-uaa \u0026amp;\u0026amp; ./gradlew jibDockerBuild -Djib.to.image=jhipster-uaa -Djib.to.tags=latest 로컬에서는 jhipster-uaa를 사용하지만, EKS에 올렸을 때는 이미 구동중인 vroong-uaa를 사용한다. 도커 구동 ./gradlew clusterUp MySQL (3306) Kafka (9092) jhipster-uaa (9999) 애플리케이션 구동 3. API-First 개발 방법론 API-First 개발 방법론 API를 중심으로 제품을 설계하는 방법이다. API는 중요한 비즈니스 요소이며, 개발 조직에 API를 제공하는 것이 높은 우선순위를 가진다고 인식하는 것이다. API-First 장점 일관성 제공 API-First 도구를 사용하여 일관성 있는 설계 및 문서화를 통해 일관된 개발자 경험을 제공할 수 있도록 해준다. 병렬 개발 편의성 API를 먼저 설계하고 결과물로 나온 API Spec을 이용해서 서버 스켈레톤과 클라이언트 SDK(API 문서 + 클라이언트 라이브러리 Stub)를 생성할 수 있고 클라이언트와 서버가 생성된 코드를 이용해서 빠르게 개발을 시작할 수 있다. 개발 속도 향상 API-First 도구는 클라이언트 SDK를 생성해주고, 이를 사내 Repository에 공유할 수 있다. 개발자들은 Mock API를 사용함으로써, API가 완성되기 전에 클라이언트를 구축할 수 있다. 빠른 피드백 제공 클라이언트 개발자는 서버 개발자가 개발 완료 후 API를 제공할 때까지 기다리지 않고, API 문서와 Mock API를 이용하여 설계를 검토하고 검증해볼 수 있다. API-First 도구 - OAS (OpenApi Specification) OAS는 REST API를 위한 IDL(Interface Defintion Language) 이다. API 스펙 및 기능, 설명을 기술한다. OAS 파일은 YAML 또는 JSON으로 작성할 수 있다. OAS 파일은 아래 내용을 포함한 내용을 기술할 수 있다. API endpoint와 HTTP method (GET /users, POST /users 등) 각 API의 요청과 응답의 파라미터 인증 method 이용 방법, 라이센스, 연락처 등과 기타 정보 Swagger Editor/IDE plugin를 사용하면 OpenApi Specification의 문법 오류와 UI를 확인 할 수 있다. OpenApi Generator의 특징 OpenApi Generator를 사용하면 서버의 코드 스켈레톤과 클라이언트의 SDK를 자동으로 생성해준다. 서버 스켈레톤은 각 API에 대한 기술없이, 구현만 해주면 된다. JAVA 뿐만 아니라 PHP, GO, C++, C#, Python, Ruby, Typescript 등 대부분의 언어를 지원한다. API Interface 뿐만 아니라 model도 구현해주고, 정규 표현식 또는 다른 제한을 validation 까지 해준다. 브라우저에서 사용자가 직접 호출해볼 수 있는 interactive API 문서를 만들어 준다. Ex) Swagger Editor OAS 문법 https://swagger.io/docs/specification/basic-structure/\n간단한 OAS 예시\nopenapi: \u0026#39;3.0.1\u0026#39; info: title: \u0026#39;msa-bootcamp\u0026#39; version: 1.0.0 servers: - url: http://localhost:8080 description: Local server paths: /api/singers: post: description: create an singer operationId: createSinger tags: - Singer requestBody: description: singer model content: application/vnd.vroong.private.v1+json: schema: $ref: \u0026#39;#/components/schemas/CreateSingerRequest\u0026#39; responses: \u0026#39;201\u0026#39;: $ref: \u0026#39;#/components/responses/Created\u0026#39; \u0026#39;400\u0026#39;: $ref: \u0026#39;#/components/responses/BadRequest\u0026#39; \u0026#39;401\u0026#39;: $ref: \u0026#39;#/components/responses/Unauthorized\u0026#39; \u0026#39;403\u0026#39;: $ref: \u0026#39;#/components/responses/Forbidden\u0026#39; \u0026#39;500\u0026#39;: $ref: \u0026#39;#/components/responses/ServerError\u0026#39; components: schemas: CommonProperties: type: object properties: createdAt: $ref: \u0026#39;#/components/schemas/DateTime\u0026#39; updatedAt: $ref: \u0026#39;#/components/schemas/DateTime\u0026#39; createdBy: $ref: \u0026#39;#/components/schemas/UUID\u0026#39; updatedBy: $ref: \u0026#39;#/components/schemas/UUID\u0026#39; Page: type: object properties: size: type: integer format: int32 default: 20 example: 20 totalElements: type: integer format: int64 example: 100 totalPages: type: integer format: int32 example: 5 number: type: integer format: int32 default: 1 example: 1 CreateSingerRequest: type: object required: - name properties: name: type: string Singer: allOf: - $ref: \u0026#39;#/components/schemas/CommonProperties\u0026#39; - type: object properties: singerId: $ref: \u0026#39;#/components/schemas/LongId\u0026#39; name: type: string 서버 코드 스켈레톤 생성 및 클라이언트 SDK 생성 OpenApi Generator를 사용한다.\nhttps://openapi-generator.tech/docs/installation 서버 코드 스켈레톤 생성\n아래와 같이 gradle이 정의되어 있어야 한다. plugin { id \u0026#39;org.openapi.generator\u0026#39; version \u0026#39;4.3.1\u0026#39; } openApiGenerate { generatorName = \u0026#39;spring\u0026#39; inputSpec = \u0026#34;$rootDir/src/main/resources/swagger/api.yml\u0026#34;.toString() outputDir = \u0026#34;$buildDir/openapi\u0026#34;.toString() apiPackage = \u0026#39;com.vroong.msabootcamp.api\u0026#39; modelPackage = \u0026#39;com.vroong.msabootcamp.api.model\u0026#39; modelNameSuffix = \u0026#34;Dto\u0026#34; apiFilesConstrainedTo = [\u0026#34;\u0026#34;] modelFilesConstrainedTo = [\u0026#34;\u0026#34;] supportingFilesConstrainedTo = [\u0026#34;ApiUtil.java\u0026#34;] configOptions = [ delegatePattern: \u0026#34;true\u0026#34;, title: \u0026#34;msabootcamp\u0026#34;, useTags: \u0026#34;true\u0026#34;, dateLibrary: \u0026#34;java8\u0026#34;, java8: \u0026#34;true\u0026#34;, hideGenerationTimestamp: \u0026#34;true\u0026#34; ] validateSpec = true } sourceSets { main { java { srcDir file(\u0026#34;${project.buildDir.path}/openapi/src/main/java\u0026#34;) } } } ./gradlew openApiGenerate Stub을 생성하면 아래의 파일이 생성된다. model에는 OAS에서 정의한 schema를 가진 DTO가 있다. 클라이언트 SDK 빌드 및 배포\n./gradlew :clients:clean :clients:publish -Dorg.gradle.internal.publish.checksums.insecure=true # 배포 결과는 https://nexus.mm.meshkorea.net/ 에서 확인할 수 있습니다. 4. Controller 작성 서버 코드 스켈레톤을 이용해서 controller를 구현한다. SingerApi\n/** * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) (5.3.0). * https://openapi-generator.tech * Do not edit the class manually. */ @javax.annotation.Generated(value = \u0026#34;org.openapitools.codegen.languages.SpringCodegen\u0026#34;) @Validated @Api(value = \u0026#34;Singer\u0026#34;, description = \u0026#34;the Singer API\u0026#34;) public interface SingerApi { default SingerApiDelegate getDelegate() { return new SingerApiDelegate() {}; } /** * POST /api/singers * create an singer * * @param createSingerRequestDto singer model (optional) * @return Created (status code 201) * or Bad Request (status code 400) * or Unauthorized (status code 401) * or Forbidden (status code 403) * or Internal Server Error (status code 500) */ @ApiOperation(value = \u0026#34;\u0026#34;, nickname = \u0026#34;createSinger\u0026#34;, notes = \u0026#34;create an singer\u0026#34;, authorizations = { @Authorization(value = \u0026#34;jhipster-uaa\u0026#34;, scopes = { }), @Authorization(value = \u0026#34;jhipster-uaa\u0026#34;, scopes = { }) }, tags={ \u0026#34;Singer\u0026#34;, }) @ApiResponses(value = { @ApiResponse(code = 201, message = \u0026#34;Created\u0026#34;), @ApiResponse(code = 400, message = \u0026#34;Bad Request\u0026#34;, response = ProblemDetailsDto.class), @ApiResponse(code = 401, message = \u0026#34;Unauthorized\u0026#34;, response = ProblemDetailsDto.class), @ApiResponse(code = 403, message = \u0026#34;Forbidden\u0026#34;, response = ProblemDetailsDto.class), @ApiResponse(code = 500, message = \u0026#34;Internal Server Error\u0026#34;, response = ProblemDetailsDto.class) }) @RequestMapping( method = RequestMethod.POST, value = \u0026#34;/api/singers\u0026#34;, produces = { \u0026#34;application/problem+json\u0026#34; }, consumes = { \u0026#34;application/vnd.vroong.private.v1+json\u0026#34; } ) default ResponseEntity\u0026lt;Void\u0026gt; createSinger(@ApiParam(value = \u0026#34;singer model\u0026#34;) @Valid @RequestBody(required = false) CreateSingerRequestDto createSingerRequestDto) { return getDelegate().createSinger(createSingerRequestDto); } } SingerApiController\n@javax.annotation.Generated(value = \u0026#34;org.openapitools.codegen.languages.SpringCodegen\u0026#34;) @Controller @RequestMapping(\u0026#34;${openapi.msabootcamp.base-path:}\u0026#34;) public class SingerApiController implements SingerApi { private final SingerApiDelegate delegate; public SingerApiController(@org.springframework.beans.factory.annotation.Autowired(required = false) SingerApiDelegate delegate) { this.delegate = Optional.ofNullable(delegate).orElse(new SingerApiDelegate() {}); } @Override public SingerApiDelegate getDelegate() { return delegate; } } SingerApiDelegate\n/** * A delegate to be called by the {@link SingerApiController}}. * Implement this interface with a {@link org.springframework.stereotype.Service} annotated class. */ @javax.annotation.Generated(value = \u0026#34;org.openapitools.codegen.languages.SpringCodegen\u0026#34;) public interface SingerApiDelegate { default Optional\u0026lt;NativeWebRequest\u0026gt; getRequest() { return Optional.empty(); } /** * POST /api/singers * create an singer * * @param createSingerRequestDto singer model (optional) * @return Created (status code 201) * or Bad Request (status code 400) * or Unauthorized (status code 401) * or Forbidden (status code 403) * or Internal Server Error (status code 500) * @see SingerApi#createSinger */ default ResponseEntity\u0026lt;Void\u0026gt; createSinger(CreateSingerRequestDto createSingerRequestDto) { return new ResponseEntity\u0026lt;\u0026gt;(HttpStatus.NOT_IMPLEMENTED); } } SingerApiDeleateImpl\n@RequiredArgsConstructor @Component public class SingerApiDelegateImpl implements SingerApiDelegate { private final SingerService singerService; @Override public ResponseEntity\u0026lt;Void\u0026gt; createSinger(CreateSingerRequestDto createSingerRequestDto) { SingerDto singerDto = singerService.createSinger(createSingerRequestDto); return ResponseEntity .created(HeaderUtils.uri(String.valueOf(singerDto.getSingerId()))) .build(); } } 5. Messaging 이벤트 메세지 또는 커맨드 메세지를 이용하여 상호간에 통신하는 방식 이벤트 이미 일어난 정보에 대한 메세지이다. immutable 하다. producer는 이벤트의 comsumer가 누구인지, 무엇을 하는지 모른다. ex) 신규 물품이 입고되었을 때 필요한 시스템만 이벤트를 구독한다. 신규 물품이 입고된 것은 이미 일어난 사건이다. 커맨드 수행할 작업에 대한 하나의 시스템에서 다른 시스템으로의 메세지 미래에 발생할 사건의 트리거가 된다. 메시징을 사용하는 이유 REST API는 클라이언트가 요청하는 시점에 서버가 항상 가용해야 하는 문제가 있다. REST와 같은 동기 IPC (Inter Process Communication) 문제점을 해결하고자 비동기 메시징을 사용한다. 메시지 브로커가 가용하다면 consumer의 장애 시점에도 producer가 발행한 메시지는 메시지 브로커에 적재되며, consumer가 장애에서 복구되면 메시지를 소비할 수 있다. Transactional Outbox Pattern 메시징을 통해 데이터를 처리할 때 데이터의 일관성을 처리하기 위해 사용한다. producer 역할을 하는 서비스에서 발생한 도메인 이벤트/메시지는 적어도 한번(at least once) 발행해야 한다. 방법 producer 역할을 하는 서비스에 OUTBOX 테이블을 생성하고, 도메인 이벤트/메시지를 트랜잭션 범위안에서 OUTBOX 테이블에 insert한다. 별도의 MessageRelay가 주기적으로 OUTBOX 테이블에 있는 메세지를 발행한다. MessageRelay는 polling publisher로 구현할 수 있다. 데이터베이스 트랜잭션이 커밋된 경우에만 MessageRelay를 통해서 메시지를 발행한다. MessageRelay를 통하기 때문에 메세지 발행에 시차는 생기지만, Eventual Consistency를 유지한다. 멱등 수신자 (Idempotent Receiver) consumer 역할을 하는 서비스는 동일한 메시지를 중복으로 여러번 수신할 수 있으므로, 중복 메시지로 인한 사이드 이펙트가 발생하지 않도록 멱등 수신자를 구현해야 한다. 방법 PROCESSED_MESSAGE 테이블을 추가한다. 메세지를 수신하면 식별자를 이용해서 테이블에서 조회한다. 테이블에서 조회된다면 메세지를 무시한다. 조회되지 않는 메세지면 PROCESSED_MESSAGE에 저장하고 처리한다. (메세지 식별자에 unique 제약조건을 걸어서 구분할 수도 있다.) Kafka 코드 application.yml\nspring: cloud: stream: kafka: binder: headers: [\u0026#34;messageId\u0026#34;, \u0026#34;messageType\u0026#34;, \u0026#34;messageVersion\u0026#34;, \u0026#34;messageSource\u0026#34;] auto-create-topics: false # Kafka - SASL_SSL설정과 SCRAM-SHA-512 를 이용한 ID Password 설정 # @see https://wiki.mm.meshkorea.net/pages/viewpage.action?pageId=95856174 configuration: sasl: jaas: config: \u0026#39;org.apache.kafka.common.security.plain.PlainLoginModule required username=\u0026#34;alice\u0026#34; password=\u0026#34;alice-secret\u0026#34;;\u0026#39; mechanism: PLAIN security: protocol: SASL_PLAINTEXT bindings: messageChannel: binder: kafka destination: local-msabootcamp-output producer: # @see https://docs.spring.io/spring-cloud-stream-binder-kafka/docs/3.0.10.RELEASE/reference/html/spring-cloud-stream-binder-kafka.html#kafka-producer-properties header-mode: headers partition-key-expression: headers[\u0026#39;partitionKey\u0026#39;] partition-count: 1 subscribableChannel: binder: kafka destination: local-msabootcamp-output content-type: application/json consumer: header-mode: embeddedHeaders checkpointMode: record default-binder: kafka spring.cloud.stream.kafka.binder 를 이용해서 KafkaBinderConfigurationProperties.class 의 값을 세팅 PersistentEventCreator.class\npublic class PersistentEventCreator { private final PersistentEventRepository repository; private final ObjectMapper objectMapper; @Transactional public void create(String eventType, Object source) { String body = \u0026#34;\u0026#34;; try { body = objectMapper.writeValueAsString(source); } catch (IOException e) { log.error(\u0026#34;Serialization failed\u0026#34;, e); } final PersistentEvent entity = PersistentEvent.newInstance(eventType, UUID.randomUUID(), body); repository.save(entity); } } PersistentEventPublisher.class - publish()\n@Transactional @Scheduled(fixedDelayString = \u0026#34;PT50S\u0026#34;, initialDelayString = \u0026#34;PT10S\u0026#34;) @SchedulerLock(name = \u0026#34;PersistentEventPublisher\u0026#34;) @Async public void publish() { final Instant timeScope = Instant.now(Clock.system(ZONE_ID)).minus(1, ChronoUnit.MINUTES); List\u0026lt;PersistentEvent\u0026gt; candidates = repository.findUnproducedByTimeScope(timeScope); // OUTBOX 조회 if (candidates.isEmpty()) { return; } writeLog(\u0026#34;started\u0026#34;, kv(\u0026#34;total\u0026#34;, candidates.size())); int success = 0; for (PersistentEvent candidate : candidates) { try { boolean produced = producer.produce(candidate); // produce if (produced) { candidate.markProduced(); success++; writeLog(\u0026#34;handling\u0026#34;, kv(\u0026#34;persistentEventId\u0026#34;, candidate.getId()), kv(\u0026#34;eventType\u0026#34;, candidate.getEventType()), kv(\u0026#34;eventId\u0026#34;, candidate.getEventId()) ); } else { throw new RuntimeException(\u0026#34;Message was not produced\u0026#34;); } } catch (Exception e) { candidate.markFailed(); reportError(e, kv(\u0026#34;persistentEventId\u0026#34;, candidate.getId())); } } writeLog(\u0026#34;success\u0026#34;, kv(\u0026#34;success\u0026#34;, success), kv(\u0026#34;total\u0026#34;, candidates.size())); } MessageProducer.class\npublic class MessageProducer { private final MessageChannel messageChannel; public boolean produce(PersistentEvent persistentEvent) { final String body = persistentEvent.getBody(); Message\u0026lt;?\u0026gt; message = MessageBuilder .withPayload(body) .setHeader(MessageKey.ID, persistentEvent.getEventId()) .setHeader(MessageKey.TYPE, persistentEvent.getEventType()) .setHeader(MessageKey.VERSION, 1) .setHeader(MessageKey.SOURCE, PROJECT_NAME) .setHeader(MessageKey.RESOURCE, body.getClass().getSimpleName()) .setHeader(MessageKey.PARTITION_KEY, persistentEvent.getPartitionKey()) .build(); log.debug(\u0026#34;Event publish: {}\u0026#34;, message); return messageChannel.send(message, MessagePolicy.DEFAULT_TIMEOUT); } } MessageSubscriber.class\npublic class MessageSubscriber { private final ReceivedEventRepository receivedEventRepository; @StreamListener(value = ConsumerChannel.CHANNEL) public void subscribe(Message\u0026lt;Album\u0026gt; event) { UUID messageId = event.getHeaders().getId(); Optional\u0026lt;ReceivedEvent\u0026gt; receivedEvent = receivedEventRepository.findByMessageId(messageId); if (receivedEvent.isPresent()) { log.info(\u0026#34;Duplicated event: {}\u0026#34;, receivedEvent.get().getMessageId()); return; } receivedEventRepository.save(new ReceivedEvent(event.getHeaders().getId())); log.debug(\u0026#34;Event received: {}\u0026#34;, event.getPayload()); } } 전체 흐름 6. CI/CD CI/CD란 CI (Continuous Integration): 애플리케이션의 소스 변경 사항이 지속적으로 빌드 및 테스트되어 공유 리포지토리에 통합되는 것이다. CD (Continuous Delivery/Deployment): 변경 사항을 테스트 또는 프로덕션 환경에 지속적으로 배포하는 것이다. Jenkinsfile jenkins는 CI 도구이다.\n빌드 → 테스트 → 코드 분석 → 도커 이미지 빌드 → helm chart 빌드 위 과정을 파이프라인으로 자동화 해준다. 파이프라인은 Job들을 순차적 또는 병렬적으로 실행시키거나 작성한 스크립드로 이벤트를 연속적으로 실행시키는 것이다.\n@Library(\u0026#39;meshkorea\u0026#39;) _ vroongNeoMsaJavaPipeline( team: \u0026#39;\u0026#39;, ecrRepoName: \u0026#39;vroong/msabootcamp\u0026#39;, argoAppName: \u0026#39;vroong-msabootcamp\u0026#39;, gradleBuildArguments: \u0026#39;\u0026#39; ) team: 슬랙 {team}-build-alerts 채널에 관련 alert를 발생시킨다. ecrRepoName: Jenkins에서 도커 빌드 후 push할 ECR 이름 argoAppName: argoCD 앱 이름 gradleBuildArguments: jar 파일 빌드시 뒤에 추가할 argument Jenkins 파이프라인 적용 방법\n리포지토리 root에 Jenkinsfile이 있어야만 파이프라인이 실행된다. github push, PR, merge 와 같은 이벤트 발생시 파이프라인이 구동된다. 도커 이미지 tag는 파이프라인에 도커 빌드 과정에서 {tag}-{commit hash} 형태로 빌드 후 ECR에 push된다. tag가 example이고, commit hash가 2d48cj3a인 경우 도커 이미지 tag는 example-2d48cj3a이다. Helm values Helm은 K8S 패키지 관리를 도와주는 패키지 매니저이다. ex) dev와 qa, prod 환경의 DB 주소가 다르다면 이를 관리해 주는 것이다. vroong-{appname}-helm-values 리포지토리 에 필요한 환경 변수 추가 위 리포지토리를 보면 다음과 같은 구조가 있다. dev1 prod qa1 ~ 4 values.yaml argoCD에서 helm values를 배포하면 K8S 서비스, deployment(replica set, pod), 서비스 account, config map 등의 리소스를 만들어준다. values.yaml 모든 환경에 동일하게 적용되어야 하는 내용이 선언되어 있다. 각 환경 별로 values.yaml 파일이 또 있다. 각 환경 별로 바인딩 되어야 하는 환경 변수를 선언한다. override하고 싶은 내용을 선언한다. 빌드 및 배포 과정 Start Init 저장소 checkout 후, commit hash를 구한다. 슬랙에 파이프라인 구동 메세지를 보낸다. Jenkinsfile에 작성한 값을 읽어낸다. Check the docker image ECR에 같은 tag를 가진 이미지가 있는지 확인한다. Gradle build nexus에 접근하기 위한 계정 정보를 복사한다. jar 파일을 빌드한다. code review / unit test sonarqube로 코드 리뷰를 하고 unit 테스트를 수행한다. Docker / ECR login 도커 이미지를 빌드하고 tag를 붙인다. ECR에 login한다. ECR push ECR에 도커 이미지를 push한다. ArgoCD trigger argoCD에 login한다. 슬랙에 빌드 완료 메세지를 보낸다. End Jenkins 과정을 거친 후 APP DIFF 버튼을 눌러, helm values 변경 사항을 확인한다.\n변경 사항에 이상이 없으면 SYNC 버튼을 누른다.\npod가 잘 교체 되는지 확인한다.\nk9s /{서비스 이름으로 검색} 상단 Context에서 현재 환경을 확인할 수 있다. 새로운 pod가 실행된 후 완료되면 기존 pod를 교체한다. 모니터링한다.\n7. UAA User Account and Authentication\nMSA Resource 서버를 보호하기 위한 Authorization Server\nOAuth2 (Open Authorization) 방식\nAuthorization Code Grant Type Resource Owner Password Grant type Client Credentials Grant Type Client Credentials Grant Type Flow https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FAGn3b%2FbtqVyURyeZN%2F77J24Xr2Y3aAIZyLUsQZg1%2Fimg.png\nsecurity: oauth2: client: access-token-uri: http://localhost:9999/oauth/token user-authorization-uri: http://localhost:9999/oauth/token client-id: internal client-secret: internal scope: web-app grant-type: client_credentials authorized-grant-type: password, client_credentials, refresh_token resource: jwt.key-uri: http://localhost:9999/oauth/token_key ","permalink":"https://jo-minjun.github.io/note/msa-stack-quick-peek/","summary":"1. 요구사항 아주 간단한 웹 기반 ITunes 주요 데이터는 다음과 같다. 가수 (Singer) 이름 정보를 가진다. 앨범 (Album) 발매 날짜, 앨범 제목 정보를 가진다. 노래 (Song) 노래 제목과 재생 시간 정보를 가진다. 공통 데이터 생성 시간 업데이트 시간 생성한 사람 업데이트한 사람 주요 기능 가수를 등록할 수 있다. 앨범을 등록할 수 있다. 노래를 등록할 수 있다. 노래 목록들을 조회할 수 있다. 노래를 조회할 수 있다. 노래를 업데이트 할 수 있다. 노래를 삭제할 수 있다.","title":"MSA 개발 스택 빠르게 훑어보기"},{"content":"1. MAC, IP, Port 번호의 식별 MAC, IP, Port는 각 다음과 같은 레이어의 식별자이다. * DoD로 구분한 Layer * user mode ============================================ - Application kernel mode ============================================ - Transport: PORT - Network: IP H/W ============================================ - Access: MAC Transport\nPort가 식별자가 된다. Network\nHost에 대해서 IP가 식별자가 된다. Host: 네트워크에 연결된 컴퓨터, NIC 하나에 IP 주소를 여러 개 바인딩 할 수 있다.\n→ Host에 IP가 여러개 존재한다. Access\nNetwork Interface Card에 대해서 MAC이 식별자가 된다. 하드웨어 식별자지만, MAC 변경이 가능하다. Network Interface Card: 노트북은 유선/무선 랜카드가 2개 → NIC가 2개 2. Host, Switch, Network의 관계 Host는 Network에 연결된 컴퓨터이다.\nNetwork는 다음과 같이 두 가지로 나뉜다.\nNetwork 이용 주체 → End-Point가 된다. (Peer, Server, Client 등) Network 자체 → 이 Computer를 Switch라 한다. (Firewall, Router 등) Network는 Router(L3 Switch)와 DNS의 집합체이다.\n(스위칭 비용 증가) user mode ============================================ L7 -------------------------------------------- L6 -------------------------------------------- L5 -------------------------------------------- kernel mode ============================================ L4 - TCP -------------------------------------------- L3 (Router) - IP -------------------------------------------- H/W ============================================ L2 -------------------------------------------- L1 -------------------------------------------- (스위칭 비용 감소) 3. IPv4 주소 체계 IP 주소 Host에 대한 식별자\nIP 주소는 다음과 같이 두가지 표현 방법이 있다.\nIPv4: 32bit IPv6: 128bit IPv4의 32bit는 다음과 같이 이루어져 있다.\n32bit는 8bit씩 나누어 표기한다. 121.123.223.10 크게 두 부분으로 나뉜다. Net ID, Host ID Net ID Host ID ----------- -- 121.123.223.10 이때 Net ID의 길이를 구분하기 위해 서브넷 마스크를 사용한다. 서브넷 마스크 서브넷 마스크도 32bit로, 8bit씩 나누어 표기한다.\n서브넷 마스크와 IP 주소를 and 연산하면 Net ID를 확인할 수 있다.\n하지만 일반적으로 다음과 같이 Net ID의 길이를 함께 표기한다.\n121.123.223.10/24 → 121.123.223.0은 Net ID, Host는 10이다.\n이 표기하는 것을 CIDR라 한다. 4. Port 번호의 이해 Port는 관점에 따라 여러 의미를 가진다.\nProcess 식별자 Service 식별자 Interface 번호 여기서는 개발자 관점에서 Process 식별자를 알아본다.\nuser mode ============================================ - Process kernel mode ============================================ - TCP - IP - Driver H/W ============================================ - NIC kernel mode는 user mode가 접근이 가능하게 하기 위해 file이라는 인터페이스를 제공한다. 하지만 이를 프로토콜 관점에서 추상화하면 socket이 된다. 이때 socket에 attach되는 정보 중 하나가 Port 번호이다. Port는 다음과 같은 특징이 있다.\nsocket에 attach되는 정보이다. 16bit 정보이다. → 2^16\n→ Port 번호의 범위는 0 ~ 61535 이다. (하지만 0과 61535는 사용할 수 없다.)\n패킷이 하위 레이어에서 상위 레이어로 올라갈 때 Port를 이용해서 프로세스를 식별한다. 5. Switch, Switching Switching은 경로 또는 인터페이스를 선택하는 것이다.\n이 때 선택지가 나오는 곳을 Switch라 한다.\nNetwork는 라우터와 DNS의 집합이다.\n라우터는 L3 스위치이다. 라우터는 라우팅 테이블을 근거로 최적의 경로를 찾아낸다. 6. 네트워크 데이터 단위 user mode ============================================ - Application (Socket 수준) kernel mode ============================================ - TCP - IP H/W ============================================ - 위에서 설명한 user와 kernel 모드 사이의 file(socket)은 Stream이다. 기본적으로 file은 사용자가 계속 데이터를 입력하면 계속해서 데이터가 커진다. TCP에서 다루는 데이터 단위: Segment IP에서 다루는 데이터 단위: Packet IP 아래 단계에서 다루는 데이터 단위: Frame 이 데이터 단위의 흐름은 다음과 같다.\nStream이 Segment로 넘어갈 때 일정한 길이로 데이터를 분해한다. 이때 **Segment의 최대 크기를 Maximum Segment Size(MSS)**라 한다. MSS는 Packet의 최대 크기으로 결정하게 되는데, Packet의 최대 크기를 (Maximum Transport Unit)MTU라 한다. 이 Packet을 Frame 데이터로 캡슐화하여 전달한다. 7. 네트워크 인터페이스 선택 원리와 기준 user mode ============================================ - HTTP (L7) - - SSL kernel mode ============================================ - TCP, UDP (L4) - IP (L3) H/W ============================================ - Ethernet - 아래와 같은 상황에서 인터페이스는 어떻게 선택될까?\n사용자가 브라우저를 켰다. (Socket이 열리고, TCP와 IP가 바인딩 되어야 한다.) KT 유선 인터넷과 SKT 무선 인터넷을 두 개 연결했다. (일반적으로 IP 주소는 2개가 된다.) → 메트릭(쉽게 말해 비용) 값으로 결정한다.\n→ 따라서 위 경우에는 KT 유선과 SKT 무선 중 메트랙 값이 적은 쪽으로 바인딩 된다.\n8. 웹 서비스를 만드신 분에 대해 웹 탄생 배경 영국 물리학 연구원 팀 버너스 리 연구원은 논문을 많이 읽는다. 논문에는 항상 참고문헌이 많았다. 하지만 당시 링크 개념이 존재하지 않았고 문서는 모두 Text 파일이었다. → 문서(Text) + Link 를 이용해서 HTML이라는 문서 형식을 만들었다.\n→ HTML의 인터넷 전달 방법을 위해서 HTTP라는 프로토콜을 만들었다.\n→ 여러 문서들이 계속해서 연결되니, Web이 형성되었다.\n→ 이는 웹 서비스가 되었고, 팀 버너스 리가 창안했다.\n9. 초창기 웹 서비스의 구조 **웹 클라이언트 (브라우저)**는 인터넷을 통해서 웹 서버와 연결된다.\n이때 연결은 HTTP라는 TCP/IP 기반으로 된다.\nHTTP는 Stateless하다. 웹 클라이언트의 IP 주소가 있고 웹 서버에도 IP 주소가 있다.\n→ 이 주소 URL을 알고 리소스(HTML 문서)에 대한 요청을 하면 연결이 되고, 응답을 준다.\n→ 응답을 받은 클라이언트는 HTML 구문 분석을 하고, 내용을 렌더링 한다.\n즉, 이 당시 브라우저는 원격 문서 뷰어 역할(단방향 작용)을 했다.\n10. 웹 서비스 3대 요소 위 구조에는 문제가 있었다.\n문서의 내용과는 별개로 UI를 개선하고 싶었다.\n→ HTML에 기능을 추가하니 유지보수가 불편하다.\n→ CSS와 이미지가 나왔다.\n→ 요청하면 HTML + CSS + IMAGE(서버에 저장되어 있다.)가 순서대로 응답된다.\n문서를 변경해야 했다.\n→ 문서를 변경하기 위해 처리를 담당하는 서버가 생겼다.\n→ 단방향 작용이 양방향 상호 작용이 되면서 상태를 처리해야 했다.\n→ DB를 이용해서 처리하게 되었다.\n문서가 변경되고, 처리가 되니 문서가 복잡해졌다.\n→ 기능에 따라 동적인 움직임을 주는 것이 필요해졌다.\n→ 브라우저에서 렌더링 후에 연산하는 기능을 가지게 되었다. (Javascript)\n즉, 웹 서비스 3대 요소는 다음과 같다.\nHTML 구문 분석 렌더링 연산 11. LAN vs WAN 주의) 이 내용은 명확한 구분은 아니다. user mode ============================================ - HTTP - - SSL kernel mode (Logical == virtual) ============================================ - TCP, UDP - IP(IP 주소) --\u0026gt; [Internet] == [virtual network] -\u0026gt; *WAN H/W (Physical) ============================================ - Ethernet(MAC 주소) --\u0026gt; *LAN - LAN과 WAN은 흔히 범위의 차이로 구분한다.\n하지만 논리/물리적 구성요소로 구분하는 방법은 아래와 같다.\n시스템은 S/W와 H/W로 구분된다. S/W(kernel mode 이상)은 IP(Internet Protocol) 를 이용해서 통신한다. Internet은 virtual network이다. → WAN H/W는 MAC 주소를 이용한다. (이는 물리적인 주소이다.) → 하드웨어로 설명되는 네트워크 → LAN 12. 패킷의 생성 원리와 캡슐화 user mode ============================================ - HTTP - - SSL kernel mode ============================================ - TCP, UDP - IP H/W ============================================ - Ethernet - user mode 영역은 socket에 데이터를 IO한다. socket은 file을 추상화한 것이다. 때문에 데이터를 계속해서 쓰기할 수 있다. 이때 데이터의 단위는 Stream이다. user mode의 Stream이 Kernel mode에서 일정 단위로 나누어진다. 이때 데이터의 단위는 Segment이다. 이 Segment가 한 번 캡슐화되어 Packet이 된다. Packet의 최대 크기: MTU(Maximum Transport Unit) 일반적으로 1500이다. Packet의 구조: Header, Payload Header에는 IP(L3)와 TCP(L4) 데이터가 있다. 이때 크기는 일반적으로 각 20씩으로 총 40이다. MTU 크기 - Header 크기 = 1460이다. 이 크기가 MSS(Maximum Segment Size) 이다. Stream을 1460 크기로 나눈 것이다. H/W영역에서 Packet이 한 번 더 캡슐화된다. Frame이 된다. 13. L2 스위치 L2 스위치는 MAC 주소(48bit)로 스위칭시킨다.\n(multilayer switch) NIC L2 Access L2 Distribution L2 Access NIC | (Up-link) (Up-link) |---------------#---------------| PC1------| | |---------PC3 | | | | | | | | |---------PC4 PC2------| | | | | | | | (Up-link) | (gateway) @ 라우터 | (방화벽) L2 Access: End-Point가 네트워크에서 가장 처음 만나는 스위치 L2 Distribution: L2 Access와 L3 라우터를 연결해주는 스위치 Up-link: 상위 계층 스위치로 연결되는 케이블 14. IP Header 위에서 언급한 것처럼 IP의 헤더는 20바이트이다. (+ @ Opitonal)\n최상단 우측에 Total Length는 16비트인데, 이것은 패킷의 최대 크기를 나타낸다.\n따라서 패킷의 최대 크기는 2^16정도인 65536이다. Identification ~ Fragment Offset은 단편화에 관련된 부분이다.\n단편화는 큰 패킷을 작은 패킷으로 나눈 것을 말한다. MTU가 1400인 곳에 1500짜리 패킷을 보내는 경우 단편화가 일어난다. TTL은 패킷이 라우터 하나를 지날때마다 1씩 감소하고 0이 되면 패킷이 사라진다.\n일반적으로 값은 256이다. (2^8) Protocol은 상위 계층 프로토콜이다.\n이 값을 보고 데이터가 TCP인지 UDP 인지 다른 값인지 확인할 수 있다. Header checksum은 전송간에 오류가 있는지 확인한다.\n15. Proxy 구조와 원리 Proxy는 대리자 역할을 한다.\n\u0026lt;Proxy 미적용\u0026gt;\nHTTPS TCP/IP PC1 (1.1.1.1)--------------Internet--------------------SERVER(9.9.9.9) \u0026lt;Proxy 적용\u0026gt;\nPC1 (1.1.1.1) SERVER(9.9.9.9) | | | | Internet | | | | (Proxy) | PC2 (2.2.2.2)---------------- Internet---------------------| \u0026lt;PC2의 역할\u0026gt;\nuser mode | PC2 ============================================ - HTTP | Proxy 역할을 하는 - | Process - SSL | (Stream) | socket1 socket2 kernel mode | ============================================ - TCP, UDP | - IP | | H/W | ============================================ - Ethernet | - | socket1은 외부에서 접속하길 대기하고 있다. PC1이 접근 정보가 들어오면 socket2를 이용해서 9.9.9.9에 접근 16. Proxy의 활용 1. 우회 Proxy를 사용하면 SERVER 입장에서 PC2의 아이피를 확인한다.\n그러나 PC2는 PC1의 모든 통신을 감청할 수 있다.\n2. 분석 웹 통신에 SSL을 적용하면 패킷 레벨에서 데이터가 암호화되어 있다.\n때문에 와이어 샤크등 프로그램에서 복호화된 데이터를 확인할 수 없다.\n이때 프록시를 아래와 같이 사용할 수 있다.\nProxy를 127.0.0.1:8080으로 건다. (내 PC) HTTP 요청을 보내면 8080번 포트의 소켓으로 데이터가 지나간다. 이 평문 데이터를 Stream 레벨에서 확인한다. 17. TCP 송신/수신 원리 Stream을 Segment로 나눈다. 이때 TCP Buffer(Window Size)에 데이터를 저장하고, 일정 크기가 되면 Segment로 나눈다. Segment를 Packet으로 캡슐화한다. Packet을 Frame으로 캡슐화한다. Frame을 전달한다. 전체를 보내는 것은 아니다. (n개 만큼 보낸다.) 일반적으로 Frame은 바뀔 수 있다. (Packet은 그대로 이지만) Frame을 전달받고 Segment로 만든다. n개의 Segment를 받으면 TCP Buffer에 저장하고 ackn+1을 송신쪽에 전달한다. ack에는 Window Size가 포함되어 있다. 송신쪽은 ackn+1을 받고 Segment를 n+1번부터 다시 보낸다. 이 과정때문에 속도 지연이 발생한다. (UDP 보다 느리다.) 만약 ack로 받은 수신 측 Window Size가 작으면 Segment를 보내지 않는다. 18. TCP 연결에 대해 TCP는 연결지향 프로토콜이다.\n우선 아래 TCP 헤더를 보자\n출발지/목적지 Port 번호가 가장위에 위치한다. Sequence Number: 32bit → 4GB (2^32), Segment의 순서 TCP Flags: Ack, Sync 3-way handshake에 사용 3-way handshake\nSeq번호와 MSS를 교환하는 행위 혼잡 제어 정책 교환 19. Unicast, Broadcast, Multicast NIC L2 Access L2 Distribution L2 Access NIC | (Up-link) (Up-link) |---------------#---------------| PC1------| | |---------PC3 | | | | | | | | |---------PC4 PC2------| | | | | | | | (Up-link) | @ 라우터 (gateway) (방화벽) Unicast\nL2 스위치 내부에서 연결이 끝나는 것 (라우터 이전) 한번에 한 지점에게만 신호를 보낸다. Broadcast\n어떤 지점에서 다수의 지점에 신호를 보내는 것 네트워크 효율을 떨어뜨린다. 2진수 IP의 끝자리가 모두 1이다. (210.153.0.255) Multicast\nBroadcast와 유사하나 관심이 없는 지점은 신호를 보내지 않음 Group을 등록해서 Group에 전달함 20. IP의 종류 Global\n인터넷(public, global network)에서 라우터가 라우팅 시켜주는 IP이다. Private\n작은 소규모 사설 인터넷을 구축할 때 사용한다. 공유기에서도 자주 사용한다. 공유기는 하나의 Global IP를 Private IP에 공유해주는 역할을 한다. 4개의 클래스로 나뉜다. A: network id: 8bit host id: 24bit 10.xxx.xxx.xxx B network id: 12bit host id: 20bit 172.16.xxx.xxx C network id: 16bit host id: 16bit 192.168.xxx.xxx D multicast를 할 때 사용한다. Loopback\n127.0.0.1 호스트 자신을 의미한다. 패킷이 만들어지지만 L2로 가지는 않는다. Broadcast\n다수의 지점에 신호를 보낼 때 사용한다. 21. DNS Domain Name\n숫자로된 IP를 사람이 보기 편하도록 해준다. naver.com google.com DNS\nIP와 Domain Name을 연결하는 테이블 역할 DNS는 계층적 구조로 되어 있다. (분산형 DB 구조) 가장 상위 DNS인 root DNS는 전세계에 13대가 있다. Domain Name으로 IP를 찾는 과정\n컴퓨터 캐시에서 검색 host file에서 검색 DNS에서 검색 root DNS에서 .com, co.kr 등을 관리하는 DNS 목록을 검색 DNS 목록에서 검색 … 22. TCP/IP 통신과 MAC 주소 TCP/IP 통신을 할 때의 MAC 주소의 변화\n패킷이 프레임으로 캡슐화된다. 프레임 헤더에도 시작/목적 지점이 있다. L2 구간(라우터)을 지나면 프레임 헤더가 새로 교체된다. L2구간에 새로 접근할 때마다 프레임 헤더의 시작/목적 지점도 계속해서 변경된다. MAC 주소만 고려하고, IP 주소는 고려하지 않는다. 23. MTU와 Packet 단편화 위 그림에서 2번째 줄(Identification, Fragment Offset)이 단편화 관련 부분이다. MTU는 1500이 기본값인 경우가 많다. MTU - 20(IP 헤더) - 20(TCP 헤더) = MSS이다. 아래와 같은 경우에는 단편화가 어떻게 이루어 질까?\nMTU:1500 MTU:1500 MTU:1400 MTU:1500 MTU:1500 PC1 ---|---#-----R1-------------R2-------------R3-----SERVER 위 경우 R1 → R2에서 단편화가 이루어져야 한다. 1500짜리 패킷을 어느 지점에서 자른다. A와 B가 생긴다. 헤더와 A를 붙이고, 헤더와 B를 붙여서 2개의 패킷을 만든다. 이때 두 패킷 헤더의 Idenfication이 같은 값이 된다. Fragment Offset 값은 A는 0, B는 A의 길이만큼이 된다. 수신하는 쪽에서 단편화를 조립한다. (SERVER) 24. 서브넷팅 ISP(Internet Service Provider)에게 어떤 회사가 100개의 사설 IP를 요청하면 어떻게 될까?\nC레벨(Net ID: 24, Host ID: 8)인 private IP를 할당한다. 그런데 C레벨 private IP를 할당하면 2^8 - 100 = 146개의 IP를 낭비하게 되는 것이다. 이런 경우 서브넷팅을 사용할 수 있다. 서브넷팅은 Net ID에 몇 개의 비트를 더 할당하는 것이다.\n192.168.0.1/25라면 마지막 4번째 자리의 1의 가장 앞부분 비트를 Net ID로 할당 시킨다. (192.168.0.0)0000001 (192.168.0.1)0000001 하지만 Host ID가 0인 경우는 아무것도 가리키지 않고, 2진수에서 모두 1인 경우는 broadcast IP 이므로 서브넷 하나마다 2개의 IP를 손실보게 된다. 예를 들어 이 경우라면 192.168.0.1/25 192.168.0.00000000, 192.168.0.01111111 192.168.0.10000000, 192.168.0.11111111 위 4가지 IP를 손실보게 된다. Reference https://www.youtube.com/watch?v=k1gyh9BlOT8\u0026amp;list=PLXvgR_grOs1BFH-TuqFsfHqbh-gpMbFoy ","permalink":"https://jo-minjun.github.io/note/networkbasic/","summary":"1. MAC, IP, Port 번호의 식별 MAC, IP, Port는 각 다음과 같은 레이어의 식별자이다. * DoD로 구분한 Layer * user mode ============================================ - Application kernel mode ============================================ - Transport: PORT - Network: IP H/W ============================================ - Access: MAC Transport\nPort가 식별자가 된다. Network\nHost에 대해서 IP가 식별자가 된다. Host: 네트워크에 연결된 컴퓨터, NIC 하나에 IP 주소를 여러 개 바인딩 할 수 있다.\n→ Host에 IP가 여러개 존재한다. Access\nNetwork Interface Card에 대해서 MAC이 식별자가 된다.","title":"네트워크 기초 지식"},{"content":"1. 스프링이란? 스프링의 생태계 필수: 스프링 프레임워크, 스프링 부트\n선택: 스프링 데이터, 스프링 세션, 스프링 시큐리티, 스프링 Rest Docs, 스프링 배치, 스프링 클라우드\n가장 중요한 것: 스프링 프레임워크 핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트, 기타 웹 기술: 스프링 MVC, 스프링 webFlux 데이터 접근 기술: 트랜잭션, JDBC, ORM 지원, XML 지원 기술 통합: 캐시, 이메일, 원격접근, 스케줄링 테스트: 스프링 기반 테스트 지원 언어: 코틀린, 그루비 *최근에는 스프링 부트를 통해서 스프링 프레임워크의 기술들을 편리하게 사용한다.\n*스프링 부트:\n스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성 Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨 손쉬운 빌드 구성을 위한 starter 종속성 제공 스프링과 3rd party(외부) 라이브러리 자동 구성 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공 관례에 의한 간결한 설정 스프링 부트는 스프링 프레임워크를 기반으로 나머지 외부 라이브러리를 자동으로 구성해주는 기술이지, 자체적으로 사용할 수 있는 것이 아님 스프링의 의미 스프링이라는 단어는 문맥에 따라 다르게 사용된다. 스프링 DI 컨테이너 기술 스프링 프레임워크 스프링 부트, 스프링 프레임워크 등을 모두 포함한 스프링 생태계 스프링의 핵심 개념 자바 언어 기반의 프레임워크 자바 언어의 가장 큰 특징 - 객체 지향 언어 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크 객체 지향 프로그래밍은 스프링의 근원 2. 좋은 객체 지향 프로그래밍이란? 객체 지향 프로그래밍이란? 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러개의 독립된 단위, 즉 “객체\u0026ldquo;들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 메세지를 주고받고 데이터를 처리한다. (협력) 객체 지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다. 유연하고 변경이 용이?\n레고 블럭 조립하듯이 키보드, 마우스 갈아 끼우듯이 컴퓨터 부품 갈아 끼우듯이 컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법 객체 지향의 특징 추상화 캡슐화 상속 다형성 → 유연하고 변경이 용이하도록 하는데에 크게 기여함 다형성의 실세계 비유 실세계와 객체 지향이 1:1로 매칭되지는 않음 그러나 실세계의 비유로 이해하기 편리함 역할과 구현으로 세상을 구분 운전자 - 자동차 예시\n자동차의 역할(인터페이스)을 3개의 자동차로 구현함 운전자는 K3를 타다가 아반떼로 차를 변경할 수 있음 차가 바뀌어도 운전자는 운전을 할 수 있음 → 유연하고 변경이 용이 클라이언트에 영향을 주지 않고, 새로운 기능을 제공할 수 있음 → 유연하고 변경이 용이 이외의 예시\n공연에서 각 인물의 역할 키보드, 마우스, 세상의 표준 인터페이스들 정렬 알고리즘 할인 정책 예시\n역할과 구현을 분리 역할과 구현으로 구분하면 세상이 단순해지고 유연해지며, 변경도 편리해진다. 장점 클라이언트는 대상의 역할(인터페이스)만 알면 된다. 클라이언트는 구현 대상의 내부 구조를 몰라도 된다. 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다. 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다. 자바 언어에서의 역할과 구현 자바 언어의 다형성을 활용 역할: 인터페이스 구현: 인터페이스를 구현한 클래스, 구현 객체 객체를 설계할 때 역할과 구현을 명확히 분리 객체 설계시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기 (구현보다 역할이 중요하다.) 객체의 협력이라는 관계부터 생각 혼자있는 객체는 없다. 클라이언트: 요청 서버: 응답 수 많은 객체 클라이언트와 객체 서버는 서로 협력 관계를 가진다. 자바 언어의 다형성 오버라이딩을 떠올려보자 오버라이딩된 메서드가 실행 다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경할 수 있다. 물론 상속 관계도 다형성, 오버라이딩 적용 가능 public class MemberService { private MemberRepository memberRepository1 = new MemoryMemberRepository(); private MemberRepository memberRepository2 = new JdbcMemberRepository(); } 다형성의 본질 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다. 다형성의 본질을 이해하려면 협력이라는 객체 사이의 관계에서 시작해야함 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다. 역할과 구현을 분리 - 정리 실세계의 역할과 구현이라는 편리한 컨셉을 다형성을 통해 객체 세상으로 가져올 수 있음 유연하고, 변경이 용이 확장 가능한 설계 클라이언트에 영향을 주지 않는 변경 가능 인터페이스를 안정적으로 잘 설계하는 것이 중요 역할과 구현을 분리 - 한계 역할(인터페이스) 자체가 변하면 클라이언트, 서버 모두에 큰 변경이 발생한다. 자동차를 비행기로 변경해야 한다면? 대본 자체가 변경된다면? USB 인터페이스 자체가 변경된다면? 인터페이스를 안정적으로 잘 설계하는 것이 중요 스프링과 객체 지향 다형성이 가장 중요하다! 스프링은 다형성을 극대화해서 이용할 수 있게 도와준다. 스프링에서 이야기하는 제어의 역전(IoC), 의존관계 주입(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다. 스프링을 사용하면 마치 레고 블럭 조립하듯이, 공연 무대의 배우를 선택하듯이, 구현을 편리하게 변경할 수 있다. 그리고 또 중요한 것 - SOLID 3. 좋은 객체 지향 설계의 5가지 원칙 (SOLID) SOLID 클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리\nSRP: 단일 책임 원칙 (Single Responsibility Principle) OCP: 개방 - 폐쇄 원칙 (Open - Closed Principle) LSP: 리스코프 치환 원칙 (Liskov Substitution Principle) ISP: 인터페이스 분리 원칙 (Interface Segregation Principle) DIP: 의존관계 역전 원칙 (Dependency Inversion Principle) SRP: 단일 책임 원칙 (Single Responsibility Principle) 한 클래스는 하나의 책임만 가져야 한다. 하나의 책임이라는 것은 모호하다. 클 수 있고, 작을 수 있다. 문맥과 상황에 따라 다르다. 중요한 기준은 변경이다. 변경이 있을 때 파급효과가 적으면 단일 책임 원칙을 잘 따른 것 Ex) UI 변경, 객체의 생성과 사용을 분리 OCP: 개방 - 폐쇄 원칙 (Open - Closed Principle) 가장 중요한 원칙 소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야 한다. 다형성을 활용 인터페이스를 구현한 클래스를 하나 만들어서 새로운 기능을 구현 지금까지 배운 역할과 구현의 분리를 생각해보자 Ex) 운전자 - 자동차 자동차가 바뀌어도 운전자는 똑같이 운전함 → 확장에 열림 문제점 MemberService 클라이언트가 구현 클래스를 직접 선택 public class MemberService { // 기존 코드 // private MemberRepository memberRepository1 = new MemoryMemberRepository(); // 변경 코드 private MemberRepository memberRepository2 = new JdbcMemberRepository(); } 구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다. 다형성을 사용했지만 OCP 원칙을 지킬 수 없다. 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다. 이 역할을 스프링 컨테이너가 해결해줌 LSP: 리스코프 치환 원칙 (Liskov Substitution Principle) 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스를 바꿀 수 있어야 한다. 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것 다형성을 지원하기 위한 원칙 인터페이스를 구현한 구현체를 믿고 사용하려면 이 원칙이 필요하다. 단순히 컴파일에 성공하는 것을 넘어서는 이야기 Ex) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능 → 뒤로가게 구현하면 리스코프 치환 원칙 위반 ISP: 인터페이스 분리 원칙 (Interface Segregation Principle) 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다. 자동차 인터페이스 → 운전 인터페이스, 정비 인터페이스로 분리 사용자 클라이언트 → 운전자 클라이언트, 정비사 클라이언트로 분리 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음 인터페이스가 명확해지고, 대체 가능성이 높아진다. DIP: 의존관계 역전 원칙 (Dependency Inversion Principle) “추상화에 의존해야지, 구체화에 의존하면 안된다.” 이 원칙을 따르는 방법 중 하나다. 쉽게 이야기 해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻 앞에서 이야기한 역할에 의존하게 해야 한다는 것과 같다. 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다. 구현체에 의존하게 되면 변경이 아주 어려워진다. Ex) 운전자 - 자동차 운전자는 운전 역할에 의존해야지, 자동차 종류에 의존할 경우 차량이 바뀌면 운전이 어려워짐 그런데 개방 - 폐쇄 원칙에서 설명한 MemberService는 인터페이스에 의존하지만, 구현 클래스도 동시에 의존한다. MemberService가 구현 클래스를 직접 선택 → DIP 위반 정리 객체 지향의 핵심은 다형성 다형성만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다. 다형성만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다. 다형성만으로는 개방 - 폐쇄 원칙, 의존관계 역전 원칙을 지킬 수 없다. 4. 객체 지향 설계와 스프링 왜 스프링 이야기에 객체 지향이야기가 나오는가? 스프링은 다음 기술로 다형성 + 개방 - 폐쇄 원칙, 의존관계 역전 원칙을 가능하게 지원한다. DI (Dependency Injection): 의존관계, 의존성 주입 DI 컨테이너 제공 클라이언트 코드의 변경 없이 기능 확장 쉽게 부품을 교체하듯이 개발 총 정리 모든 설계에 역할과 구현을 분리하자 자동차, 공연의 예를 떠올려보자 애플리케이션 설계도 공연을 설계하듯이 배역만 만들어두고, 배우는 언제든지 유연하게 변경할 수 있도록 만드는 것이 좋은 객체 지향 설계이다. 이상적으로는 모든 설계에 인터페이스를 부여하자. 실무 고민 하지만 인터페이스를 도입하면 추상화라는 비용이 발생한다. 인터페이스도 만들고 구현체도 만들고 개발자가 구현된 코드가 안보여서 한 번더 열어봐야 됨 기능을 확장할 가능성이 없다면 구체 클래스를 직접 사용하고, 향후에 꼭 필요할 때 리팩토링을 해서 인터페이스를 도입하는 것도 방법이다. Reference 인프런 강의 스프링 핵심 원리(김영한) ","permalink":"https://jo-minjun.github.io/note/spring-core-basic/","summary":"1. 스프링이란? 스프링의 생태계 필수: 스프링 프레임워크, 스프링 부트\n선택: 스프링 데이터, 스프링 세션, 스프링 시큐리티, 스프링 Rest Docs, 스프링 배치, 스프링 클라우드\n가장 중요한 것: 스프링 프레임워크 핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트, 기타 웹 기술: 스프링 MVC, 스프링 webFlux 데이터 접근 기술: 트랜잭션, JDBC, ORM 지원, XML 지원 기술 통합: 캐시, 이메일, 원격접근, 스케줄링 테스트: 스프링 기반 테스트 지원 언어: 코틀린, 그루비 *최근에는 스프링 부트를 통해서 스프링 프레임워크의 기술들을 편리하게 사용한다.","title":"객체 지향 설계와 스프링"}]