<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Kafka on minjun's memory</title><link>https://jo-minjun.github.io/tags/kafka/</link><description>Recent content in Kafka on minjun's memory</description><image><title>minjun's memory</title><url>https://jo-minjun.github.io/logo.png</url><link>https://jo-minjun.github.io/logo.png</link></image><generator>Hugo -- gohugo.io</generator><language>kr</language><lastBuildDate>Sat, 02 Jul 2022 18:12:21 +0900</lastBuildDate><atom:link href="https://jo-minjun.github.io/tags/kafka/index.xml" rel="self" type="application/rss+xml"/><item><title>Avro schema</title><link>https://jo-minjun.github.io/notes/avro-schema/</link><pubDate>Sat, 02 Jul 2022 18:12:21 +0900</pubDate><guid>https://jo-minjun.github.io/notes/avro-schema/</guid><description>1. Avro 란? 아브로(Avro)는 아파치의 하둡 프로젝트에서 개발된 RPC 및 데이터 직렬화 프레임워크이다.
schema를 json으로 정의하여 바이너리 포맷으로 직렬화 한다.
2. 장점 데이터의 타입을 알 수 있다. 스키마가 직렬화되어 네트워크 통신에 자유롭다. 스키마에 설명이 포함되어 schema 구조를 이해하는데 도움을 준다. 다양한 language를 지원한다. (java, c, c++ 등) default 값을 정의할 수 있다. 3. Data Type 이름 태그 null no value boolean a binary value int 32bit signed integer long 62bit signed integer float single precision(단정밀도) 32bit floating-point number double double percision(배정밀도) 64bit floating-point number bytes sequence of 8-bit unsigned bytes string unicode character sequence Enums name, namespace, aliases, doc, symbols, default 등을 가진다.</description><content:encoded><![CDATA[<h2 id="1-avro-란">1. Avro 란?</h2>
<p>아브로(Avro)는 아파치의 하둡 프로젝트에서 개발된 RPC 및 데이터 직렬화 프레임워크이다.<br>
schema를 json으로 정의하여 바이너리 포맷으로 직렬화 한다.</p>
<h2 id="2-장점">2. 장점</h2>
<ol>
<li>데이터의 타입을 알 수 있다.</li>
<li>스키마가 직렬화되어 네트워크 통신에 자유롭다.</li>
<li>스키마에 설명이 포함되어 schema 구조를 이해하는데 도움을 준다.</li>
<li>다양한 language를 지원한다. (java, c, c++ 등)</li>
<li>default 값을 정의할 수 있다.</li>
</ol>
<h2 id="3-data-type">3. Data Type</h2>
<table>
<thead>
<tr>
<th>이름</th>
<th>태그</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>null</code></td>
<td>no value</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>a binary value</td>
</tr>
<tr>
<td><code>int</code></td>
<td>32bit signed integer</td>
</tr>
<tr>
<td><code>long</code></td>
<td>62bit signed integer</td>
</tr>
<tr>
<td><code>float</code></td>
<td>single precision(단정밀도) 32bit floating-point number</td>
</tr>
<tr>
<td><code>double</code></td>
<td>double percision(배정밀도) 64bit floating-point number</td>
</tr>
<tr>
<td><code>bytes</code></td>
<td>sequence of 8-bit unsigned bytes</td>
</tr>
<tr>
<td><code>string</code></td>
<td>unicode character sequence</td>
</tr>
</tbody>
</table>
<h3 id="enums">Enums</h3>
<p>name, namespace, aliases, doc, symbols, default 등을 가진다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;enum&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;Suit&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;symbols&#34;</span>: [<span style="color:#e6db74">&#34;SPADES&#34;</span>, <span style="color:#e6db74">&#34;HEARTS&#34;</span>, <span style="color:#e6db74">&#34;DIAMONDS&#34;</span>, <span style="color:#e6db74">&#34;CLUBS&#34;</span>]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="arrays">Arrays</h3>
<p>items를 가진다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;array&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;items&#34;</span>: <span style="color:#e6db74">&#34;string&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;default&#34;</span>: []
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="maps">Maps</h3>
<p>values를 가진다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;map&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;values&#34;</span>: <span style="color:#e6db74">&#34;long&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;default&#34;</span>: {}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="unions">Unions</h3>
<p>string, int, boolean 등과 같은 여러개의 서로 다른 타입을 가짐으로써 선택적인 값을 저장할 수 있도록 한다.</p>
<h2 id="4-schema-필드">4. Schema 필드</h2>
<table>
<thead>
<tr>
<th>이름</th>
<th>태그</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>json을 지원하는 스키마의 이름</td>
</tr>
<tr>
<td>namespace</td>
<td>name을 구별하는 패키지</td>
</tr>
<tr>
<td>doc</td>
<td>스키마를 설명하는 doc</td>
</tr>
<tr>
<td>aliases</td>
<td>name의 별칭</td>
</tr>
<tr>
<td>fields</td>
<td>name, doc, type, default, order, aliases 등을 가지는 json type object</td>
</tr>
</tbody>
</table>
<h2 id="5-avro-schema-예시">5. Avro Schema 예시</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;record&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;LongList&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;aliases&#34;</span>: [<span style="color:#e6db74">&#34;LinkedLongs&#34;</span>], <span style="color:#75715e">// old name for this
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#f92672">&#34;fields&#34;</span>: [
</span></span><span style="display:flex;"><span>    { <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;value&#34;</span>, <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;long&#34;</span> }, <span style="color:#75715e">// each element has a long
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    { <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;next&#34;</span>, <span style="color:#f92672">&#34;type&#34;</span>: [<span style="color:#e6db74">&#34;null&#34;</span>, <span style="color:#e6db74">&#34;LongList&#34;</span>] } <span style="color:#75715e">// optional next element
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&#34;type&#34;</span> : <span style="color:#e6db74">&#34;record&#34;</span>,
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&#34;namespace&#34;</span> : <span style="color:#e6db74">&#34;tutorialspoint&#34;</span>,
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&#34;name&#34;</span> : <span style="color:#e6db74">&#34;empdetails &#34;</span>,
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&#34;fields&#34;</span> :
</span></span><span style="display:flex;"><span>   [
</span></span><span style="display:flex;"><span>      { <span style="color:#f92672">&#34;name&#34;</span> : <span style="color:#e6db74">&#34;experience&#34;</span>, <span style="color:#f92672">&#34;type&#34;</span>: [<span style="color:#e6db74">&#34;int&#34;</span>, <span style="color:#e6db74">&#34;null&#34;</span>] },
</span></span><span style="display:flex;"><span>      { <span style="color:#f92672">&#34;name&#34;</span> : <span style="color:#e6db74">&#34;age&#34;</span>, <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;int&#34;</span> }
</span></span><span style="display:flex;"><span>      {<span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;additional&#34;</span>, <span style="color:#f92672">&#34;type&#34;</span>: {<span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;map&#34;</span>, <span style="color:#f92672">&#34;values&#34;</span>: <span style="color:#e6db74">&#34;string&#34;</span>}}
</span></span><span style="display:flex;"><span>   ]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>]]></content:encoded></item><item><title>Schema registry란?</title><link>https://jo-minjun.github.io/notes/schema-registry/</link><pubDate>Fri, 01 Jul 2022 21:42:30 +0900</pubDate><guid>https://jo-minjun.github.io/notes/schema-registry/</guid><description>1. Schema registry 란? 데이터 관리의 중요한 관점들 중 하나는 schema의 버전 관리이다. 응용프로그램의 시간이 지날수록 schema가 정의되기 시작한 시점부터 schema는 점점 바뀌어가고, producer와 consumer는 직접적인 관계가 끊어져있기 때문에 운영상에 발생하는 이슈가 있다.
producer는 consumer가 어떤 메세지를 소비할지 알 수 없다.
consumer는 producer가 어떤 메세지를 생산했는지 알 수 없다.
위와 같은 상황에서 producer가 갑자기 다른 schema를 이용해서 메세지를 생산할 경우, consumer는 이 메세지에 대해서 대처하지 못할 수 있다.
이는 구조적인 결합도는 낮지만, 메세지 schema에 대한 의존성이 높기 때문인데, schema registry는 이를 보완하기 위해 고안되었다.</description><content:encoded><![CDATA[<h2 id="1-schema-registry-란">1. Schema registry 란?</h2>
<p>데이터 관리의 중요한 관점들 중 하나는 schema의 버전 관리이다.
응용프로그램의 시간이 지날수록 schema가 정의되기 시작한 시점부터 schema는 점점 바뀌어가고,
producer와 consumer는 직접적인 관계가 끊어져있기 때문에 운영상에 발생하는 이슈가 있다.</p>
<blockquote>
<p>producer는 consumer가 어떤 메세지를 소비할지 알 수 없다.<br>
consumer는 producer가 어떤 메세지를 생산했는지 알 수 없다.</p>
</blockquote>
<p>위와 같은 상황에서 producer가 갑자기 다른 schema를 이용해서 메세지를 생산할 경우, consumer는 이 메세지에 대해서 대처하지 못할 수 있다.</p>
<p>이는 구조적인 결합도는 낮지만, 메세지 schema에 대한 의존성이 높기 때문인데,
schema registry는 이를 보완하기 위해 고안되었다.</p>
<p>Confluent Schema registry는 Avro, Json, Protobuf 등의 schema 정보의 history를 subjects를 통해 관리하며, REST API를 통해 <strong>compatibility settings</strong>을 결정하고 현재 버전과 이전 버전간의 호환성을 지원한다.</p>
<p><img loading="lazy" src="/images/notes/schema-registry/schema-registry-kafka.png" alt="schema-registry-kafka.png"  />
</p>
<p>Schema registry는 kafka boroker와 독립적으로 존재하며, producer와 consumer는 kafka broker와 읽고 쓰는 동안 Schema registry와 동작하며 데이터 모델을 확인할 수 있다.</p>
<h2 id="2-schemas-subjects-and-topics-란">2. Schemas, Subjects and Topics 란?</h2>
<p>topic은 kafka의 topic을, schema는 Avro, Json, Protobuf 등으로 정의된 데이터 포맷 구조를 의미한다.</p>
<p>Subject는 Schema registry에 schema가 등록된 이름이며, 여러 버전의 schema가 등록될 수 있다.</p>
<p>따라서 Subject를 통해 계속해서 Schema의 정보를 관리할 수 있고, 새로운 버전의 Schema ID와 버전을 확인할 수 있다.</p>
<p><img loading="lazy" src="/images/notes/schema-registry/schema-subject-topic.png" alt="schema registry.png"  />
</p>
<ul>
<li>kafka topic은 메세지가 포함되어 있으며, 각 메세지는 key - value 쌍으로 되어있으며
메세지의 key와 value는 Avro, Json, Protobuf 등으로 직렬화할 수 있다.</li>
<li>Schema는 데이터 포맷의 구조를 정의한다.</li>
<li>kafka의 topic 이름은 schema의 이름과 의존적이지 않다.</li>
<li>Schema의 ID는 전역적이다.</li>
</ul>
<h2 id="3-compatibility-settings-란">3. Compatibility settings 란?</h2>
<p>schema compatibility checking는 모든 schema를 버전화해서 schema registry compatibility type에 의해서 구현된다.</p>
<p>즉, 아래의 schema 전략에 의한 패턴으로 호환성을 유지하게 된다.</p>
<table>
<thead>
<tr>
<th>Compatibility type</th>
<th>허가되는 변경</th>
<th>비교하는 schema</th>
<th>upgrade 순서</th>
</tr>
</thead>
<tbody>
<tr>
<td>BACKWARD</td>
<td>- 필드 삭제<!-- raw HTML omitted -->- Optional 필드 추가</td>
<td>마지막 버전</td>
<td>Consumers</td>
</tr>
<tr>
<td>BACKWARD_TRANSITIVE</td>
<td>- 필드 삭제<!-- raw HTML omitted -->- Optional 필드 추가</td>
<td>모든 이전 버전</td>
<td>Consumers</td>
</tr>
<tr>
<td>FORWARD</td>
<td>- 필드 추가<!-- raw HTML omitted -->- Optional 필드 삭제</td>
<td>마지막 버전</td>
<td>Producers</td>
</tr>
<tr>
<td>FORWARD_TRANSITIVE</td>
<td>- 필드 추가<!-- raw HTML omitted -->- Optional 필드 삭제</td>
<td>모든 이전 버전</td>
<td>Producers</td>
</tr>
<tr>
<td>FULL</td>
<td>- Optional 필드 추가<!-- raw HTML omitted -->- Optional 필드 삭제</td>
<td>마지막 버전</td>
<td>Any order</td>
</tr>
<tr>
<td>FULL_TRANSITIVE</td>
<td>- Optional 필드 추가<!-- raw HTML omitted -->- Optional 필드 삭제</td>
<td>모든 이전 버전</td>
<td>Any order</td>
</tr>
<tr>
<td>NONE</td>
<td>모든 변경 허용</td>
<td>비교하지 않음</td>
<td>Depends</td>
</tr>
</tbody>
</table>
<ul>
<li><code>BACKWARD</code>: (<em>default</em>) consumer가 새로운 스키마를 사용하여 producer가 마지막 버전의 스키마로 생성한 메세지를 읽을 수 있다.
(새로운 스키마로 이전 스키마 메세지를 읽는다.)
(새로운 스키마 필드에 default value가 없으면 오류가 발생한다.)</li>
<li><code>BACKWARD_TRANSITIVE</code>: consumer가 새로운 스키마를 사용하여 producer가 모든 마지막 버전 스키마로 생성한 메세지를 읽을 수 있다.</li>
<li><code>FORWARD</code>: consumer가 마지막 버전의 스키마를 사용하여 producer가 새로운 스키마로 생성한 메세지를 읽을 수 있다.
(이전 스키마로 새로운 스키마 데이터를 읽는다.)
(새로운 스키마에서 필드가 삭제되면, 이전 스키마에 default value가 있어야 한다.)</li>
<li><code>FORWARD_TRANSITIVE</code>: consumer가 모든 마지막 버전의 스키마를 사용하여 producer가 새로운 스키마로 생성한 메세지를 읽을 수 있다.</li>
<li><code>FULL</code>: <code>BACKWARD</code> 와 <code>FORWARD</code> 를 모두 만족한다.</li>
<li><code>FULL_TRANSITIVE</code>: <code>BACKWARD_TRANSITIVE</code> 와 <code>FORWARD_TRANSITIVE</code> 를 모두 만족한다.</li>
<li><code>NONE</code>: schema compatibility checks are disabled</li>
</ul>
<h2 id="4-rest-api-interface-reference---schemas-subjects">4. Rest API Interface Reference - Schemas, Subjects</h2>
<p>Schema Registry REST API 서버는 사용된 API의 버전과 데이터의 직렬화 포맷을 표시하기 위해 요청과 응답에 content type을 사용한다.</p>
<p>현재는 직렬화 포맷은 JSON만을 지원하고 API의 버전은 v1만 사용할 수 있다.
하지만 나중 버전의 호환을 위해서 반드시 content type을 사용해야한다.</p>
<p>추천하는 content type은 <code>application/vnd.schemaregistry.v1+json</code>이다.
v1은 API의 버전이고, json은 직렬화 포맷이다.</p>
<p>모든 API endpoint는 다음과 같은 error message 포맷을 사용한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">422</span> Unprocessable Entity
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;error_code&#34;</span>: 422,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;message&#34;</span>: <span style="color:#e6db74">&#34;schema may not be empty&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><blockquote>
<p>추가적으로 요청시 json은 string 형태로 전달해야 한다.</p>
</blockquote>
<h3 id="schemas-관련">Schemas 관련</h3>
<h4 id="getschemasidsintid"><code>GET /schemas/ids/{int: id}</code></h4>
<p>입력한 id를 이용하여 스키마 정보를 요청한다.</p>
<blockquote>
<p><strong>Parameters:</strong><br>
id (int) - 전역적으로 unique한 스키마 id</p>
</blockquote>
<p><strong>Response JSON Object:</strong>
schema (string) - id로 구분한 schema string</p>
<p><strong>Status Codes:</strong>
404 Not Found - schema not found
500 Internal Server Error - Error in the backend datastore</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /schemas/ids/1 HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;schema&#34;</span>: <span style="color:#e6db74">&#34;{\&#34;type\&#34;: \&#34;string\&#34;}&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h4 id="getschemastypes"><code>GET /schemas/types/</code></h4>
<p>Schema Registry에 저장된 스키마 타입을 요청한다.</p>
<blockquote>
<p><strong>Response JSON Object:</strong>
schema (string) - Schema Registry에서 현재 사용가능한 스키마 타입</p>
</blockquote>
<p><strong>Status Codes:</strong>
404 Not Found - schema not found
500 Internal Server Error - Error in the backend datastore</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /schemas/types HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;JSON&#34;</span>, <span style="color:#e6db74">&#34;PROTOBUF&#34;</span>, <span style="color:#e6db74">&#34;AVRO&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h4 id="getschemasidsintidversions"><code>GET /schemas/ids/{int: id}/versions</code></h4>
<p>Schema Registry에 저장된 스키마 타입을 요청한다.</p>
<blockquote>
<p><strong>Parameters:</strong><br>
id (int) - 전역적으로 unique한 스키마 id</p>
</blockquote>
<p><strong>Response JSON Object:</strong>
subject - subject의 이름
version - return된 subject의 버전</p>
<p><strong>Status Codes:</strong>
404 Not Found - schema not found
500 Internal Server Error - Error in the backend datastore</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /schemas/ids/1/versions HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[{</span><span style="color:#e6db74">&#34;subject&#34;</span>:<span style="color:#e6db74">&#34;test-subject1&#34;</span>,<span style="color:#e6db74">&#34;version&#34;</span>:1<span style="color:#f92672">}]</span>
</span></span></code></pre></div><h3 id="subjects-관련">Subjects 관련</h3>
<blockquote>
<p>subject resource는 Schema Registry에 저장된 모든 subject 목록을 제공한다.<br>
subject는 스키마가 저장된 이름을 나타낸다.<br>
만약 Kafka에 Schema Registry를 사용하고 있다면, subject는 topic에 대한 key 또는 value 스키마를 등록하고 있는지에 따라 <code>&lt;topic&gt;-key</code> 또는 <code>&lt;topic&gt;-value</code>를 참조한다.</p>
</blockquote>
<h4 id="getsubjects"><code>GET /subjects</code></h4>
<p>Schema Registry에 저장된 subject의 목록을 요청한다.</p>
<blockquote>
<p><strong>Parameters:</strong><br>
subject (string) - subject의 이름<br>
deleted (boolean) - default는 false이다. <code>?deleted=true</code>로 요청하면 soft delete된 subject 목록을 함께 return 한다.</p>
</blockquote>
<p><strong>Response JSON Object:</strong>
name (string) - subject</p>
<p><strong>Status Codes:</strong>
500 Internal Server Error - Error in the backend datastore</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /subjects HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span><span style="color:#e6db74">&#34;subject1&#34;</span>, <span style="color:#e6db74">&#34;subject2&#34;</span><span style="color:#f92672">]</span>
</span></span></code></pre></div><h4 id="getsubjectsstring-subjectversions"><code>GET /subjects/(string: subject)/versions</code></h4>
<p>Schema Registry에 저장된 subject의 버전 목록을 요청한다.</p>
<blockquote>
<p><strong>Parameters:</strong><br>
subject (string) - subject의 이름</p>
</blockquote>
<p><strong>Response JSON Object:</strong>
version (int) - subject 아래에 저장된 스키마의 버전</p>
<p><strong>Status Codes:</strong>
404 Not Found - schema not found
500 Internal Server Error - Error in the backend datastore</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /subjects/test/versions HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>  1, 2, 3, <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">]</span>
</span></span></code></pre></div><h4 id="deletesubjectsstringsubject"><code>DELETE /subjects/(string: subject)</code></h4>
<p>등록된 특정 subject를 삭제한다.
이 API는 topic을 재사용하거나 개발 환경에서만 사용하는 것이 권장된다.</p>
<blockquote>
<p><strong>Parameters:</strong><br>
subject (string) - subject의 이름<br>
permanent (boolean) - <code>?permanent=true</code>를 추가하여 hard delete를 표시한다.</p>
</blockquote>
<p><strong>Response JSON Object:</strong>
version (int) - subject 아래에 저장된 스키마의 버전</p>
<p><strong>Status Codes:</strong>
404 Not Found - schema not found
500 Internal Server Error - Error in the backend datastore</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>DELETE /subjects/test HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>  1, 2, 3, <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">]</span>
</span></span></code></pre></div><h4 id="getsubjectsstringsubjectversionsversionidversion"><code>GET /subjects/(string: subject)/versions/(versionId: version)</code></h4>
<p>등록된 특정 subject를 요청한다.</p>
<blockquote>
<p><strong>Parameters:</strong><br>
subject (string) - subject의 이름<br>
version (versionId) - return될 스키마의 버전이다. [1, 2^31 - 1] 또는 latest가 유효한 값이다.</p>
</blockquote>
<p><strong>Response JSON Object:</strong>
subject (string) - subject의 이름
id (int) - 전역적으로 unique한 shema의 id
version (int) - subject 아래에 저장된 return될 스키마의 버전
schemaType (string) - schema의 format (default: AVRO)
schema (string) - schema의 내용</p>
<p><strong>Status Codes:</strong>
404 Not Found - schema not found
422 Unprocessable Entity - Invalid version
500 Internal Server Error - Error in the backend datastore</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /subjects/test/versions/1 HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;test&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;version&#34;</span>: 1,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;schema&#34;</span>: <span style="color:#e6db74">&#34;{\&#34;type\&#34;: \&#34;string\&#34;}&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h4 id="getsubjectsstringsubjectversionsversionidversionschema"><code>GET /subjects/(string: subject)/versions/(versionId: version)/schema</code></h4>
<p>등록된 특정 subject를 요청한다. unescaped schema만 return 된다.?</p>
<blockquote>
<p><strong>Parameters:</strong><br>
subject (string) - subject의 이름<br>
version (versionId) - return될 스키마의 버전이다. [1, 2^31 - 1] 또는 latest가 유효한 값이다.</p>
</blockquote>
<p><strong>Response JSON Object:</strong>
schema (string) - schema의 내용</p>
<p><strong>Status Codes:</strong>
404 Not Found - subject not found or version not found
422 Unprocessable Entity - Invalid version
500 Internal Server Error - Error in the backend datastore</p>
<blockquote>
</blockquote>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /subjects/test/versions/1/schema HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span><span style="color:#e6db74">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;string&#34;</span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h4 id="postsubjectsstringsubjectversions"><code>POST /subjects/(string: subject)/versions</code></h4>
<p>등록된 특정 subject에 새로운 스키마를 등록한다.
만약 성공적으로 등록되면, unique한 스키마의 id가 return 된다.
동일한 스키마가 다른 subject에 등록되면 동일한 id가 return 된다. 그라나 스키마의 버전은 subject에 따라 다를 수 있다.</p>
<blockquote>
<p><strong>Parameters:</strong><br>
subject (string) - subject의 이름<br>
normalize (boolean) - <code>?normalize=true</code>를 추가하여 normalize 상태를 표시한다.?</p>
</blockquote>
<p><strong>Request JSON Object:</strong>
schema (string) - schema의 내용
schemaType - 스키마의 포맷 (default: AVRO)
references - 스키마의 이름 지정 (optional)</p>
<p><strong>Response JSON Object:</strong>
subject (string) - subject의 이름
id (int) - 전역적으로 unique한 스키마의 id
version (int) - return 되는 스키마의 버전
schema (string) - schema의 내용</p>
<p><strong>Status Codes:</strong>
409 Conflic - Incompatible schema
422 Unprocessable Entity - Invalid version
500 Internal Server Error - Error in the backend datastore or Operation timed out or Error while forwarding the request to the primary</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>POST /subjects/test/versions HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;schema&#34;</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">       \&#34;type\&#34;: \&#34;record\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">       \&#34;name\&#34;: \&#34;test\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">       \&#34;fields\&#34;:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         [
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             \&#34;type\&#34;: \&#34;string\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             \&#34;name\&#34;: \&#34;field1\&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           },
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             \&#34;type\&#34;: \&#34;com.acme.Referenced\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             \&#34;name\&#34;: \&#34;int\&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">          ]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     }&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;schemaType&#34;</span>: <span style="color:#e6db74">&#34;AVRO&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;references&#34;</span>: <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>       <span style="color:#e6db74">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;com.acme.Referenced&#34;</span>,
</span></span><span style="display:flex;"><span>       <span style="color:#e6db74">&#34;subject&#34;</span>:  <span style="color:#e6db74">&#34;childSubject&#34;</span>,
</span></span><span style="display:flex;"><span>       <span style="color:#e6db74">&#34;version&#34;</span>: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span><span style="color:#e6db74">&#34;id&#34;</span>:1<span style="color:#f92672">}</span>
</span></span></code></pre></div><h4 id="postsubjectsstringsubject"><code>POST /subjects/(string: subject)</code></h4>
<p>특정 subject에 schema가 이미 등록됐는지 확인한다.
만약 존재하면 전역적으로 unique한 id와 schema를 return 한다.</p>
<blockquote>
<p><strong>Parameters:</strong><br>
subject (string) - subject의 이름<br>
normalize (boolean) - <code>?normalize=true</code>를 추가하여 normalize 상태를 표시한다.</p>
</blockquote>
<p><strong>Request JSON Object:</strong>
schema (string) - schema의 내용
schemaType - 스키마의 포맷 (default: AVRO)
references - 스키마의 이름 지정 (optional)</p>
<p><strong>Response JSON Object:</strong>
subject (string) - subject의 이름
id (int) - 전역적으로 unique한 스키마의 id
version (int) - return 되는 스키마의 버전
schema (string) - schema의 내용</p>
<p><strong>Status Codes:</strong>
404 Not Found - Subject not found
500 Internal Server Error - Internal server error</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>POST /subjects/test HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;schema&#34;</span>:
</span></span><span style="display:flex;"><span>         <span style="color:#e6db74">&#34;{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                \&#34;type\&#34;: \&#34;record\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                \&#34;name\&#34;: \&#34;test\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                \&#34;fields\&#34;:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                  [
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                      \&#34;type\&#34;: \&#34;string\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                      \&#34;name\&#34;: \&#34;field1\&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    },
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                      \&#34;type\&#34;: \&#34;int\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                      \&#34;name\&#34;: \&#34;field2\&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                  ]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">              }&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;subject&#34;</span>: <span style="color:#e6db74">&#34;test&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;id&#34;</span>: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;version&#34;</span>: <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;schema&#34;</span>:
</span></span><span style="display:flex;"><span>         <span style="color:#e6db74">&#34;{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                \&#34;type\&#34;: \&#34;record\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                \&#34;name\&#34;: \&#34;test\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                \&#34;fields\&#34;:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                  [
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                      \&#34;type\&#34;: \&#34;string\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                      \&#34;name\&#34;: \&#34;field1\&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    },
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                      \&#34;type\&#34;: \&#34;int\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                      \&#34;name\&#34;: \&#34;field2\&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                  ]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">              }&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span></code></pre></div><h4 id="deletesubjectsstringsubjectversionsversionidversion"><code>DELETE /subjects/(string: subject)/versions/(versionId: version)</code></h4>
<p>특정 subject에 등록된 schema의 버전을 삭제한다.
이 API는 호환성 목적으로 이전에 등록한 스키마를 삭제하거나 이전에 등록한 스키마를 다시 등록해야 하는 개발 환경이나 극단적인 상황에서만 사용하는 것이 좋다.</p>
<blockquote>
<p><strong>Parameters:</strong><br>
subject (string) - subject의 이름<br>
version (versionId) - 삭제될 schema 버전을 표시한다. [1, 2^31 - 1] 또는 latest가 될 수 있다.<br>
permanent (boolean) - <code>?permanent=true</code>를 추가하여 hard delete를 표시한다.</p>
</blockquote>
<p><strong>Response JSON Object:</strong>
int - 삭제된 schema의 버전</p>
<p><strong>Status Codes:</strong>
404 Not Found - Subject not found or Version not found
422 Unprocessable Entity - Invalid version
500 Internal Server Error - Error in the backend data store</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>DELETE /subjects/test/versions/1 HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span></code></pre></div><h4 id="getsubjectsstringsubjectversionsversionidversionreferencedby"><code>GET /subjects/(string: subject)/versions/{versionId: version}/referencedby</code></h4>
<p>주어진 subject와 버전에 대한 schema의 id의 목록을 요청한다.</p>
<blockquote>
<p><strong>Parameters:</strong><br>
subject (string) - subject의 이름<br>
version (versionId) - return 되는 schema 버전을 표시한다. [1, 2^31 - 1] 또는 latest가 될 수 있다.</p>
</blockquote>
<p><strong>Request JSON Array of Objects:</strong>
id (int) - 전역적으로 unique한 스키마의 id</p>
<p><strong>Status Codes:</strong>
404 Not Found - Subject not found
500 Internal Server Error - Error in the backend data store</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /subjects/test/versions/1/referencedby HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>  1, 2, 3, <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">]</span>
</span></span></code></pre></div><h2 id="5-rest-api-interface-reference---compatibility-config">5. REST API Interface Reference - Compatibility, Config</h2>
<h3 id="compatibility">Compatibility</h3>
<p>compatibility resource는 모든 버전 또는 특정 버전에 대해 사용자가 스키마의 호환성을 검사할 수 있도록 한다.</p>
<h4 id="postcompatibilitysubjectsstringsubjectversionsversionidversion"><code>POST /compatibility/subjects/(string: subject)/versions/(versionId: version)</code></h4>
<p>input 스키마에 대해서 특정 스키마의 버전에 대한 호환성을 검사한다.</p>
<blockquote>
<p><strong>Parameters:</strong>
subject (string) - 호환성을 테스트할 subject의 이름<br>
version (versionId) - 호환성을 테스트할 대상의 schema 버전을 표시한다. [1, 2^31 - 1] 또는 latest가 될 수 있다.<br>
verbose (boolean) - <code>?verbose=true</code>를 추가하여 호환성 테스트에 실패하는 이유를 출력한다.</p>
</blockquote>
<p><strong>Request JSON Object:</strong>
schema - 스키마의 내용
schemaType - 스키마의 포맷 (default: AVRO)
references - 참조된 스키마의 이름을 지정한다. (optional)</p>
<p><strong>Response JSON Object:</strong>
is_compatible (boolean) - 호환가능 여부</p>
<hr>
<p><strong>Status Codes:</strong>
404 Not Found - Subject not found or Version not found
422 Unprocessable Entity - Invalid schema or Invalid version
500 Internal Server Error - Error in the backend data store</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>POST /compatibility/subjects/test/versions/latest HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;schema&#34;</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">       \&#34;type\&#34;: \&#34;record\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">       \&#34;name\&#34;: \&#34;test\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">       \&#34;fields\&#34;:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         [
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             \&#34;type\&#34;: \&#34;string\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             \&#34;name\&#34;: \&#34;field1\&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           },
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             \&#34;type\&#34;: \&#34;int\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             \&#34;name\&#34;: \&#34;field2\&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         ]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     }&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;is_compatible&#34;</span>: true
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h4 id="postcompatibilitysubjectsstringsubjectversions"><code>POST /compatibility/subjects/(string: subject)/versions</code></h4>
<p>호환성 전략에 따라 subject의 하나의 버전 또는 여러 버전의 호환성을 확인한다.</p>
<blockquote>
<p><strong>Parameters:</strong>
subject (string) - 호환성을 테스트할 subject의 이름
verbose (boolean) - **<code>?verbose=true</code>**를 추가하여 호환성 테스트에 실패하는 이유를 출력한다.</p>
</blockquote>
<p><strong>Request JSON Object:</strong>
schema - 스키마의 내용
schemaType - 스키마의 포맷 (default: AVRO)
references - 참조된 스키마의 이름을 지정한다. (optional)</p>
<p><strong>Response JSON Object:</strong>
is_compatible (boolean) - 호환가능 여부</p>
<hr>
<p><strong>Status Codes:</strong>
404 Not Found - Subject not found
422 Unprocessable Entity - Invalid schema
500 Internal Server Error - Error in the backend data store</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>POST /compatibility/subjects/test/versions
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;schema&#34;</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">       \&#34;type\&#34;: \&#34;record\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">       \&#34;name\&#34;: \&#34;test\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">       \&#34;fields\&#34;:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         [
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             \&#34;type\&#34;: \&#34;string\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             \&#34;name\&#34;: \&#34;field1\&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           },
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             \&#34;type\&#34;: \&#34;int\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             \&#34;name\&#34;: \&#34;field2\&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         ]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     }&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;is_compatible&#34;</span>: true
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="config">Config</h3>
<h4 id="putconfig"><code>PUT /config</code></h4>
<p>전역적 호환성 전략을 변경한다.</p>
<blockquote>
<p><strong>Request JSON Object:</strong><br>
compatibility (string) - 새롭게 변경된 호환성 전략을 표시한다.</p>
</blockquote>
<hr>
<p><strong>Status Codes:</strong>
422 Unprocessable Entity - Invalid compatibility level
500 Internal Server Error - Error in the backend data store or Error while forwarding request to the primary</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>PUT /config HTTP/1.1
</span></span><span style="display:flex;"><span>Host: kafkaproxy.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;compatibility&#34;</span>: <span style="color:#e6db74">&#34;FULL&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;compatibility&#34;</span>: <span style="color:#e6db74">&#34;FULL&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h4 id="get-config"><code>**GET /config**</code></h4>
<p>전역적 호환성 전략을 요청한다.</p>
<blockquote>
<p><strong>Response JSON Object:</strong><br>
compatibility (string) - 현재 호환성 전략을 표시한다.</p>
</blockquote>
<hr>
<p><strong>Status Codes:</strong>
500 Internal Server Error - Error in the backend data store</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /config HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;compatibilityLevel&#34;</span>: <span style="color:#e6db74">&#34;FULL&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h4 id="putconfigstring-subject"><code>PUT /config/(string: subject)</code></h4>
<p>특정 subject에 대한 호환성 전략을 변경한다.</p>
<blockquote>
<p><strong>Parameters:</strong>
subject (string) - subject의 이름</p>
</blockquote>
<p><strong>Request JSON Object:</strong>
compatibility (string) - 새롭게 변경된 호환성 전략을 표시한다.</p>
<hr>
<p><strong>Status Codes:</strong>
422 Unprocessable Entity - Invalid compatibility level
500 Internal Server Error - Error in the backend data store or Error while forwarding request to the primary</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>PUT /config/test HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;compatibility&#34;</span>: <span style="color:#e6db74">&#34;FULL&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;compatibility&#34;</span>: <span style="color:#e6db74">&#34;FULL&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h4 id="get-configstring-subject"><code>GET /config/(string: subject)</code></h4>
<p>특정 subject에 대한 호환성 전략을 요청한다.</p>
<blockquote>
<p><strong>Parameters:</strong><br>
subject (string) - subject의 이름<br>
defaultToGlobal (boolean) - **<code>?defaultToBlobal=false</code>**를 추가하여 호환성을 표시한다.<br>
**<code>?defaultToBlobal=true</code>**를 추가하면 호환성 검사에 필요한 사항을 표시한다.</p>
</blockquote>
<p><strong>Response JSON Object:</strong>
compatibility (string) - 현재 호환성 전략을 표시한다.</p>
<hr>
<p><strong>Status Codes:</strong>
404 Not Found - Subject not found
500 Internal Server Error - Error in the backend data store</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /config/test HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>   <span style="color:#e6db74">&#34;compatibilityLevel&#34;</span>: <span style="color:#e6db74">&#34;FULL&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h4 id="deleteconfigstringsubject"><code>DELETE /config/(string: subject)</code></h4>
<p>특정 subject에 대한 호환성 전략을 삭제하고, 전역적 호환성 전략을 사용한다.</p>
<blockquote>
<p><strong>Parameters:</strong><br>
subject (string) - subject의 이름</p>
</blockquote>
<hr>
<p><strong>Status Codes:</strong>
404 Not Found - Subject not found
500 Internal Server Error - Error in the backend data store</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>DELETE /config/test HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>   <span style="color:#e6db74">&#34;compatibility&#34;</span>: <span style="color:#e6db74">&#34;NONE&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h2 id="6-subject-name-strategy">6. Subject Name Strategy</h2>
<p>subject 이름을 만들어 내기 위한 subject naming strategy가 있다.</p>
<table>
<thead>
<tr>
<th>Strategy</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>TopicNameStrategy<!-- raw HTML omitted --> (default)</td>
<td>- topic 이름으로부터 subject의 이름을 만든다.<!-- raw HTML omitted -->- 항상 하나의 topic에 있는 메세지는 같은 schema를 가지는 것을 보장한다.</td>
</tr>
<tr>
<td>RecordNameStrategy</td>
<td>- record 이름으로부터 subject의 이름을 만들고, subject 아래에 서로 다른 schema를 가질 수 있는 논리적으로 관련된 그룹화를 제공한다.<!-- raw HTML omitted -->- 하나의 topic에 여러개의 schema를 가지는 것을 허용한다.<!-- raw HTML omitted -->- 이 전략은 메세지가 서로 다른 데이터 구조를 가질때 유용하게 사용할 수 있다.</td>
</tr>
<tr>
<td>TopicRecordNameStrategy</td>
<td>- topic과 record 이름으로부터 subject의 이름을 만들고, subject 아래에 서로 다른 schema를 가질 수 있는 논리적으로 관련된 그룹화를 제공한다.<!-- raw HTML omitted -->- 하나의 topic에 여러개의 schema를 가지는 것을 허용한다.<!-- raw HTML omitted -->- 이 전략은 메세지가 서로 다른 데이터 구조를 가질때 유용하게 사용할 수 있다.</td>
</tr>
</tbody>
</table>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://docs.confluent.io/platform/current/schema-registry/serdes-develop/index.html#">https://docs.confluent.io/platform/current/schema-registry/serdes-develop/index.html#</a></li>
</ul>
]]></content:encoded></item><item><title>Kafka란?</title><link>https://jo-minjun.github.io/notes/kafka/</link><pubDate>Fri, 01 Jul 2022 12:51:30 +0900</pubDate><guid>https://jo-minjun.github.io/notes/kafka/</guid><description>1. kafka 란? apache kafka는 오픈 소스 분산 이벤트 스트리밍 플랫폼이다.
*데이터 파이프 라인 구성시, 주로 사용되는 오픈 소스로 대용량 실시간 로그 처리에 특화되어 많은 사람들이 사용하고 있다.
*데이터 파이프 라인: 데이터 처리 단계의 출력이 다음 단계의 입력으로 이어지는 형태로 연결된 구조를 가리킨다.
2. kafka의 특성 2.1. Publisher-Subscriber 모델 Publisher-Subscriber 모델은 중간에 데이터 큐를 두고 서로 간 독립적으로 데이터를 생산하고 소비한다.
이러한 구조를 통해, Publisher나 Subscriber에 장애가 생겨도, 독립적이기 때문에 안정적으로 데이터를 처리할 수 있다.</description><content:encoded><![CDATA[<h2 id="1-kafka-란"><strong>1. kafka 란?</strong></h2>
<p>apache kafka는 오픈 소스 분산 이벤트 스트리밍 플랫폼이다.</p>
<p><strong>*데이터 파이프 라인</strong> 구성시, 주로 사용되는 오픈 소스로 대용량 실시간 로그 처리에 특화되어 많은 사람들이 사용하고 있다.</p>
<blockquote>
<p><strong>*데이터 파이프 라인:</strong>
데이터 처리 단계의 출력이 다음 단계의 입력으로 이어지는 형태로 연결된 구조를 가리킨다.</p>
</blockquote>
<h2 id="2-kafka의-특성">2. kafka의 특성</h2>
<h3 id="21-publisher-subscriber-모델">2.1. Publisher-Subscriber 모델</h3>
<p>Publisher-Subscriber 모델은 중간에 데이터 큐를 두고 서로 간 독립적으로 데이터를 생산하고 소비한다.</p>
<p>이러한 구조를 통해, Publisher나 Subscriber에 장애가 생겨도, 독립적이기 때문에 안정적으로 데이터를 처리할 수 있다.</p>
<h3 id="22-고가용성-및-확장성-high-availablility-and-scalability">2.2. 고가용성 및 확장성 (High availablility and Scalability)</h3>
<p>kafka는 cluster 구조로 데이터를 분산하여 저장한다.</p>
<p>따라서 하나의 broker에 장애가 생겨도 가용성이 높다.</p>
<p>또한 클러스터를 수평적으로 늘려 안정성 및 성능을 향상시키는 Scale-out이 가능하다.</p>
<h3 id="23-디스크-순차-저장-및-처리">2.3. 디스크 순차 저장 및 처리</h3>
<p>메세지를 메모리 큐에 적재하는 기존 메세지 시스템과 달리 kafka는 메세지를 디스크에 순차적으로 저장한다.</p>
<p>따라서</p>
<p>서버에 장애가 나도 메세지가 디스크에 저장되어 안정성이 높고 순차적으로 저장되어 I/O작업이 줄어들어 성능이 좋아진다.</p>
<h3 id="24-분산-처리">2.4. 분산 처리</h3>
<p>kafka는 partition을 통해 여러개의 partition을 여러개의 서버에 분산시켜 나누어 처리할 수 있다.</p>
<h2 id="3-kafka의-구조">3. kafka의 구조</h2>
<h3 id="31-publisher-subscriber-모델">3.1. Publisher-Subscriber 모델</h3>
<p>Pub-Sub (발행-구독) 모델은 특정 시스템에 직접 메세지를 전달하는 시스템이 아니다.</p>
<p>publisher은 메세지를 <strong>*Topic</strong>을 통해서 분류하여 관리하고, receiver은 전달받기를 원하는 <strong>*Topic</strong>을 구독하여 메세지를 전달 받는다.</p>
<p>즉 <strong>*kafka cluster</strong>를 중심으로 producer가 push하고, consumer가 메세지를 pull하는 구조이다.</p>
<p><img loading="lazy" src="/images/notes/kafka/pub-sub.png" alt="pub-sub"  />
</p>
<blockquote>
<p><strong>*kafka cluster:</strong>
kafka 서버 (broker)로 이루어진 클러스터를 말한다.</p>
</blockquote>
<p><strong>broker:</strong>
메세지 중계 역할을 하는 kafka서버를 말한다.</p>
<p><strong>*topic:</strong>
kafka cluster에 메세지를 관리할 때, 기준이 되는 논리적 모델이다.
여러개를 생성할 수 있으며, 하나의 topic은 1개 이상의 partition으로 구성되어 있다.</p>
<p><strong>partition:</strong>
토픽에서 메세지를 분산 처리하는 단위이다.
토픽을 partition으로 나누어 나눈 만큼 분산 처리를 한다.
kafka option에서 지정한 replica (replication factor)의 수만큼 partition이 broker들에게 복제된다.</p>
<p><strong>leader &amp; follower:</strong>
kafka 에서는 복제된 partition들 중에서 하나의 leader가 선출된다.
leader는 read, write 연산을 담당하며, follower들은 leader의 메세지를 복사한다.
leader partition이 포함된 broker에서 장애가 발생하면
follower partition들 중 하나가 leader가 된다.</p>
<p><strong>*consumer group - 상세 설명:</strong>
consumer의 집합을 구성하는 단위이다.
kafka에서는 consumer group 단위로 메세지를 처리하고, consumer group의 consumer 수만큼 파티션의 데이터를 분산처리하게 된다.</p>
<p><strong>*offset - 상세 설명:</strong>
consumer group들은 partition의 offset을 기준으로 데이터를 순차적으로 처리한다.</p>
<blockquote>
</blockquote>
<p><strong>3.1.1. consumer group</strong></p>
<p>여러개의 producer 들이 메세지를 전달하는 속도가 consumer가 메세지를 처리하는 속도보다 빠르면 하나의 consumer 만으로는 전달되는 메세지를 모두 처리할 수 없다.</p>
<p>따라서 consumer group을 통해 메세지를 처리한다.</p>
<p>consumer group은 같은 토픽의 여러개의 partition을 분담하여 처리하게 된다.</p>
<p>가령 partition의 수가 4개이고, consumer group의 consumer가 2개라면
각 consumer는 2개씩의 partition을 분담하여 메세지를 처리한다.
또한, partition의 수가 consumer group의 consumer 수보다 적다면
partition을 분담하지 못한 consumer는 idle이 된다.</p>
<p><strong>3.1.2. offset</strong></p>
<p>producer는 메세지를 순차적으로 전달하고 디스크에 순차적으로 저장한다.
따라서 저장된 메세지 뒤에 세로운 메세지를 붙이는 append 방식으로 write를 진행한다.
이 때 partition 들은 각 메세지의 순차적인 위치인 offset으로 구성된다.</p>
<p>따라서 offset은 partition 내에서 메세지의 위치를 표시하는 유니크한 숫자이다.
consumer는 자신이 어디까지 메세지를 처리했는지 offset을 이용해서 관리한다.</p>
<p><img loading="lazy" src="/images/notes/kafka/offset.png" alt="offset"  />
</p>
<h2 id="4-zookeeper-란">4. zookeeper 란?</h2>
<p>zookeeper는 분산 애플리케이션이 안정적으로 서비스될 수 있도록 각 애플리케이션의 구성 정보를 중앙 집중시키고, 네이밍, 동기화 등의 서비스를 지원한다.</p>
<p><img loading="lazy" src="/images/notes/kafka/zookeeper.png" alt="zookeeper"  />
</p>
<blockquote>
<p>zookeeper 여러개를 하나의 클러스터로 구성하고, 각각의 zookeeper 서버는 클라이언트 애플리케이션과 커넥션을 유지하며, 상태 정보를 공유한다.</p>
</blockquote>
<p>상태 정보는 zookeeper의 데이터 레지스터의 공유 계층 name space에 저장된다. 그리고 이 공간을 znode라고 부른다.</p>
<p>znode는 key-value 형태이며, 자식 노드를 가지고 있는 계층형 구조로 구성되어 있다.</p>
<p><img loading="lazy" src="/images/notes/kafka/znode.png" alt="znode"  />
</p>
<p>zookeeper는 클러스터로 구성될 시 몇개의 서버가 다운되더라도 과반수 구조에 의해 서비스가 유지된다.</p>
<p>따라서 일반적으로 클러스터는 홀수개의 서버로 구성된다.</p>
<blockquote>
<p><strong>3대 구성 클러스터:</strong>
1대 down, 2대 up: 서비스가 유지된다.
2대 down, 1대 up: 서비스가 유지되지 않는다.</p>
</blockquote>
]]></content:encoded></item></channel></rss>