<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker 스터디 | minjun's memory</title><meta name=keywords content="Docker"><meta name=description content="Docker Docker란 애플리케이션 개발, 실행, 공유를 위한 오픈 플랫폼이다. 호스트 시스템과 격리된 환경에서 애플리케이션을 패키징하고 실행할 수 있게 해준다. (컨테이너) 협업 시 각 로컬에 개발환경을 설치하지 않아도 된다. 서버 관리에 편리하다. https://docs.docker.com/get-started/overview/
도커 명령어 크게 4가지 종류의 명령어가 있다. Registry 관련 Image 관련 Container 관련 Compose 관련 명령어의 자세한 옵션과 설명은 아래 문서를 참조
docker
Registry 관련 login
docker login Registry에 로그인한다. logout
docker logout Registry에서 로그아웃한다. search
docker search [OPTIONS] <TERM> Registry에 있는 이미지를 검색한다."><meta name=author content="조민준"><link rel=canonical href=https://jo-minjun.github.io/notes/docker-study/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://jo-minjun.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jo-minjun.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jo-minjun.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jo-minjun.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jo-minjun.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZW1ZBXB1FD"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZW1ZBXB1FD",{anonymize_ip:!1})}</script><meta property="og:title" content="Docker 스터디"><meta property="og:description" content="Docker Docker란 애플리케이션 개발, 실행, 공유를 위한 오픈 플랫폼이다. 호스트 시스템과 격리된 환경에서 애플리케이션을 패키징하고 실행할 수 있게 해준다. (컨테이너) 협업 시 각 로컬에 개발환경을 설치하지 않아도 된다. 서버 관리에 편리하다. https://docs.docker.com/get-started/overview/
도커 명령어 크게 4가지 종류의 명령어가 있다. Registry 관련 Image 관련 Container 관련 Compose 관련 명령어의 자세한 옵션과 설명은 아래 문서를 참조
docker
Registry 관련 login
docker login Registry에 로그인한다. logout
docker logout Registry에서 로그아웃한다. search
docker search [OPTIONS] <TERM> Registry에 있는 이미지를 검색한다."><meta property="og:type" content="article"><meta property="og:url" content="https://jo-minjun.github.io/notes/docker-study/"><meta property="article:section" content="notes"><meta property="article:published_time" content="2023-01-04T23:51:30+09:00"><meta property="article:modified_time" content="2023-01-04T23:51:30+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker 스터디"><meta name=twitter:description content="Docker Docker란 애플리케이션 개발, 실행, 공유를 위한 오픈 플랫폼이다. 호스트 시스템과 격리된 환경에서 애플리케이션을 패키징하고 실행할 수 있게 해준다. (컨테이너) 협업 시 각 로컬에 개발환경을 설치하지 않아도 된다. 서버 관리에 편리하다. https://docs.docker.com/get-started/overview/
도커 명령어 크게 4가지 종류의 명령어가 있다. Registry 관련 Image 관련 Container 관련 Compose 관련 명령어의 자세한 옵션과 설명은 아래 문서를 참조
docker
Registry 관련 login
docker login Registry에 로그인한다. logout
docker logout Registry에서 로그아웃한다. search
docker search [OPTIONS] <TERM> Registry에 있는 이미지를 검색한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Notes","item":"https://jo-minjun.github.io/notes/"},{"@type":"ListItem","position":3,"name":"Docker 스터디","item":"https://jo-minjun.github.io/notes/docker-study/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker 스터디","name":"Docker 스터디","description":"Docker Docker란 애플리케이션 개발, 실행, 공유를 위한 오픈 플랫폼이다. 호스트 시스템과 격리된 환경에서 애플리케이션을 패키징하고 실행할 수 있게 해준다. (컨테이너) 협업 시 각 로컬에 개발환경을 설치하지 않아도 된다. 서버 관리에 편리하다. https://docs.docker.com/get-started/overview/\n도커 명령어 크게 4가지 종류의 명령어가 있다. Registry 관련 Image 관련 Container 관련 Compose 관련 명령어의 자세한 옵션과 설명은 아래 문서를 참조\ndocker\nRegistry 관련 login\ndocker login Registry에 로그인한다. logout\ndocker logout Registry에서 로그아웃한다. search\ndocker search [OPTIONS] \u0026lt;TERM\u0026gt; Registry에 있는 이미지를 검색한다.","keywords":["Docker"],"articleBody":"Docker Docker란 애플리케이션 개발, 실행, 공유를 위한 오픈 플랫폼이다. 호스트 시스템과 격리된 환경에서 애플리케이션을 패키징하고 실행할 수 있게 해준다. (컨테이너) 협업 시 각 로컬에 개발환경을 설치하지 않아도 된다. 서버 관리에 편리하다. https://docs.docker.com/get-started/overview/\n도커 명령어 크게 4가지 종류의 명령어가 있다. Registry 관련 Image 관련 Container 관련 Compose 관련 명령어의 자세한 옵션과 설명은 아래 문서를 참조\ndocker\nRegistry 관련 login\ndocker login Registry에 로그인한다. logout\ndocker logout Registry에서 로그아웃한다. search\ndocker search [OPTIONS] Registry에 있는 이미지를 검색한다. Option Default Description –filter -f key=value 포맷으로 검색을 필터링 한다. stars: star의 개수 (int) is-automated: 자동 빌드 여부 (boolean) is-official: 공식 여부 (boolean) | | –limit | 25 | 검색 결과의 최대 개수 | | –no-trunc | | 검색 결과 텍스트를 생략하지 않고 전부 보여준다. | pull\ndocker pull [OPTIONS] Registry에서 이미지를 내려 받는다. 에 사용자 명을 지정하지 않으면 공식 이미지를 내려 받는다. push\ndocker push [OPTIONS] 이미지를 Registry에 업로드 한다. Image 관련 build\ndocker image build [OPTIONS] [Dockerfile PATH | URL] Dockerfile을 이용해서 이미지를 빌드한다. ls\ndocker image ls [OPTIONS] 이미지 목록를 보여준다. rm\ndocker image rm [OPTIONS] [IMAGE...] 하나 또는 하나 이상의 이미지를 제거한다. Option Default Description –force -f 이미지를 강제로 제거한다. tag\ndocker image tag SOURCE_IMAGE TARGET_IMAGE 이미지에 태그를 설정한다. (IMAGE_ID에 별칭을 부여한다.) 숫자 및 _ - . 으로 이름을 시작할 수 없다. Container 관련 commit\ndocker container commit [OPTIONS] CONTAINER 컨테이너의 변경사항을 이미지로 생성한다. Option Default Description –author -a 커밋한 사용자를 작성한다. –message -m 커밋 메시지를 작성한다. diff\ndocker container diff CONTAINER 컨테이너의 변경사항을 확인한다. A: 추가, C: 변경, D: 삭제 exec\ndocker container exec [OPTIONS] CONTAINER COMMAND [ARG...] docker exec 명령어와 같다. 실행 중인 컨테이너에 명령어를 실행한다. Option Default Description –detach -d 명령어를 백그라운드로 실행한다. –interactive -i 표준입력을 유지한다. –tty -t 터미널(pseudo-TTY)을 할당한다. logs\ndocker container logs CONTAINER docker logs 명령어와 같다. 컨테이너의 로그를 보여준다. Option Default Description –follow -f 로그를 계속 추적하면서 출력한다. –timestamps -t 시간 데이터를 보여준다. ls\ndocker container ls [OPTIONS] 컨테이너 목록을 보여준다. Option Default Description –all -a running container 모든 컨테이너를 보여준다. –size -s 사이즈를 같이 보여준다. prune\ndocker container prune stop 상태인 모든 컨테이너를 제거한다. rename\ndocker container rename CONTAINER NEW_NAME 컨테이너 이름을 변경한다. rm\ndocker container rm [OPTIONS] CONTAINER [CONTAINER...] 하나 또는 하나 이상 컨테이너를 제거한다. Option Default Description –force -f 동작 중인 컨테이너를 강제로 제거한다. run\ndocker container run [OPTIONS] IMAGE [COMMAND] [ARG...] 이미지를 컨테이너로 생성하고 실행한다. Option Default Description —detach -d 컨테이너의 ID를 출력하고 백그라운드로 실행한다. –interactive -i 표준입력을 유지한다. –tty -t 터미널(pseudo-TTY)을 할당한다. –name random 컨테이너에 이름을 지정한다. –env -e 환경변수를 설정한다. –publish -p host(port):container(port) 포맷으로 publish와 bind를 설정한다. –volume -v 볼륨을 마운트 시킨다. –rm 종료되면 해당 컨테이너를 삭제한다. start, restart\ndocker container start [OPTIONS] CONTAINER [CONTAINER...] 하나 또는 하나 이상의 컨테이너를 시작한다. 이미 실행 중인 컨테이너를 다시 시작하려면 restart를 사용한다. stop\ndocker container stop [OPTIONS] CONTAINER [CONTAINER...] 하나 또는 하나 이상의 컨테이너를 중지시킨다. Compose 관련 up\ndocker compose up 컴포즈 파일의 컨테이너들을 생성하고 시작한다. down\ndocker compose down 컨테이너를 중단하고 제거한다. Option Default Description –rmi 서비스에 사용된 이미지를 제거한다. –volumnes -v 이름이 지정된 volume을 제거한다. Dockerfile Dockerfile을 이용해서 Docker 이미지를 빌드할 수 있다. docker image build 명령어를 사용해서 Dockerfile에 명시된 command line을 수행하도록 할 수 있다. docker image build [Dockerfile 경로] Format\nDockerfile 포맷은 다음과 같다. # Comment INSTRUCTION arguments INSTRUCTION은 대/소문자를 구분하지 않지만, 대문자로 작성하는 것이 컨벤션이다. Dockerfile은 반드시 FROM INSTRUCTION으로 시작해야 한다. Environment replacement\n환경변수는 $variable_name 또는 ${variable_name} 방식으로 사용할 수 있다. ${variable_name} 는 다음과 같은 연산자를 지원한다. ${variable_name:-word} 는 variable_name 이 정의되어있지 않다면 word 로 대체된다. ${variable_name:+word} 는 variable_name 이 정의되어 있다면 word 가 그 값으로 대체되고 정의되어있지 않다면 빈 문자열로 대체된다. FROM\nFROM [--platform=] [AS ] FROM [--platform=] [:] [AS ] FROM [--platform=] [@] [AS ] 생성할 이미지의 베이스 이미지를 설정한다. 멀티 플랫폼 이미지를 참조할 때 --platform 사용하여 플랫폼을 특정할 수 있다. linux/amd64 linux/arm64 windows/amd64 … 뒤에 TAG와 DIGEST는 선택적으로 사용한다. 둘 다 생략했다면 TAG로 latest가 사용된다. AS를 사용해서 빌드 단계에 이름을 줄 수 있다. RUN\nRUN # shell 형식 RUN [\"executable\", \"param1\", \"param2\"] # exec 형식 현재 이미지의 새 레이어에서 실행되고 결과를 커밋되고, 커밋된 이미지는 Dockerfile의 다음 스텝에서 사용된다. RUN 명령어는 두 가지 방식을 따른다. shell 형식 내부적으로 shell 명령어를 호출하여 를 호출한다. exec 형식 사용자가 executable(/bin/sh, /bin/bash…) 을 명시하여 명령어를 실행할 수 있다. CMD\nCMD param1 param2 # shell 형식 CMD [\"executable\", \"param1\", \"param2\"] # exec 형식 컨테이너가 실행될 때 수행될 default 명령어를 설정한다. 컨테이너 실행시 override가 가능하다. CMD는 두 가지 방식을 따른다. shell 형식 내부적으로 shell 명령어를 호출하여 를 호출한다. exec 형식 사용자가 executable(/bin/sh, /bin/bash…) 을 명시하여 명령어를 실행할 수 있다. ENTIRYPOINT\nENTRYPOINT command param1 param2 # shell 형식 ENTRYPOINT [\"executable\", \"param1\", \"param2\"] #exec 형식 컨테이너가 실행될 때 가장 먼저 수행되는 명령어를 지정한다. ENTIRYPOINT 명령어는 두 가지 방식을 따른다. shell 형식 내부적으로 shell 명령어를 호출하여 를 호출한다. exec 형식 사용자가 executable(/bin/sh, /bin/bash…) 을 명시하여 명령어를 실행할 수 있다. LABEL\nLABEL = = = ... # 한 줄에 작성 LABEL = \\ # 여러 줄에 작성 = \\ = \\ ... 키=밸류 방식으로 이미지에 메타데이터를 추가한다. LABEL은 기본 또는 상위 이미지의 LABEL을 현재 이미지에 상속 받는다. 이미지의 라벨은 docker image inspect 명령어로 확인할 수 있다. EXPOSE\nEXPOSE [/...] Docker에게 컨테이너가 런타임에서 어떤 네트워크 포트를 사용할 지 알려준다. TCP, UDP를 사용할 수 있고, 명시하지 않는다면 TCP가 사용된다. 실제로 포트를 공개하지는 않지만 docker run -P 명령어를 사용하면 호스트의 랜덤 포트가 컨테이너의 EXPOSE로 명시한 포트에 매핑된다. ENV\nENV ENV = ... 환경변수 를 로 설정한다. 컨테이너 실행 시 docker container run —env 명령어로 변경할 수 있다. ADD\nADD [--chown=;] ... ADD [--chown=;] [\"\",... \"\"] 의 파일, 디렉토리, 리모트 파일의 URL을 에 추가한다. *과 ? 과 같은 패턴을 사용할 수도 있다. # hom으로 시작하는 모든 파일 추가 ADD home* /dir/ # ?는 단일 문자 대체 ADD hom?.txt /dir/ COPY\nCOPY [--chown=:] ... COPY [--chown=:] [\"\",... \"\"] 이미지에 호스트의 파일이나 디렉토리를 복사한다. ADD는 대상이 압축파일인 경우 해체하여 복사하는 등 기능을 제공하지만, COPY는 복사만 수행한다. WORKDIR\nWORKDIR /path/to/workdir Dockerfile에서 정의한 명령을 실행하기 위한 디렉토리를 지정하며, 경로가 존재하지 않으면 생성한다. ARG\nARG [=] Dockerfile에서 사용할 변수를 정의한다. ENV와 달리 Dockerfile 내부에서만 사용 가능하다. HEALTHCHECK\nHEALTHCHECK [OPTIONS] CMD command # 사용할 명령을 지정 (curl 등) HEALTHCHECK NONE #기본 이미지에서 상속된 healthcheck 사용 안함 컨테이너가 잘 동작하는지 확인한다. 옵션은 다음과 같다. Option Default Description –interval=n 30s 헬스 체크 간격 –timeout=n 30s 헬스 체크 타임아웃 기준 –retries=n 3 타임아웃 횟수 –start_period=n 0s 컨테이너 실행 후 대기 시간 Compose file Compose specification\nCompose file versions Reference file What changed in this version https://docs.docker.com/compose/compose-file/ (most current, and recommended) https://docs.docker.com/compose/compose-file/compose-versioning/#versioning https://docs.docker.com/compose/compose-file/compose-file-v3/ https://docs.docker.com/compose/compose-file/compose-versioning/#version-3 https://docs.docker.com/compose/compose-file/compose-file-v2/ https://docs.docker.com/compose/compose-file/compose-versioning/#version-2 Version 1 (Deprecated) https://docs.docker.com/compose/compose-file/compose-versioning/#version-1-deprecated Compose specification Compose specification은 도커가 다중 컨테이너 애플리케이션을 정의하기 위해 만든 새로운 표준 규격이다. **YAML(YML)**을 이용해서 다음과 같은 항목을 정의한다. service(필수), network, volume, config, secret Compose file의 이름은 compose.yaml 또는 docker-compose.yaml을 사용한다. 만약 둘 다 존재하는 경우 Compose spec의 컨벤션인 compose.yaml을 권장한다. Compose 애플리케이션 모델 Compose file은 플랫폼에 의존하지 않는 컨테이너 집합 기반 애플리케이션을 정의한다. 서비스(service) 애플리케이션 컴포넌트를 구성한다. 컨테이너를 실행해서 플랫폼에 구현되는 추상 개념이다. 어떤 서비스는 런타임 또는 플랫폼에 의존적인 **설정(config)**을 필요로 한다. 네트워크(network) 서비스간 통신을 구성한다. 서로 연결된 서비스 컨테이너 간에 IP 라우팅을 위한 플랫폼 기능 추상체이다. 볼륨(volume) 서비스는 볼륨에 데이터를 저장하고 공유한다. config와 secret을 이용해서 컨테이너에 필요한 정책과 보안을 설정할 수 있다. Profile 프로필을 사용해서 환경에 맞게 Compose 애플리케이션 모델을 조정할 수 있다. services는 요소로 서비스 name을 제공하고 그 하위에 profiles 속성을 제공한다. profiles 속성으로 프로필 목록을 정의한다. profiles 속성이 설정되지 않은 서비스는 항상 활성화 된다. 특정 서비스를 실행하는 경우 지정한 프로필이 활성화 된다. services: # 모든 프로필에서 활성화 된다. foo: image: foo # test 프로필에서 활성화 된다. bar: image: bar profiles: - test # test 및 debug 프로필에서 활성화 된다. baz: image: baz depends_on: - bar profiles: - test - debug service의 구성 요소 service의 주요 하위 요소 build image command container_name depends_on environment expose ports healthcheck volumes 다른 구성 요소는 문서를 참고 build\n컨테이너 이미지를 생성하기 위한 빌드 구성을 지정한다. build 요소는 문자열 값을 가지거나 하위 요소를 가질 수 있다. 아래와 같이 build에 문자열 값을 가지면 Dockerfile의 context만 가질 수 있다. services: webapp: build: ./dir build 요소의 하위 요소는 다음과 같다. context: Dockerfile의 context를 지정한다. dockerfile: 사용할 Dockerfile의 이름을 지정한다. args: Dockerfile ARG 값을 정의한다. … services: webapp: build: context: ./dir dockerfile: webapp.Dockerfile args: - GIT_COMMIT=cdc3b19 image\n컨테이너를 시작할 이미지를 지정한다. [/][/][:|@] 방식으로 기술해야 한다. image: redis image: redis:5 image: library/redis image: docker.io/library/redis image: my_private.registry:5000/redis command\n컨테이너 이미지(CMD)에 선언된 기본 명령을 재정의 한다. services: webapp: command: [\"bundle\", \"exec\", \"thin\", \"-p\", \"3000\"] # exec 형식 command: bundle exec thin -p 3000 # shell 형식 container_name\ncontainer_name은 컨테이너의 이름을 지정한다. services: webapp: container_name: my-web-container **depends_on**\n서비스 간의 시작 및 종료 종속성을 기술한다. 두 가지 방법으로 기술할 수 있다. Short syntax 종속성 서비스 이름만 지정한다. services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres 위 예제는 아래와 같은 동작을 의미한다. web 보다 db 및 redis가 빨리 생성된다. web 이 db 및 redis보다 빨리 제거된다. Long syntax 이 방법을 사용하면 추가 필드를 사용할 수 있다. condition: 종속성이 충족된 것으로 간주되는 조건 service_started: (default) 의존하는 서비스가 먼저 시작됨 service_healthy: 의존하는 서비스가 먼저 시작되고, healthy 상태임 service_completed_successfully: 의존하는 서비스가 성공적으로 종료됨 services: web: build: . depends_on: db: condition: service_healthy redis: condition: service_started redis: image: redis db: image: postgres 위 예제는 아래와 같은 동작을 의미한다. web 이 실행되기 전에 db 가 healthy 상태이고 redis가 시작된 상태이다. environment\n컨테이너에 설정된 환경변수를 정의한다. 두 가지 방법으로 환경변수를 정의할 수 있다. Map syntax environment: RACK_ENV: development SHOW: \"true\" USER_INPUT: Array syntax environment: - RACK_ENV=development - SHOW=true - USER_INPUT expose\n컨테이너에서 노출해야 하는 포트를 정의한다. 호스트 내부의 다른 컨테이너들만 엑세스가 가능하다. expose: - \"3000\" - \"8000\" ports\n컨테이너 포트를 노출한다. [HOST:]CONTAINER[/PROTOCOL] ports: - \"3000\" # 호스트의 랜덤 포트, 컨테이너의 3000번 포트 - \"3000-3005\" # 컨테이너의 포트 번호 범위내에서 할당 - \"8000:8000\" - \"9090-9091:8080-8081\" - \"49100:22\" - \"127.0.0.1:8001:8001\" - \"127.0.0.1:5000-5010:5000-5010\" - \"6060:6060/udp\" expose vs ports - ports는 호스트와 컨테이너의 포트를 바인딩 시킨다. - ports는 호스트 포트와 컨테이너 포트를 모두 노출시키기 때문에 호스트 내부 컨테이너 간에는 노출된 포트로 접근할 수 있지만, 호스트 외부에서는 컨테이너와 바인딩된 포트로 접근해야 한다. - expose는 호스트 포트를 공개하지 않고 컨테이너의 포트만 공개한다. - 따라서 호스트 외부에서는 컨테이너에 접근할 수 없고 컨테이너 끼리만 접근이 가능하다. healthcheck\n서비스 컨테이너가 healthy 상태인지 확인한다. healthcheck의 하위 구성 요소는 아래와 같다. Element Description disable true 또는 false로 healthcheck 여부를 설정 test 컨테이너 상태를 확인하기 위한 명령 정의. exec 방식과 shell 방식 모두 사용 가능 interval 헬스 체크 간격 timeout 헬스 체크 타임아웃 기준 retries 타임아웃 횟수 start_period 컨테이너 시작 후 대기 시간 healthcheck: test: [\"CMD\", \"curl\", \"-f\", \"http://localhost\"] interval: 1m30s timeout: 10s retries: 3 start_period: 40s volumes\n서비스 컨테이너에서 엑세스하는 마운트 호스트 경로 또는 정의한 볼륨을 기술한다. 마운트가 단일 서비스에서만 사용되는 경우 최상위 volumes 요소 대신 services 하위 요소로 선언할 수 있다. 여러 서비스가 볼륨을 재사용하려면 최상위 volumes 요소에서 정의된 볼륨을 기술해야 한다. HOST_VOLUME:CONTAINER_PATH:[ACCESS_MODE] HOST_VOLUME: 호스트 경로 또는 최상위 volumes 요소에서 정의한 볼륨 이름 CONTAINER_PATH: 컨테이너의 경로 ACCESS_MODE: 목록은 ,으로 구분된다. rw : 읽기 및 쓰기(기본값) ro : 읽기 전용 services: backend: image: awesome/database volumes: - db-data:/etc/data backup: image: backup-service volumes: - db-data:/var/lib/backup/data volumes: db-data: driver_opts: device: /host/path/to/volume services: backend: image: awesome/database volumes: - /dir1:/etc/data backup: image: backup-service volumes: - /dir2:/var/lib/backup/data:ro ","wordCount":"1824","inLanguage":"en","datePublished":"2023-01-04T23:51:30+09:00","dateModified":"2023-01-04T23:51:30+09:00","author":[{"@type":"Person","name":"조민준"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://jo-minjun.github.io/notes/docker-study/"},"publisher":{"@type":"Organization","name":"minjun's memory","logo":{"@type":"ImageObject","url":"https://jo-minjun.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jo-minjun.github.io accesskey=h title="minjun's memory (Alt + H)">minjun's memory</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jo-minjun.github.io/search title=" (Alt + /)" accesskey=/><span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="23" y1="23" x2="16.65" y2="16.65"/></svg></span></a></li><li><a href=https://jo-minjun.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://jo-minjun.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jo-minjun.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jo-minjun.github.io/notes/ title=Notes><span>Notes</span></a></li><li><a href=https://jo-minjun.github.io/doodles/ title=끄적끄적><span>끄적끄적</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jo-minjun.github.io>Home</a>&nbsp;»&nbsp;<a href=https://jo-minjun.github.io/notes/>Notes</a></div><h1 class=post-title>Docker 스터디</h1><div class=post-meta><span title='2023-01-04 23:51:30 +0900 +0900'>January 4, 2023</span>&nbsp;·&nbsp;조민준&nbsp;|&nbsp;<a href=https://github.com/jo-minjun/my-blog/issues/new rel="noopener noreferrer" target=_blank>변경 요청 &lt;-- 내용이 잘못되었다면?</a></div></header><br><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>목차 보기</span></summary><div class=inner><ul><li><a href=#docker aria-label=Docker>Docker</a><ul><ul><li><a href=#docker%eb%9e%80 aria-label=Docker란>Docker란</a></li></ul><li><a href=#%eb%8f%84%ec%bb%a4-%eb%aa%85%eb%a0%b9%ec%96%b4 aria-label="도커 명령어">도커 명령어</a><ul><li><a href=#registry-%ea%b4%80%eb%a0%a8 aria-label="Registry 관련">Registry 관련</a></li><li><a href=#image-%ea%b4%80%eb%a0%a8 aria-label="Image 관련">Image 관련</a></li><li><a href=#container-%ea%b4%80%eb%a0%a8 aria-label="Container 관련">Container 관련</a></li><li><a href=#compose-%ea%b4%80%eb%a0%a8 aria-label="Compose 관련">Compose 관련</a></li></ul></li><li><a href=#dockerfile aria-label=Dockerfile>Dockerfile</a></li><li><a href=#compose-file aria-label="Compose file">Compose file</a><ul><li><a href=#compose-file-versions aria-label="Compose file versions">Compose file versions</a></li><li><a href=#compose-specification aria-label="Compose specification">Compose specification</a></li><li><a href=#compose-%ec%95%a0%ed%94%8c%eb%a6%ac%ec%bc%80%ec%9d%b4%ec%85%98-%eb%aa%a8%eb%8d%b8 aria-label="Compose 애플리케이션 모델">Compose 애플리케이션 모델</a></li><li><a href=#profile aria-label=Profile>Profile</a></li><li><a href=#service%ec%9d%98-%ea%b5%ac%ec%84%b1-%ec%9a%94%ec%86%8c aria-label="service의 구성 요소">service의 구성 요소</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=docker>Docker<a hidden class=anchor aria-hidden=true href=#docker>#</a></h1><h3 id=docker란>Docker란<a hidden class=anchor aria-hidden=true href=#docker란>#</a></h3><ul><li>애플리케이션 개발, 실행, 공유를 위한 오픈 플랫폼이다.</li><li>호스트 시스템과 격리된 환경에서 애플리케이션을 패키징하고 실행할 수 있게 해준다. (컨테이너)<ul><li>협업 시 각 로컬에 개발환경을 설치하지 않아도 된다.</li><li>서버 관리에 편리하다.</li></ul></li></ul><p><img loading=lazy src=/images/notes/docker-study/1.svg alt=1></p><p><a href=https://docs.docker.com/get-started/overview/>https://docs.docker.com/get-started/overview/</a></p><h2 id=도커-명령어>도커 명령어<a hidden class=anchor aria-hidden=true href=#도커-명령어>#</a></h2><ul><li>크게 4가지 종류의 명령어가 있다.<ul><li>Registry 관련</li><li>Image 관련</li><li>Container 관련</li><li>Compose 관련</li></ul></li></ul><p>명령어의 자세한 옵션과 설명은 아래 문서를 참조</p><p><a href=https://docs.docker.com/engine/reference/commandline/docker/>docker</a></p><h3 id=registry-관련>Registry 관련<a hidden class=anchor aria-hidden=true href=#registry-관련>#</a></h3><p><strong>login</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker login
</span></span></code></pre></div><ul><li>Registry에 로그인한다.</li></ul><p><strong>logout</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker logout
</span></span></code></pre></div><ul><li>Registry에서 로그아웃한다.</li></ul><p><strong>search</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker search <span style=color:#f92672>[</span>OPTIONS<span style=color:#f92672>]</span> &lt;TERM&gt;
</span></span></code></pre></div><ul><li>Registry에 있는 이미지를 검색한다.</li></ul><table><thead><tr><th>Option</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>&ndash;filter -f</td><td></td><td>key=value 포맷으로 검색을 필터링 한다.</td></tr></tbody></table><ul><li>stars: star의 개수 (int)</li><li>is-automated: 자동 빌드 여부 (boolean)</li><li>is-official: 공식 여부 (boolean) |
| &ndash;limit | 25 | 검색 결과의 최대 개수 |
| &ndash;no-trunc | | 검색 결과 텍스트를 생략하지 않고 전부 보여준다. |</li></ul><p><strong>pull</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker pull <span style=color:#f92672>[</span>OPTIONS<span style=color:#f92672>]</span> &lt;IMAGE&gt;
</span></span></code></pre></div><ul><li>Registry에서 이미지를 내려 받는다.</li><li>에 사용자 명을 지정하지 않으면 공식 이미지를 내려 받는다.</li></ul><p><strong>push</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker push <span style=color:#f92672>[</span>OPTIONS<span style=color:#f92672>]</span> &lt;IMAGE&gt;
</span></span></code></pre></div><ul><li>이미지를 Registry에 업로드 한다.</li></ul><h3 id=image-관련>Image 관련<a hidden class=anchor aria-hidden=true href=#image-관련>#</a></h3><p><strong>build</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker image build <span style=color:#f92672>[</span>OPTIONS<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>Dockerfile PATH | URL<span style=color:#f92672>]</span>
</span></span></code></pre></div><ul><li>Dockerfile을 이용해서 이미지를 빌드한다.</li></ul><p><strong>ls</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker image ls <span style=color:#f92672>[</span>OPTIONS<span style=color:#f92672>]</span>
</span></span></code></pre></div><ul><li>이미지 목록를 보여준다.</li></ul><p><strong>rm</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker image rm <span style=color:#f92672>[</span>OPTIONS<span style=color:#f92672>]</span> &lt;IMAGE&gt; <span style=color:#f92672>[</span>IMAGE...<span style=color:#f92672>]</span>
</span></span></code></pre></div><ul><li>하나 또는 하나 이상의 이미지를 제거한다.</li></ul><table><thead><tr><th>Option</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>&ndash;force -f</td><td></td><td>이미지를 강제로 제거한다.</td></tr></tbody></table><p><strong>tag</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker image tag SOURCE_IMAGE TARGET_IMAGE
</span></span></code></pre></div><ul><li>이미지에 태그를 설정한다. (IMAGE_ID에 별칭을 부여한다.)</li><li>숫자 및 <code>_</code> <code>-</code> <code>.</code> 으로 이름을 시작할 수 없다.</li></ul><h3 id=container-관련>Container 관련<a hidden class=anchor aria-hidden=true href=#container-관련>#</a></h3><p><strong>commit</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker container commit <span style=color:#f92672>[</span>OPTIONS<span style=color:#f92672>]</span> CONTAINER
</span></span></code></pre></div><ul><li>컨테이너의 변경사항을 이미지로 생성한다.</li></ul><table><thead><tr><th>Option</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>&ndash;author -a</td><td></td><td>커밋한 사용자를 작성한다.</td></tr><tr><td>&ndash;message -m</td><td></td><td>커밋 메시지를 작성한다.</td></tr></tbody></table><p><strong>diff</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker container diff CONTAINER
</span></span></code></pre></div><ul><li>컨테이너의 변경사항을 확인한다.</li><li>A: 추가, C: 변경, D: 삭제</li></ul><p><strong>exec</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker container exec <span style=color:#f92672>[</span>OPTIONS<span style=color:#f92672>]</span> CONTAINER COMMAND <span style=color:#f92672>[</span>ARG...<span style=color:#f92672>]</span>
</span></span></code></pre></div><ul><li><code>docker exec</code> 명령어와 같다.</li><li>실행 중인 컨테이너에 명령어를 실행한다.</li></ul><table><thead><tr><th>Option</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>&ndash;detach -d</td><td></td><td>명령어를 백그라운드로 실행한다.</td></tr><tr><td>&ndash;interactive -i</td><td></td><td>표준입력을 유지한다.</td></tr><tr><td>&ndash;tty -t</td><td></td><td>터미널(pseudo-TTY)을 할당한다.</td></tr></tbody></table><p><strong>logs</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker container logs CONTAINER
</span></span></code></pre></div><ul><li><code>docker logs</code> 명령어와 같다.</li><li>컨테이너의 로그를 보여준다.</li></ul><table><thead><tr><th>Option</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>&ndash;follow -f</td><td></td><td>로그를 계속 추적하면서 출력한다.</td></tr><tr><td>&ndash;timestamps -t</td><td></td><td>시간 데이터를 보여준다.</td></tr></tbody></table><p><strong>ls</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker container ls <span style=color:#f92672>[</span>OPTIONS<span style=color:#f92672>]</span>
</span></span></code></pre></div><ul><li>컨테이너 목록을 보여준다.</li></ul><table><thead><tr><th>Option</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>&ndash;all -a</td><td>running container</td><td>모든 컨테이너를 보여준다.</td></tr><tr><td>&ndash;size -s</td><td></td><td>사이즈를 같이 보여준다.</td></tr></tbody></table><p><strong>prune</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker container prune
</span></span></code></pre></div><ul><li>stop 상태인 모든 컨테이너를 제거한다.</li></ul><p><strong>rename</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker container rename CONTAINER NEW_NAME
</span></span></code></pre></div><ul><li>컨테이너 이름을 변경한다.</li></ul><p><strong>rm</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker container rm <span style=color:#f92672>[</span>OPTIONS<span style=color:#f92672>]</span> CONTAINER <span style=color:#f92672>[</span>CONTAINER...<span style=color:#f92672>]</span>
</span></span></code></pre></div><ul><li>하나 또는 하나 이상 컨테이너를 제거한다.</li></ul><table><thead><tr><th>Option</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>&ndash;force -f</td><td></td><td>동작 중인 컨테이너를 강제로 제거한다.</td></tr></tbody></table><p><strong>run</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker container run <span style=color:#f92672>[</span>OPTIONS<span style=color:#f92672>]</span> IMAGE <span style=color:#f92672>[</span>COMMAND<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>ARG...<span style=color:#f92672>]</span>
</span></span></code></pre></div><ul><li>이미지를 컨테이너로 생성하고 실행한다.</li></ul><table><thead><tr><th>Option</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>—detach -d</td><td></td><td>컨테이너의 ID를 출력하고 백그라운드로 실행한다.</td></tr><tr><td>&ndash;interactive -i</td><td></td><td>표준입력을 유지한다.</td></tr><tr><td>&ndash;tty -t</td><td></td><td>터미널(pseudo-TTY)을 할당한다.</td></tr><tr><td>&ndash;name</td><td>random</td><td>컨테이너에 이름을 지정한다.</td></tr><tr><td>&ndash;env -e</td><td></td><td>환경변수를 설정한다.</td></tr><tr><td>&ndash;publish -p</td><td></td><td>host(port):container(port) 포맷으로 publish와 bind를 설정한다.</td></tr><tr><td>&ndash;volume -v</td><td></td><td>볼륨을 마운트 시킨다.</td></tr><tr><td>&ndash;rm</td><td></td><td>종료되면 해당 컨테이너를 삭제한다.</td></tr></tbody></table><p><strong>start, restart</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker container start <span style=color:#f92672>[</span>OPTIONS<span style=color:#f92672>]</span> CONTAINER <span style=color:#f92672>[</span>CONTAINER...<span style=color:#f92672>]</span>
</span></span></code></pre></div><ul><li>하나 또는 하나 이상의 컨테이너를 시작한다.</li><li>이미 실행 중인 컨테이너를 다시 시작하려면 <code>restart</code>를 사용한다.</li></ul><p><strong>stop</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker container stop <span style=color:#f92672>[</span>OPTIONS<span style=color:#f92672>]</span> CONTAINER <span style=color:#f92672>[</span>CONTAINER...<span style=color:#f92672>]</span>
</span></span></code></pre></div><ul><li>하나 또는 하나 이상의 컨테이너를 중지시킨다.</li></ul><h3 id=compose-관련>Compose 관련<a hidden class=anchor aria-hidden=true href=#compose-관련>#</a></h3><p><strong>up</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker compose up
</span></span></code></pre></div><ul><li>컴포즈 파일의 컨테이너들을 생성하고 시작한다.</li></ul><p><strong>down</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker compose down
</span></span></code></pre></div><ul><li>컨테이너를 중단하고 제거한다.</li></ul><table><thead><tr><th>Option</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>&ndash;rmi</td><td></td><td>서비스에 사용된 이미지를 제거한다.</td></tr><tr><td>&ndash;volumnes -v</td><td></td><td>이름이 지정된 volume을 제거한다.</td></tr></tbody></table><h2 id=dockerfile>Dockerfile<a hidden class=anchor aria-hidden=true href=#dockerfile>#</a></h2><ul><li>Dockerfile을 이용해서 Docker 이미지를 빌드할 수 있다.</li><li><code>docker image build</code> 명령어를 사용해서 Dockerfile에 명시된 command line을 수행하도록 할 수 있다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker image build <span style=color:#f92672>[</span>Dockerfile 경로<span style=color:#f92672>]</span>
</span></span></code></pre></div><p><strong>Format</strong></p><ul><li>Dockerfile 포맷은 다음과 같다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span><span style=color:#75715e># Comment</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>INSTRUCTION arguments<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ul><li>INSTRUCTION은 대/소문자를 구분하지 않지만, 대문자로 작성하는 것이 컨벤션이다.</li><li>Dockerfile은 반드시 <code>FROM</code> INSTRUCTION으로 시작해야 한다.</li></ul><p><strong>Environment replacement</strong></p><ul><li>환경변수는 <code>$variable_name</code> 또는 <code>${variable_name}</code> 방식으로 사용할 수 있다.</li><li><code>${variable_name}</code> 는 다음과 같은 연산자를 지원한다.<ul><li><code>${variable_name:-word}</code> 는 <code>variable_name</code> 이 정의되어있지 않다면 <code>word</code> 로 대체된다.</li><li><code>${variable_name:+word}</code> 는 <code>variable_name</code> 이 정의되어 있다면 <code>word</code> 가 그 값으로 대체되고 정의되어있지 않다면 빈 문자열로 대체된다.</li></ul></li></ul><p><strong>FROM</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> [--platform=&lt;platform&gt;] &lt;IMAGE&gt; [AS &lt;name&gt;]</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> [--platform=&lt;platform&gt;] &lt;IMAGE&gt;[:&lt;TAG&gt;] [AS &lt;name&gt;]</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> [--platform=&lt;platform&gt;] &lt;IMAGE&gt;[@&lt;DIGEST&gt;] [AS &lt;name&gt;]</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ul><li>생성할 이미지의 베이스 이미지를 설정한다.</li><li>멀티 플랫폼 이미지를 참조할 때 <code>--platform</code> 사용하여 플랫폼을 특정할 수 있다.<ul><li>linux/amd64</li><li>linux/arm64</li><li>windows/amd64</li><li>…</li></ul></li><li>뒤에 <code>TAG</code>와 <code>DIGEST</code>는 선택적으로 사용한다. 둘 다 생략했다면 <code>TAG</code>로 latest가 사용된다.</li><li>AS를 사용해서 빌드 단계에 이름을 줄 수 있다.</li></ul><p><strong>RUN</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span><span style=color:#66d9ef>RUN</span> &lt;command&gt; <span style=color:#75715e># shell 형식</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;executable&#34;</span>, <span style=color:#e6db74>&#34;param1&#34;</span>, <span style=color:#e6db74>&#34;param2&#34;</span><span style=color:#f92672>]</span> <span style=color:#75715e># exec 형식</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ul><li>현재 이미지의 새 레이어에서 실행되고 결과를 커밋되고, 커밋된 이미지는 Dockerfile의 다음 스텝에서 사용된다.</li><li>RUN 명령어는 두 가지 방식을 따른다.<ul><li>shell 형식<ul><li>내부적으로 shell 명령어를 호출하여 를 호출한다.</li></ul></li><li>exec 형식<ul><li>사용자가 executable(<code>/bin/sh</code>, <code>/bin/bash</code>…) 을 명시하여 명령어를 실행할 수 있다.</li></ul></li></ul></li></ul><p><strong>CMD</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span><span style=color:#66d9ef>CMD</span> &lt;command&gt; param1 param2 <span style=color:#75715e># shell 형식</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;executable&#34;</span>, <span style=color:#e6db74>&#34;param1&#34;</span>, <span style=color:#e6db74>&#34;param2&#34;</span>] <span style=color:#75715e># exec 형식</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ul><li>컨테이너가 실행될 때 수행될 default 명령어를 설정한다.</li><li>컨테이너 실행시 override가 가능하다.</li><li>CMD는 두 가지 방식을 따른다.<ul><li>shell 형식<ul><li>내부적으로 shell 명령어를 호출하여 를 호출한다.</li></ul></li><li>exec 형식<ul><li>사용자가 executable(<code>/bin/sh</code>, <code>/bin/bash</code>…) 을 명시하여 명령어를 실행할 수 있다.</li></ul></li></ul></li></ul><p><strong>ENTIRYPOINT</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span><span style=color:#66d9ef>ENTRYPOINT</span> command param1 param2 <span style=color:#75715e># shell 형식</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENTRYPOINT</span> [<span style=color:#e6db74>&#34;executable&#34;</span>, <span style=color:#e6db74>&#34;param1&#34;</span>, <span style=color:#e6db74>&#34;param2&#34;</span>] <span style=color:#75715e>#exec 형식</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ul><li>컨테이너가 실행될 때 가장 먼저 수행되는 명령어를 지정한다.</li><li>ENTIRYPOINT 명령어는 두 가지 방식을 따른다.<ul><li>shell 형식<ul><li>내부적으로 shell 명령어를 호출하여 를 호출한다.</li></ul></li><li>exec 형식<ul><li>사용자가 executable(<code>/bin/sh</code>, <code>/bin/bash</code>…) 을 명시하여 명령어를 실행할 수 있다.</li></ul></li></ul></li></ul><p><strong>LABEL</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span><span style=color:#66d9ef>LABEL</span> &lt;key&gt;<span style=color:#f92672>=</span>&lt;value&gt; &lt;key&gt;<span style=color:#f92672>=</span>&lt;value&gt; &lt;key&gt;<span style=color:#f92672>=</span>&lt;value&gt; ... <span style=color:#75715e># 한 줄에 작성</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>LABEL</span> &lt;key&gt;<span style=color:#f92672>=</span>&lt;value&gt; <span style=color:#ae81ff>\ </span><span style=color:#75715e># 여러 줄에 작성</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>			&lt;key&gt;<span style=color:#f92672>=</span>&lt;value&gt; <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>			&lt;key&gt;<span style=color:#f92672>=</span>&lt;value&gt; <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>			...<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ul><li>키=밸류 방식으로 이미지에 메타데이터를 추가한다.</li><li>LABEL은 기본 또는 상위 이미지의 LABEL을 현재 이미지에 상속 받는다.</li><li>이미지의 라벨은 <code>docker image inspect</code> 명령어로 확인할 수 있다.</li></ul><p><strong>EXPOSE</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span><span style=color:#66d9ef>EXPOSE</span><span style=color:#e6db74> &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ul><li>Docker에게 컨테이너가 런타임에서 어떤 네트워크 포트를 사용할 지 알려준다.</li><li>TCP, UDP를 사용할 수 있고, 명시하지 않는다면 TCP가 사용된다.</li><li>실제로 포트를 공개하지는 않지만 <code>docker run -P</code> 명령어를 사용하면 호스트의 랜덤 포트가 컨테이너의 EXPOSE로 명시한 포트에 매핑된다.</li></ul><p><strong>ENV</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span><span style=color:#66d9ef>ENV</span> &lt;key&gt; &lt;value&gt;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENV</span> &lt;key&gt;<span style=color:#f92672>=</span>&lt;value&gt; ...<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ul><li>환경변수 를 로 설정한다.</li><li>컨테이너 실행 시 <code>docker container run —env</code> 명령어로 변경할 수 있다.</li></ul><p><strong>ADD</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span><span style=color:#66d9ef>ADD</span> <span style=color:#f92672>[</span>--chown<span style=color:#f92672>=</span>&lt;user&gt;;&lt;group&gt;<span style=color:#f92672>]</span> &lt;src&gt;... &lt;dest&gt;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ADD</span> <span style=color:#f92672>[</span>--chown<span style=color:#f92672>=</span>&lt;user&gt;;&lt;group&gt;<span style=color:#f92672>]</span> <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;&lt;src&gt;&#34;</span>,... <span style=color:#e6db74>&#34;&lt;dest&gt;&#34;</span><span style=color:#f92672>]</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ul><li>의 파일, 디렉토리, 리모트 파일의 URL을 에 추가한다.</li><li><code>*</code>과 <code>?</code> 과 같은 패턴을 사용할 수도 있다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span><span style=color:#75715e># hom으로 시작하는 모든 파일 추가</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ADD</span> home* /dir/<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># ?는 단일 문자 대체</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ADD</span> hom?.txt /dir/<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p><strong>COPY</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span><span style=color:#66d9ef>COPY</span> <span style=color:#f92672>[</span>--chown<span style=color:#f92672>=</span>&lt;user&gt;:&lt;group&gt;<span style=color:#f92672>]</span> &lt;src&gt;... &lt;dest&gt;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> <span style=color:#f92672>[</span>--chown<span style=color:#f92672>=</span>&lt;user&gt;:&lt;group&gt;<span style=color:#f92672>]</span> <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;&lt;src&gt;&#34;</span>,... <span style=color:#e6db74>&#34;&lt;dest&gt;&#34;</span><span style=color:#f92672>]</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ul><li>이미지에 호스트의 파일이나 디렉토리를 복사한다.</li><li><code>ADD</code>는 대상이 압축파일인 경우 해체하여 복사하는 등 기능을 제공하지만, COPY는 복사만 수행한다.</li></ul><p><strong>WORKDIR</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /path/to/workdir</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ul><li>Dockerfile에서 정의한 명령을 실행하기 위한 디렉토리를 지정하며, 경로가 존재하지 않으면 생성한다.</li></ul><p><strong>ARG</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span><span style=color:#66d9ef>ARG</span> &lt;name&gt;<span style=color:#f92672>[=</span>&lt;default value&gt;<span style=color:#f92672>]</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ul><li>Dockerfile에서 사용할 변수를 정의한다.</li><li><code>ENV</code>와 달리 Dockerfile 내부에서만 사용 가능하다.</li></ul><p><strong>HEALTHCHECK</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>HEALTHCHECK</span> <span style=color:#f92672>[</span>OPTIONS<span style=color:#f92672>]</span> CMD command <span style=color:#75715e># 사용할 명령을 지정 (curl 등)</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>HEALTHCHECK</span> NONE <span style=color:#75715e>#기본 이미지에서 상속된 healthcheck 사용 안함</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><ul><li>컨테이너가 잘 동작하는지 확인한다.</li><li>옵션은 다음과 같다.</li></ul><table><thead><tr><th>Option</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>&ndash;interval=n</td><td>30s</td><td>헬스 체크 간격</td></tr><tr><td>&ndash;timeout=n</td><td>30s</td><td>헬스 체크 타임아웃 기준</td></tr><tr><td>&ndash;retries=n</td><td>3</td><td>타임아웃 횟수</td></tr><tr><td>&ndash;start_period=n</td><td>0s</td><td>컨테이너 실행 후 대기 시간</td></tr></tbody></table><h2 id=compose-file>Compose file<a hidden class=anchor aria-hidden=true href=#compose-file>#</a></h2><p><a href=https://docs.docker.com/compose/compose-file/>Compose specification</a></p><h3 id=compose-file-versions>Compose file versions<a hidden class=anchor aria-hidden=true href=#compose-file-versions>#</a></h3><table><thead><tr><th>Reference file</th><th>What changed in this version</th></tr></thead><tbody><tr><td><a href=https://docs.docker.com/compose/compose-file/>https://docs.docker.com/compose/compose-file/</a> (most current, and recommended)</td><td><a href=https://docs.docker.com/compose/compose-file/compose-versioning/#versioning>https://docs.docker.com/compose/compose-file/compose-versioning/#versioning</a></td></tr><tr><td><a href=https://docs.docker.com/compose/compose-file/compose-file-v3/>https://docs.docker.com/compose/compose-file/compose-file-v3/</a></td><td><a href=https://docs.docker.com/compose/compose-file/compose-versioning/#version-3>https://docs.docker.com/compose/compose-file/compose-versioning/#version-3</a></td></tr><tr><td><a href=https://docs.docker.com/compose/compose-file/compose-file-v2/>https://docs.docker.com/compose/compose-file/compose-file-v2/</a></td><td><a href=https://docs.docker.com/compose/compose-file/compose-versioning/#version-2>https://docs.docker.com/compose/compose-file/compose-versioning/#version-2</a></td></tr><tr><td>Version 1 (Deprecated)</td><td><a href=https://docs.docker.com/compose/compose-file/compose-versioning/#version-1-deprecated>https://docs.docker.com/compose/compose-file/compose-versioning/#version-1-deprecated</a></td></tr></tbody></table><h3 id=compose-specification>Compose specification<a hidden class=anchor aria-hidden=true href=#compose-specification>#</a></h3><ul><li>Compose specification은 도커가 다중 컨테이너 애플리케이션을 정의하기 위해 만든 <strong>새로운 표준 규격</strong>이다.</li><li>**YAML(YML)**을 이용해서 다음과 같은 항목을 정의한다.<ul><li>service(필수), network, volume, config, secret</li></ul></li><li>Compose file의 이름은 compose.yaml 또는 docker-compose.yaml을 사용한다.</li><li>만약 둘 다 존재하는 경우 Compose spec의 컨벤션인 <strong>compose.yaml을 권장</strong>한다.</li></ul><h3 id=compose-애플리케이션-모델>Compose 애플리케이션 모델<a hidden class=anchor aria-hidden=true href=#compose-애플리케이션-모델>#</a></h3><ul><li>Compose file은 플랫폼에 의존하지 않는 컨테이너 집합 기반 애플리케이션을 정의한다.</li><li><strong>서비스(service)</strong><ul><li>애플리케이션 컴포넌트를 구성한다.</li><li>컨테이너를 실행해서 플랫폼에 구현되는 추상 개념이다.</li><li>어떤 서비스는 런타임 또는 플랫폼에 의존적인 **설정(config)**을 필요로 한다.</li></ul></li><li><strong>네트워크(network)</strong><ul><li>서비스간 통신을 구성한다.</li><li>서로 연결된 서비스 컨테이너 간에 IP 라우팅을 위한 플랫폼 기능 추상체이다.</li></ul></li><li><strong>볼륨(volume)</strong><ul><li>서비스는 볼륨에 데이터를 저장하고 공유한다.</li></ul></li><li>config와 secret을 이용해서 컨테이너에 필요한 정책과 보안을 설정할 수 있다.</li></ul><h3 id=profile>Profile<a hidden class=anchor aria-hidden=true href=#profile>#</a></h3><ul><li>프로필을 사용해서 환경에 맞게 Compose 애플리케이션 모델을 조정할 수 있다.</li><li><code>services</code>는 요소로 서비스 <code>name</code>을 제공하고 그 하위에 <code>profiles</code> 속성을 제공한다.<ul><li>profiles 속성으로 프로필 목록을 정의한다.</li><li>profiles 속성이 설정되지 않은 서비스는 항상 활성화 된다.</li><li>특정 서비스를 실행하는 경우 지정한 프로필이 활성화 된다.</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>	<span style=color:#75715e># 모든 프로필에서 활성화 된다.</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>foo</span>:
</span></span><span style=display:flex><span>		<span style=color:#f92672>image</span>: <span style=color:#ae81ff>foo</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e># test 프로필에서 활성화 된다.</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>bar</span>:
</span></span><span style=display:flex><span>		<span style=color:#f92672>image</span>: <span style=color:#ae81ff>bar</span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>profiles</span>:
</span></span><span style=display:flex><span>			- <span style=color:#ae81ff>test</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e># test 및 debug 프로필에서 활성화 된다.</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>baz</span>:
</span></span><span style=display:flex><span>		<span style=color:#f92672>image</span>: <span style=color:#ae81ff>baz</span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>depends_on</span>:
</span></span><span style=display:flex><span>			- <span style=color:#ae81ff>bar</span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>profiles</span>:
</span></span><span style=display:flex><span>			- <span style=color:#ae81ff>test</span>
</span></span><span style=display:flex><span>			- <span style=color:#ae81ff>debug</span>
</span></span></code></pre></div><h3 id=service의-구성-요소>service의 구성 요소<a hidden class=anchor aria-hidden=true href=#service의-구성-요소>#</a></h3><ul><li>service의 주요 하위 요소<ul><li><code>build</code> <code>image</code> <code>command</code> <code>container_name</code> <code>depends_on</code> <code>environment</code> <code>expose</code> <code>ports</code> <code>healthcheck</code> <code>volumes</code></li></ul></li><li>다른 구성 요소는 문서를 참고</li></ul><p><strong>build</strong></p><ul><li>컨테이너 이미지를 생성하기 위한 빌드 구성을 지정한다.</li><li><code>build</code> 요소는 문자열 값을 가지거나 하위 요소를 가질 수 있다.</li><li>아래와 같이 build에 문자열 값을 가지면 Dockerfile의 context만 가질 수 있다.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>	<span style=color:#f92672>webapp</span>:
</span></span><span style=display:flex><span>		<span style=color:#f92672>build</span>: <span style=color:#ae81ff>./dir</span>
</span></span></code></pre></div></li><li><code>build</code> 요소의 하위 요소는 다음과 같다.<ul><li>context: Dockerfile의 context를 지정한다.</li><li>dockerfile: 사용할 Dockerfile의 이름을 지정한다.</li><li>args: Dockerfile ARG 값을 정의한다.</li><li>…</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>	<span style=color:#f92672>webapp</span>:
</span></span><span style=display:flex><span>		<span style=color:#f92672>build</span>:
</span></span><span style=display:flex><span>			<span style=color:#f92672>context</span>: <span style=color:#ae81ff>./dir</span>
</span></span><span style=display:flex><span>			<span style=color:#f92672>dockerfile</span>: <span style=color:#ae81ff>webapp.Dockerfile</span>
</span></span><span style=display:flex><span>			<span style=color:#f92672>args</span>:
</span></span><span style=display:flex><span>				- <span style=color:#ae81ff>GIT_COMMIT=cdc3b19</span>
</span></span></code></pre></div></li></ul><p><strong>image</strong></p><ul><li>컨테이너를 시작할 이미지를 지정한다.</li><li><code>[&lt;registry>/][&lt;project>/]&lt;image>[:&lt;tag>|@&lt;digest>]</code> 방식으로 기술해야 한다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>image</span>: <span style=color:#ae81ff>redis</span>
</span></span><span style=display:flex><span><span style=color:#f92672>image</span>: <span style=color:#ae81ff>redis:5</span>
</span></span><span style=display:flex><span><span style=color:#f92672>image</span>: <span style=color:#ae81ff>library/redis</span>
</span></span><span style=display:flex><span><span style=color:#f92672>image</span>: <span style=color:#ae81ff>docker.io/library/redis</span>
</span></span><span style=display:flex><span><span style=color:#f92672>image</span>: <span style=color:#ae81ff>my_private.registry:5000/redis</span>
</span></span></code></pre></div><p><strong>command</strong></p><ul><li>컨테이너 이미지(CMD)에 선언된 기본 명령을 재정의 한다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>	<span style=color:#f92672>webapp</span>:
</span></span><span style=display:flex><span>		<span style=color:#f92672>command</span>: [<span style=color:#e6db74>&#34;bundle&#34;</span>, <span style=color:#e6db74>&#34;exec&#34;</span>, <span style=color:#e6db74>&#34;thin&#34;</span>, <span style=color:#e6db74>&#34;-p&#34;</span>, <span style=color:#e6db74>&#34;3000&#34;</span>] <span style=color:#75715e># exec 형식</span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>command</span>: <span style=color:#ae81ff>bundle exec thin -p 3000 </span> <span style=color:#75715e># shell 형식</span>
</span></span></code></pre></div><p><strong>container_name</strong></p><ul><li>container_name은 컨테이너의 이름을 지정한다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>	<span style=color:#f92672>webapp</span>:
</span></span><span style=display:flex><span>		<span style=color:#f92672>container_name</span>: <span style=color:#ae81ff>my-web-container</span>
</span></span></code></pre></div><p>*<strong>*depends_on**</strong></p><ul><li>서비스 간의 시작 및 종료 종속성을 기술한다.</li><li>두 가지 방법으로 기술할 수 있다.</li><li>Short syntax<ul><li>종속성 서비스 이름만 지정한다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>web</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>build</span>: <span style=color:#ae81ff>.</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>depends_on</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>db</span>
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>redis</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>redis</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>redis</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>db</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>postgres</span>
</span></span></code></pre></div><ul><li>위 예제는 아래와 같은 동작을 의미한다.<ul><li><code>web</code> 보다 <code>db</code> 및 <code>redis</code>가 빨리 생성된다.</li><li><code>web</code> 이 <code>db</code> 및 <code>redis</code>보다 빨리 제거된다.</li></ul></li></ul></li><li>Long syntax<ul><li>이 방법을 사용하면 추가 필드를 사용할 수 있다.</li><li><code>condition</code>: 종속성이 충족된 것으로 간주되는 조건<ul><li><code>service_started</code>: (default) 의존하는 서비스가 먼저 시작됨</li><li><code>service_healthy</code>: 의존하는 서비스가 먼저 시작되고, healthy 상태임</li><li><code>service_completed_successfully</code>: 의존하는 서비스가 성공적으로 종료됨</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>web</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>build</span>: <span style=color:#ae81ff>.</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>depends_on</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>db</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>condition</span>: <span style=color:#ae81ff>service_healthy</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>redis</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>condition</span>: <span style=color:#ae81ff>service_started</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>redis</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>redis</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>db</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>postgres</span>
</span></span></code></pre></div><ul><li>위 예제는 아래와 같은 동작을 의미한다.<ul><li><code>web</code> 이 실행되기 전에 <code>db</code> 가 healthy 상태이고 <code>redis</code>가 시작된 상태이다.</li></ul></li></ul></li></ul><p><strong>environment</strong></p><ul><li>컨테이너에 설정된 환경변수를 정의한다.</li><li>두 가지 방법으로 환경변수를 정의할 수 있다.</li><li>Map syntax<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>environment</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>RACK_ENV</span>: <span style=color:#ae81ff>development</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>SHOW</span>: <span style=color:#e6db74>&#34;true&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>USER_INPUT</span>:
</span></span></code></pre></div></li><li>Array syntax<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>environment</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>RACK_ENV=development</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>SHOW=true</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>USER_INPUT</span>
</span></span></code></pre></div></li></ul><p><strong>expose</strong></p><ul><li>컨테이너에서 노출해야 하는 포트를 정의한다.</li><li>호스트 내부의 다른 컨테이너들만 엑세스가 가능하다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>expose</span>:
</span></span><span style=display:flex><span>  - <span style=color:#e6db74>&#34;3000&#34;</span>
</span></span><span style=display:flex><span>  - <span style=color:#e6db74>&#34;8000&#34;</span>
</span></span></code></pre></div><p><strong>ports</strong></p><ul><li>컨테이너 포트를 노출한다.</li><li><code>[HOST:]CONTAINER[/PROTOCOL]</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>  - <span style=color:#e6db74>&#34;3000&#34;</span> <span style=color:#75715e># 호스트의 랜덤 포트, 컨테이너의 3000번 포트</span>
</span></span><span style=display:flex><span>  - <span style=color:#e6db74>&#34;3000-3005&#34;</span> <span style=color:#75715e># 컨테이너의 포트 번호 범위내에서 할당</span>
</span></span><span style=display:flex><span>  - <span style=color:#e6db74>&#34;8000:8000&#34;</span>
</span></span><span style=display:flex><span>  - <span style=color:#e6db74>&#34;9090-9091:8080-8081&#34;</span>
</span></span><span style=display:flex><span>  - <span style=color:#e6db74>&#34;49100:22&#34;</span>
</span></span><span style=display:flex><span>  - <span style=color:#e6db74>&#34;127.0.0.1:8001:8001&#34;</span>
</span></span><span style=display:flex><span>  - <span style=color:#e6db74>&#34;127.0.0.1:5000-5010:5000-5010&#34;</span>
</span></span><span style=display:flex><span>  - <span style=color:#e6db74>&#34;6060:6060/udp&#34;</span>
</span></span></code></pre></div><pre tabindex=0><code>expose vs ports
- ports는 호스트와 컨테이너의 포트를 바인딩 시킨다.
- ports는 호스트 포트와 컨테이너 포트를 모두 노출시키기 때문에
	호스트 내부 컨테이너 간에는 노출된 포트로 접근할 수 있지만,
	호스트 외부에서는 컨테이너와 바인딩된 포트로 접근해야 한다.

- expose는 호스트 포트를 공개하지 않고 컨테이너의 포트만 공개한다.
- 따라서 호스트 외부에서는 컨테이너에 접근할 수 없고 컨테이너 끼리만 접근이 가능하다.
</code></pre><p><strong>healthcheck</strong></p><ul><li>서비스 컨테이너가 healthy 상태인지 확인한다.</li><li>healthcheck의 하위 구성 요소는 아래와 같다.</li></ul><table><thead><tr><th>Element</th><th>Description</th></tr></thead><tbody><tr><td>disable</td><td>true 또는 false로 healthcheck 여부를 설정</td></tr><tr><td>test</td><td>컨테이너 상태를 확인하기 위한 명령 정의. exec 방식과 shell 방식 모두 사용 가능</td></tr><tr><td>interval</td><td>헬스 체크 간격</td></tr><tr><td>timeout</td><td>헬스 체크 타임아웃 기준</td></tr><tr><td>retries</td><td>타임아웃 횟수</td></tr><tr><td>start_period</td><td>컨테이너 시작 후 대기 시간</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>healthcheck</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>test</span>: [<span style=color:#e6db74>&#34;CMD&#34;</span>, <span style=color:#e6db74>&#34;curl&#34;</span>, <span style=color:#e6db74>&#34;-f&#34;</span>, <span style=color:#e6db74>&#34;http://localhost&#34;</span>]
</span></span><span style=display:flex><span>  <span style=color:#f92672>interval</span>: <span style=color:#ae81ff>1m30s</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>timeout</span>: <span style=color:#ae81ff>10s</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>retries</span>: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>start_period</span>: <span style=color:#ae81ff>40s</span>
</span></span></code></pre></div><p><strong>volumes</strong></p><ul><li>서비스 컨테이너에서 엑세스하는 마운트 호스트 경로 또는 정의한 볼륨을 기술한다.</li><li>마운트가 단일 서비스에서만 사용되는 경우 최상위 volumes 요소 대신 services 하위 요소로 선언할 수 있다.</li><li>여러 서비스가 볼륨을 재사용하려면 최상위 volumes 요소에서 정의된 볼륨을 기술해야 한다.</li><li><code>HOST_VOLUME:CONTAINER_PATH:[ACCESS_MODE]</code><ul><li><code>HOST_VOLUME</code>: 호스트 경로 또는 최상위 volumes 요소에서 정의한 볼륨 이름</li><li><code>CONTAINER_PATH</code>: 컨테이너의 경로</li><li><code>ACCESS_MODE</code>: 목록은 <code>,</code>으로 구분된다.<ul><li><code>rw</code> : 읽기 및 쓰기(기본값)</li><li><code>ro</code> : 읽기 전용</li><li></li></ul></li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>backend</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>awesome/database</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>db-data:/etc/data</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>backup</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>backup-service</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>db-data:/var/lib/backup/data</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>db-data</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>driver_opts</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>device</span>: <span style=color:#ae81ff>/host/path/to/volume</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>backend</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>awesome/database</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>/dir1:/etc/data</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>backup</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>backup-service</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>/dir2:/var/lib/backup/data:ro</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://jo-minjun.github.io/tags/docker/>Docker</a></li></ul><nav class=paginav><a class=prev href=https://jo-minjun.github.io/notes/linux-package-manager/><span class=title>« Prev</span><br><span>Linux 배포판 별 패키지 매니저</span></a>
<a class=next href=https://jo-minjun.github.io/notes/ddd-study/><span class=title>Next »</span><br><span>DDD 핵심 정리</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Docker 스터디 on twitter" href="https://twitter.com/intent/tweet/?text=Docker%20%ec%8a%a4%ed%84%b0%eb%94%94&amp;url=https%3a%2f%2fjo-minjun.github.io%2fnotes%2fdocker-study%2f&amp;hashtags=Docker"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker 스터디 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fjo-minjun.github.io%2fnotes%2fdocker-study%2f&amp;title=Docker%20%ec%8a%a4%ed%84%b0%eb%94%94&amp;summary=Docker%20%ec%8a%a4%ed%84%b0%eb%94%94&amp;source=https%3a%2f%2fjo-minjun.github.io%2fnotes%2fdocker-study%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker 스터디 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fjo-minjun.github.io%2fnotes%2fdocker-study%2f&title=Docker%20%ec%8a%a4%ed%84%b0%eb%94%94"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker 스터디 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjo-minjun.github.io%2fnotes%2fdocker-study%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker 스터디 on whatsapp" href="https://api.whatsapp.com/send?text=Docker%20%ec%8a%a4%ed%84%b0%eb%94%94%20-%20https%3a%2f%2fjo-minjun.github.io%2fnotes%2fdocker-study%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker 스터디 on telegram" href="https://telegram.me/share/url?text=Docker%20%ec%8a%a4%ed%84%b0%eb%94%94&amp;url=https%3a%2f%2fjo-minjun.github.io%2fnotes%2fdocker-study%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><div><script src=https://utteranc.es/client.js repo=jo-minjun/my-blog issue-term=pathname label=comment theme=photon-dark crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://jo-minjun.github.io>minjun's memory</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script>const images=Array.from(document.querySelectorAll(".post-content img"));images.forEach(e=>{mediumZoom(e,{margin:0,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.8)"})})</script><script type=module src=https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.esm.js></script>
<script nomodule src=https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.js></script>
<script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>