<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>객체 지향 설계와 스프링 | minjun's memory</title><meta name=keywords content="Spring,OOP"><meta name=description content="1. 스프링이란? 스프링의 생태계 필수: 스프링 프레임워크, 스프링 부트
선택: 스프링 데이터, 스프링 세션, 스프링 시큐리티, 스프링 Rest Docs, 스프링 배치, 스프링 클라우드
가장 중요한 것: 스프링 프레임워크 핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트, 기타 웹 기술: 스프링 MVC, 스프링 webFlux 데이터 접근 기술: 트랜잭션, JDBC, ORM 지원, XML 지원 기술 통합: 캐시, 이메일, 원격접근, 스케줄링 테스트: 스프링 기반 테스트 지원 언어: 코틀린, 그루비 *최근에는 스프링 부트를 통해서 스프링 프레임워크의 기술들을 편리하게 사용한다."><meta name=author content="조민준"><link rel=canonical href=https://jo-minjun.github.io/notes/spring-core-basic/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://jo-minjun.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jo-minjun.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jo-minjun.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jo-minjun.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jo-minjun.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZW1ZBXB1FD"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZW1ZBXB1FD",{anonymize_ip:!1})}</script><meta property="og:title" content="객체 지향 설계와 스프링"><meta property="og:description" content="1. 스프링이란? 스프링의 생태계 필수: 스프링 프레임워크, 스프링 부트
선택: 스프링 데이터, 스프링 세션, 스프링 시큐리티, 스프링 Rest Docs, 스프링 배치, 스프링 클라우드
가장 중요한 것: 스프링 프레임워크 핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트, 기타 웹 기술: 스프링 MVC, 스프링 webFlux 데이터 접근 기술: 트랜잭션, JDBC, ORM 지원, XML 지원 기술 통합: 캐시, 이메일, 원격접근, 스케줄링 테스트: 스프링 기반 테스트 지원 언어: 코틀린, 그루비 *최근에는 스프링 부트를 통해서 스프링 프레임워크의 기술들을 편리하게 사용한다."><meta property="og:type" content="article"><meta property="og:url" content="https://jo-minjun.github.io/notes/spring-core-basic/"><meta property="og:image" content="https://jo-minjun.github.io/47"><meta property="article:section" content="notes"><meta property="article:published_time" content="2022-07-01T19:42:48+09:00"><meta property="article:modified_time" content="2022-07-01T19:42:48+09:00"><meta property="og:site_name" content="민준의 블로그"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jo-minjun.github.io/47"><meta name=twitter:title content="객체 지향 설계와 스프링"><meta name=twitter:description content="1. 스프링이란? 스프링의 생태계 필수: 스프링 프레임워크, 스프링 부트
선택: 스프링 데이터, 스프링 세션, 스프링 시큐리티, 스프링 Rest Docs, 스프링 배치, 스프링 클라우드
가장 중요한 것: 스프링 프레임워크 핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트, 기타 웹 기술: 스프링 MVC, 스프링 webFlux 데이터 접근 기술: 트랜잭션, JDBC, ORM 지원, XML 지원 기술 통합: 캐시, 이메일, 원격접근, 스케줄링 테스트: 스프링 기반 테스트 지원 언어: 코틀린, 그루비 *최근에는 스프링 부트를 통해서 스프링 프레임워크의 기술들을 편리하게 사용한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Notes","item":"https://jo-minjun.github.io/notes/"},{"@type":"ListItem","position":3,"name":"객체 지향 설계와 스프링","item":"https://jo-minjun.github.io/notes/spring-core-basic/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"객체 지향 설계와 스프링","name":"객체 지향 설계와 스프링","description":"1. 스프링이란? 스프링의 생태계 필수: 스프링 프레임워크, 스프링 부트\n선택: 스프링 데이터, 스프링 세션, 스프링 시큐리티, 스프링 Rest Docs, 스프링 배치, 스프링 클라우드\n가장 중요한 것: 스프링 프레임워크 핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트, 기타 웹 기술: 스프링 MVC, 스프링 webFlux 데이터 접근 기술: 트랜잭션, JDBC, ORM 지원, XML 지원 기술 통합: 캐시, 이메일, 원격접근, 스케줄링 테스트: 스프링 기반 테스트 지원 언어: 코틀린, 그루비 *최근에는 스프링 부트를 통해서 스프링 프레임워크의 기술들을 편리하게 사용한다.","keywords":["Spring","OOP"],"articleBody":"1. 스프링이란? 스프링의 생태계 필수: 스프링 프레임워크, 스프링 부트\n선택: 스프링 데이터, 스프링 세션, 스프링 시큐리티, 스프링 Rest Docs, 스프링 배치, 스프링 클라우드\n가장 중요한 것: 스프링 프레임워크 핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트, 기타 웹 기술: 스프링 MVC, 스프링 webFlux 데이터 접근 기술: 트랜잭션, JDBC, ORM 지원, XML 지원 기술 통합: 캐시, 이메일, 원격접근, 스케줄링 테스트: 스프링 기반 테스트 지원 언어: 코틀린, 그루비 *최근에는 스프링 부트를 통해서 스프링 프레임워크의 기술들을 편리하게 사용한다.\n*스프링 부트:\n스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성 Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨 손쉬운 빌드 구성을 위한 starter 종속성 제공 스프링과 3rd party(외부) 라이브러리 자동 구성 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공 관례에 의한 간결한 설정 스프링 부트는 스프링 프레임워크를 기반으로 나머지 외부 라이브러리를 자동으로 구성해주는 기술이지, 자체적으로 사용할 수 있는 것이 아님 스프링의 의미 스프링이라는 단어는 문맥에 따라 다르게 사용된다. 스프링 DI 컨테이너 기술 스프링 프레임워크 스프링 부트, 스프링 프레임워크 등을 모두 포함한 스프링 생태계 스프링의 핵심 개념 자바 언어 기반의 프레임워크 자바 언어의 가장 큰 특징 - 객체 지향 언어 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크 객체 지향 프로그래밍은 스프링의 근원 2. 좋은 객체 지향 프로그래밍이란? 객체 지향 프로그래밍이란? 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러개의 독립된 단위, 즉 “객체“들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 메세지를 주고받고 데이터를 처리한다. (협력) 객체 지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다. 유연하고 변경이 용이?\n레고 블럭 조립하듯이 키보드, 마우스 갈아 끼우듯이 컴퓨터 부품 갈아 끼우듯이 컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법 객체 지향의 특징 추상화 캡슐화 상속 다형성 → 유연하고 변경이 용이하도록 하는데에 크게 기여함 다형성의 실세계 비유 실세계와 객체 지향이 1:1로 매칭되지는 않음 그러나 실세계의 비유로 이해하기 편리함 역할과 구현으로 세상을 구분 운전자 - 자동차 예시\n자동차의 역할(인터페이스)을 3개의 자동차로 구현함 운전자는 K3를 타다가 아반떼로 차를 변경할 수 있음 차가 바뀌어도 운전자는 운전을 할 수 있음 → 유연하고 변경이 용이 클라이언트에 영향을 주지 않고, 새로운 기능을 제공할 수 있음 → 유연하고 변경이 용이 이외의 예시\n공연에서 각 인물의 역할 키보드, 마우스, 세상의 표준 인터페이스들 정렬 알고리즘 할인 정책 예시\n역할과 구현을 분리 역할과 구현으로 구분하면 세상이 단순해지고 유연해지며, 변경도 편리해진다. 장점 클라이언트는 대상의 역할(인터페이스)만 알면 된다. 클라이언트는 구현 대상의 내부 구조를 몰라도 된다. 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다. 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다. 자바 언어에서의 역할과 구현 자바 언어의 다형성을 활용 역할: 인터페이스 구현: 인터페이스를 구현한 클래스, 구현 객체 객체를 설계할 때 역할과 구현을 명확히 분리 객체 설계시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기 (구현보다 역할이 중요하다.) 객체의 협력이라는 관계부터 생각 혼자있는 객체는 없다. 클라이언트: 요청 서버: 응답 수 많은 객체 클라이언트와 객체 서버는 서로 협력 관계를 가진다. 자바 언어의 다형성 오버라이딩을 떠올려보자 오버라이딩된 메서드가 실행 다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경할 수 있다. 물론 상속 관계도 다형성, 오버라이딩 적용 가능 public class MemberService { private MemberRepository memberRepository1 = new MemoryMemberRepository(); private MemberRepository memberRepository2 = new JdbcMemberRepository(); } 다형성의 본질 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다. 다형성의 본질을 이해하려면 협력이라는 객체 사이의 관계에서 시작해야함 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다. 역할과 구현을 분리 - 정리 실세계의 역할과 구현이라는 편리한 컨셉을 다형성을 통해 객체 세상으로 가져올 수 있음 유연하고, 변경이 용이 확장 가능한 설계 클라이언트에 영향을 주지 않는 변경 가능 인터페이스를 안정적으로 잘 설계하는 것이 중요 역할과 구현을 분리 - 한계 역할(인터페이스) 자체가 변하면 클라이언트, 서버 모두에 큰 변경이 발생한다. 자동차를 비행기로 변경해야 한다면? 대본 자체가 변경된다면? USB 인터페이스 자체가 변경된다면? 인터페이스를 안정적으로 잘 설계하는 것이 중요 스프링과 객체 지향 다형성이 가장 중요하다! 스프링은 다형성을 극대화해서 이용할 수 있게 도와준다. 스프링에서 이야기하는 제어의 역전(IoC), 의존관계 주입(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다. 스프링을 사용하면 마치 레고 블럭 조립하듯이, 공연 무대의 배우를 선택하듯이, 구현을 편리하게 변경할 수 있다. 그리고 또 중요한 것 - SOLID 3. 좋은 객체 지향 설계의 5가지 원칙 (SOLID) SOLID 클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리\nSRP: 단일 책임 원칙 (Single Responsibility Principle) OCP: 개방 - 폐쇄 원칙 (Open - Closed Principle) LSP: 리스코프 치환 원칙 (Liskov Substitution Principle) ISP: 인터페이스 분리 원칙 (Interface Segregation Principle) DIP: 의존관계 역전 원칙 (Dependency Inversion Principle) SRP: 단일 책임 원칙 (Single Responsibility Principle) 한 클래스는 하나의 책임만 가져야 한다. 하나의 책임이라는 것은 모호하다. 클 수 있고, 작을 수 있다. 문맥과 상황에 따라 다르다. 중요한 기준은 변경이다. 변경이 있을 때 파급효과가 적으면 단일 책임 원칙을 잘 따른 것 Ex) UI 변경, 객체의 생성과 사용을 분리 OCP: 개방 - 폐쇄 원칙 (Open - Closed Principle) 가장 중요한 원칙 소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야 한다. 다형성을 활용 인터페이스를 구현한 클래스를 하나 만들어서 새로운 기능을 구현 지금까지 배운 역할과 구현의 분리를 생각해보자 Ex) 운전자 - 자동차 자동차가 바뀌어도 운전자는 똑같이 운전함 → 확장에 열림 문제점 MemberService 클라이언트가 구현 클래스를 직접 선택 public class MemberService { // 기존 코드 // private MemberRepository memberRepository1 = new MemoryMemberRepository(); // 변경 코드 private MemberRepository memberRepository2 = new JdbcMemberRepository(); } 구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다. 다형성을 사용했지만 OCP 원칙을 지킬 수 없다. 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다. 이 역할을 스프링 컨테이너가 해결해줌 LSP: 리스코프 치환 원칙 (Liskov Substitution Principle) 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스를 바꿀 수 있어야 한다. 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것 다형성을 지원하기 위한 원칙 인터페이스를 구현한 구현체를 믿고 사용하려면 이 원칙이 필요하다. 단순히 컴파일에 성공하는 것을 넘어서는 이야기 Ex) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능 → 뒤로가게 구현하면 리스코프 치환 원칙 위반 ISP: 인터페이스 분리 원칙 (Interface Segregation Principle) 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다. 자동차 인터페이스 → 운전 인터페이스, 정비 인터페이스로 분리 사용자 클라이언트 → 운전자 클라이언트, 정비사 클라이언트로 분리 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음 인터페이스가 명확해지고, 대체 가능성이 높아진다. DIP: 의존관계 역전 원칙 (Dependency Inversion Principle) “추상화에 의존해야지, 구체화에 의존하면 안된다.” 이 원칙을 따르는 방법 중 하나다. 쉽게 이야기 해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻 앞에서 이야기한 역할에 의존하게 해야 한다는 것과 같다. 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다. 구현체에 의존하게 되면 변경이 아주 어려워진다. Ex) 운전자 - 자동차 운전자는 운전 역할에 의존해야지, 자동차 종류에 의존할 경우 차량이 바뀌면 운전이 어려워짐 그런데 개방 - 폐쇄 원칙에서 설명한 MemberService는 인터페이스에 의존하지만, 구현 클래스도 동시에 의존한다. MemberService가 구현 클래스를 직접 선택 → DIP 위반 정리 객체 지향의 핵심은 다형성 다형성만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다. 다형성만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다. 다형성만으로는 개방 - 폐쇄 원칙, 의존관계 역전 원칙을 지킬 수 없다. 4. 객체 지향 설계와 스프링 왜 스프링 이야기에 객체 지향이야기가 나오는가? 스프링은 다음 기술로 다형성 + 개방 - 폐쇄 원칙, 의존관계 역전 원칙을 가능하게 지원한다. DI (Dependency Injection): 의존관계, 의존성 주입 DI 컨테이너 제공 클라이언트 코드의 변경 없이 기능 확장 쉽게 부품을 교체하듯이 개발 총 정리 모든 설계에 역할과 구현을 분리하자 자동차, 공연의 예를 떠올려보자 애플리케이션 설계도 공연을 설계하듯이 배역만 만들어두고, 배우는 언제든지 유연하게 변경할 수 있도록 만드는 것이 좋은 객체 지향 설계이다. 이상적으로는 모든 설계에 인터페이스를 부여하자. 실무 고민 하지만 인터페이스를 도입하면 추상화라는 비용이 발생한다. 인터페이스도 만들고 구현체도 만들고 개발자가 구현된 코드가 안보여서 한 번더 열어봐야 됨 기능을 확장할 가능성이 없다면 구체 클래스를 직접 사용하고, 향후에 꼭 필요할 때 리팩토링을 해서 인터페이스를 도입하는 것도 방법이다. Reference 인프런 강의 스프링 핵심 원리(김영한) ","wordCount":"1215","inLanguage":"en","datePublished":"2022-07-01T19:42:48+09:00","dateModified":"2022-07-01T19:42:48+09:00","author":[{"@type":"Person","name":"조민준"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://jo-minjun.github.io/notes/spring-core-basic/"},"publisher":{"@type":"Organization","name":"minjun's memory","logo":{"@type":"ImageObject","url":"https://jo-minjun.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jo-minjun.github.io accesskey=h title="minjun's memory (Alt + H)">minjun's memory</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jo-minjun.github.io/search title=" (Alt + /)" accesskey=/><span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="23" y1="23" x2="16.65" y2="16.65"/></svg></span></a></li><li><a href=https://jo-minjun.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://jo-minjun.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jo-minjun.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jo-minjun.github.io/notes/ title=Notes><span>Notes</span></a></li><li><a href=https://jo-minjun.github.io/doodles/ title=끄적끄적><span>끄적끄적</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jo-minjun.github.io>Home</a>&nbsp;»&nbsp;<a href=https://jo-minjun.github.io/notes/>Notes</a></div><h1 class=post-title>객체 지향 설계와 스프링</h1><div class=post-meta><span title='2022-07-01 19:42:48 +0900 +0900'>July 1, 2022</span>&nbsp;·&nbsp;조민준&nbsp;|&nbsp;<a href=https://github.com/jo-minjun/my-blog/issues/new rel="noopener noreferrer" target=_blank>변경 요청 &lt;-- 내용이 잘못되었다면?</a></div></header><br><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>목차 보기</span></summary><div class=inner><ul><li><a href=#1-%ec%8a%a4%ed%94%84%eb%a7%81%ec%9d%b4%eb%9e%80 aria-label="1. 스프링이란?">1. 스프링이란?</a><ul><li><a href=#%ec%8a%a4%ed%94%84%eb%a7%81%ec%9d%98-%ec%83%9d%ed%83%9c%ea%b3%84 aria-label="스프링의 생태계">스프링의 생태계</a></li><li><a href=#%ea%b0%80%ec%9e%a5-%ec%a4%91%ec%9a%94%ed%95%9c-%ea%b2%83-%ec%8a%a4%ed%94%84%eb%a7%81-%ed%94%84%eb%a0%88%ec%9e%84%ec%9b%8c%ed%81%ac aria-label="가장 중요한 것: 스프링 프레임워크">가장 중요한 것: <strong>스프링 프레임워크</strong></a></li><li><a href=#%ec%8a%a4%ed%94%84%eb%a7%81%ec%9d%98-%ec%9d%98%eb%af%b8 aria-label="스프링의 의미">스프링의 의미</a></li><li><a href=#%ec%8a%a4%ed%94%84%eb%a7%81%ec%9d%98-%ed%95%b5%ec%8b%ac-%ea%b0%9c%eb%85%90 aria-label="스프링의 핵심 개념">스프링의 핵심 개념</a></li></ul></li><li><a href=#2-%ec%a2%8b%ec%9d%80-%ea%b0%9d%ec%b2%b4-%ec%a7%80%ed%96%a5-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d%ec%9d%b4%eb%9e%80 aria-label="2. 좋은 객체 지향 프로그래밍이란?">2. 좋은 객체 지향 프로그래밍이란?</a><ul><li><a href=#%ea%b0%9d%ec%b2%b4-%ec%a7%80%ed%96%a5-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d%ec%9d%b4%eb%9e%80 aria-label="객체 지향 프로그래밍이란?">객체 지향 프로그래밍이란?</a></li><li><a href=#%ea%b0%9d%ec%b2%b4-%ec%a7%80%ed%96%a5%ec%9d%98-%ed%8a%b9%ec%a7%95 aria-label="객체 지향의 특징">객체 지향의 특징</a></li><li><a href=#%eb%8b%a4%ed%98%95%ec%84%b1%ec%9d%98-%ec%8b%a4%ec%84%b8%ea%b3%84-%eb%b9%84%ec%9c%a0 aria-label="다형성의 실세계 비유">다형성의 실세계 비유</a></li><li><a href=#%ec%97%ad%ed%95%a0%ea%b3%bc-%ea%b5%ac%ed%98%84%ec%9d%84-%eb%b6%84%eb%a6%ac aria-label="역할과 구현을 분리">역할과 구현을 분리</a></li><li><a href=#%ec%9e%90%eb%b0%94-%ec%96%b8%ec%96%b4%ec%97%90%ec%84%9c%ec%9d%98-%ec%97%ad%ed%95%a0%ea%b3%bc-%ea%b5%ac%ed%98%84 aria-label="자바 언어에서의 역할과 구현"><strong>자바 언어에서의 역할과 구현</strong></a></li><li><a href=#%ea%b0%9d%ec%b2%b4%ec%9d%98-%ed%98%91%eb%a0%a5%ec%9d%b4%eb%9d%bc%eb%8a%94-%ea%b4%80%ea%b3%84%eb%b6%80%ed%84%b0-%ec%83%9d%ea%b0%81 aria-label="객체의 협력이라는 관계부터 생각">객체의 협력이라는 관계부터 생각</a></li><li><a href=#%ec%9e%90%eb%b0%94-%ec%96%b8%ec%96%b4%ec%9d%98-%eb%8b%a4%ed%98%95%ec%84%b1 aria-label="자바 언어의 다형성">자바 언어의 다형성</a></li><li><a href=#%eb%8b%a4%ed%98%95%ec%84%b1%ec%9d%98-%eb%b3%b8%ec%a7%88 aria-label="다형성의 본질">다형성의 본질</a></li><li><a href=#%ec%97%ad%ed%95%a0%ea%b3%bc-%ea%b5%ac%ed%98%84%ec%9d%84-%eb%b6%84%eb%a6%ac---%ec%a0%95%eb%a6%ac aria-label="역할과 구현을 분리 - 정리">역할과 구현을 분리 - 정리</a></li><li><a href=#%ec%97%ad%ed%95%a0%ea%b3%bc-%ea%b5%ac%ed%98%84%ec%9d%84-%eb%b6%84%eb%a6%ac---%ed%95%9c%ea%b3%84 aria-label="역할과 구현을 분리 - 한계">역할과 구현을 분리 - 한계</a></li><li><a href=#%ec%8a%a4%ed%94%84%eb%a7%81%ea%b3%bc-%ea%b0%9d%ec%b2%b4-%ec%a7%80%ed%96%a5 aria-label="스프링과 객체 지향">스프링과 객체 지향</a></li></ul></li><li><a href=#3-%ec%a2%8b%ec%9d%80-%ea%b0%9d%ec%b2%b4-%ec%a7%80%ed%96%a5-%ec%84%a4%ea%b3%84%ec%9d%98-5%ea%b0%80%ec%a7%80-%ec%9b%90%ec%b9%99-solid aria-label="3. 좋은 객체 지향 설계의 5가지 원칙 (SOLID)">3. 좋은 객체 지향 설계의 5가지 원칙 (SOLID)</a><ul><li><a href=#solid aria-label=SOLID>SOLID</a></li><li><a href=#srp-%eb%8b%a8%ec%9d%bc-%ec%b1%85%ec%9e%84-%ec%9b%90%ec%b9%99-single-responsibility-principle aria-label="SRP: 단일 책임 원칙 (Single Responsibility Principle)"><strong>SRP:</strong> 단일 책임 원칙 (Single Responsibility Principle)</a></li><li><a href=#ocp-%ea%b0%9c%eb%b0%a9---%ed%8f%90%ec%87%84-%ec%9b%90%ec%b9%99-open---closed-principle aria-label="OCP: 개방 - 폐쇄 원칙 (Open - Closed Principle)"><strong>OCP:</strong> 개방 - 폐쇄 원칙 (Open - Closed Principle)</a></li><li><a href=#lsp-%eb%a6%ac%ec%8a%a4%ec%bd%94%ed%94%84-%ec%b9%98%ed%99%98-%ec%9b%90%ec%b9%99-liskov-substitution-principle aria-label="LSP: 리스코프 치환 원칙 (Liskov Substitution Principle)"><strong>LSP:</strong> 리스코프 치환 원칙 (Liskov Substitution Principle)</a></li><li><a href=#isp-%ec%9d%b8%ed%84%b0%ed%8e%98%ec%9d%b4%ec%8a%a4-%eb%b6%84%eb%a6%ac-%ec%9b%90%ec%b9%99-interface-segregation-principle aria-label="ISP: 인터페이스 분리 원칙 (Interface Segregation Principle)"><strong>ISP:</strong> 인터페이스 분리 원칙 (Interface Segregation Principle)</a></li><li><a href=#dip-%ec%9d%98%ec%a1%b4%ea%b4%80%ea%b3%84-%ec%97%ad%ec%a0%84-%ec%9b%90%ec%b9%99-dependency-inversion-principle aria-label="DIP: 의존관계 역전 원칙 (Dependency Inversion Principle)"><strong>DIP:</strong> 의존관계 역전 원칙 (Dependency Inversion Principle)</a></li><li><a href=#%ec%a0%95%eb%a6%ac aria-label=정리>정리</a></li></ul></li><li><a href=#4-%ea%b0%9d%ec%b2%b4-%ec%a7%80%ed%96%a5-%ec%84%a4%ea%b3%84%ec%99%80-%ec%8a%a4%ed%94%84%eb%a7%81 aria-label="4. 객체 지향 설계와 스프링">4. 객체 지향 설계와 스프링</a><ul><li><a href=#%ec%99%9c-%ec%8a%a4%ed%94%84%eb%a7%81-%ec%9d%b4%ec%95%bc%ea%b8%b0%ec%97%90-%ea%b0%9d%ec%b2%b4-%ec%a7%80%ed%96%a5%ec%9d%b4%ec%95%bc%ea%b8%b0%ea%b0%80-%eb%82%98%ec%98%a4%eb%8a%94%ea%b0%80 aria-label="왜 스프링 이야기에 객체 지향이야기가 나오는가?">왜 스프링 이야기에 객체 지향이야기가 나오는가?</a></li><li><a href=#%ec%b4%9d-%ec%a0%95%eb%a6%ac aria-label="총 정리">총 정리</a></li><li><a href=#%ec%8b%a4%eb%ac%b4-%ea%b3%a0%eb%af%bc aria-label="실무 고민">실무 고민</a></li></ul></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h2 id=1-스프링이란>1. 스프링이란?<a hidden class=anchor aria-hidden=true href=#1-스프링이란>#</a></h2><h3 id=스프링의-생태계>스프링의 생태계<a hidden class=anchor aria-hidden=true href=#스프링의-생태계>#</a></h3><blockquote><p><strong>필수:</strong>
스프링 프레임워크, 스프링 부트</p></blockquote><p><strong>선택:</strong>
스프링 데이터, 스프링 세션, 스프링 시큐리티, 스프링 Rest Docs, 스프링 배치, 스프링 클라우드</p><blockquote></blockquote><h3 id=가장-중요한-것-스프링-프레임워크>가장 중요한 것: <strong>스프링 프레임워크</strong><a hidden class=anchor aria-hidden=true href=#가장-중요한-것-스프링-프레임워크>#</a></h3><ul><li><strong>핵심 기술:</strong> 스프링 DI 컨테이너, AOP, 이벤트, 기타</li><li><strong>웹 기술:</strong> 스프링 MVC, 스프링 webFlux</li><li><strong>데이터 접근 기술:</strong> 트랜잭션, JDBC, ORM 지원, XML 지원</li><li><strong>기술 통합:</strong> 캐시, 이메일, 원격접근, 스케줄링</li><li><strong>테스트:</strong> 스프링 기반 테스트 지원</li><li><strong>언어:</strong> 코틀린, 그루비</li></ul><blockquote><p>*최근에는 <strong>스프링 부트</strong>를 통해서 스프링 프레임워크의 기술들을 편리하게 사용한다.</p></blockquote><p><strong>*스프링 부트:</strong></p><ul><li>스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용</li><li>단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성</li><li>Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨</li><li>손쉬운 빌드 구성을 위한 starter 종속성 제공</li><li>스프링과 3rd party(외부) 라이브러리 자동 구성</li><li>메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공</li><li>관례에 의한 간결한 설정</li><li>스프링 부트는 스프링 프레임워크를 기반으로 나머지 외부 라이브러리를 자동으로 구성해주는 기술이지, 자체적으로 사용할 수 있는 것이 아님</li></ul><h3 id=스프링의-의미>스프링의 의미<a hidden class=anchor aria-hidden=true href=#스프링의-의미>#</a></h3><ul><li>스프링이라는 단어는 문맥에 따라 다르게 사용된다.<ol><li>스프링 DI 컨테이너 기술</li><li>스프링 프레임워크</li><li>스프링 부트, 스프링 프레임워크 등을 모두 포함한 스프링 생태계</li></ol></li></ul><h3 id=스프링의-핵심-개념>스프링의 핵심 개념<a hidden class=anchor aria-hidden=true href=#스프링의-핵심-개념>#</a></h3><ul><li>자바 언어 기반의 프레임워크</li><li>자바 언어의 가장 큰 특징 - <strong>객체 지향 언어</strong></li><li>스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크</li><li>스프링은 <strong>좋은 객체 지향</strong> 애플리케이션을 개발할 수 있게 도와주는 프레임워크</li><li><strong>객체 지향 프로그래밍</strong>은 스프링의 근원</li></ul><h2 id=2-좋은-객체-지향-프로그래밍이란>2. 좋은 객체 지향 프로그래밍이란?<a hidden class=anchor aria-hidden=true href=#2-좋은-객체-지향-프로그래밍이란>#</a></h2><h3 id=객체-지향-프로그래밍이란>객체 지향 프로그래밍이란?<a hidden class=anchor aria-hidden=true href=#객체-지향-프로그래밍이란>#</a></h3><ul><li>프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러개의 독립된 단위,
즉 “<strong>객체</strong>&ldquo;들의 <strong>모임</strong>으로 파악하고자 하는 것이다.
각각의 <strong>객체</strong>는 <strong>메세지</strong>를 주고받고 데이터를 처리한다. <strong>(협력)</strong></li><li>객체 지향 프로그래밍은 프로그램을 <strong>유연</strong>하고 <strong>변경이 용이</strong>하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다.</li></ul><blockquote><p><strong>유연하고 변경이 용이?</strong></p><ol><li>레고 블럭 조립하듯이</li><li>키보드, 마우스 갈아 끼우듯이</li><li>컴퓨터 부품 갈아 끼우듯이</li><li>컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법</li></ol></blockquote><h3 id=객체-지향의-특징>객체 지향의 특징<a hidden class=anchor aria-hidden=true href=#객체-지향의-특징>#</a></h3><ul><li>추상화</li><li>캡슐화</li><li>상속</li><li><strong>다형성</strong> → 유연하고 변경이 용이하도록 하는데에 크게 기여함</li></ul><h3 id=다형성의-실세계-비유>다형성의 실세계 비유<a hidden class=anchor aria-hidden=true href=#다형성의-실세계-비유>#</a></h3><ul><li>실세계와 객체 지향이 1:1로 매칭되지는 않음</li><li>그러나 실세계의 비유로 이해하기 편리함</li><li><strong>역할</strong>과 <strong>구현</strong>으로 세상을 구분</li></ul><p><strong>운전자 - 자동차 예시</strong></p><p><img loading=lazy src=/images/notes/spring-core-basic/0.png alt=운전자-자동차_예시.png></p><ul><li>자동차의 역할(인터페이스)을 3개의 자동차로 구현함</li><li>운전자는 K3를 타다가 아반떼로 차를 변경할 수 있음</li><li>차가 바뀌어도 운전자는 운전을 할 수 있음 → 유연하고 변경이 용이</li><li><strong>클라이언트에 영향을 주지 않고, 새로운 기능을 제공할 수 있음</strong> → 유연하고 변경이 용이</li></ul><blockquote><p><strong>이외의 예시</strong></p><p>공연에서 각 인물의 역할
키보드, 마우스, 세상의 표준 인터페이스들
정렬 알고리즘
할인 정책 예시</p></blockquote><h3 id=역할과-구현을-분리>역할과 구현을 분리<a hidden class=anchor aria-hidden=true href=#역할과-구현을-분리>#</a></h3><ul><li><strong>역할과 구현</strong>으로 구분하면 세상이 단순해지고 유연해지며, 변경도 편리해진다.</li><li>장점<ul><li>클라이언트는 대상의 <strong>역할(인터페이스)만 알면 된다.</strong></li><li>클라이언트는 구현 <strong>대상의 내부 구조를 몰라도 된다.</strong></li><li>클라이언트는 구현 <strong>대상의 내부 구조가 변경되어도 영향을 받지 않는다.</strong></li><li>클라이언트는 구현 <strong>대상 자체를 변경해도 영향을 받지 않는다.</strong></li></ul></li></ul><h3 id=자바-언어에서의-역할과-구현><strong>자바 언어에서의 역할과 구현</strong><a hidden class=anchor aria-hidden=true href=#자바-언어에서의-역할과-구현>#</a></h3><ul><li>자바 언어의 다형성을 활용<ul><li>역할: 인터페이스</li><li>구현: 인터페이스를 구현한 클래스, 구현 객체</li></ul></li><li>객체를 설계할 때 <strong>역할</strong>과 <strong>구현</strong>을 명확히 분리</li><li>객체 설계시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기
(구현보다 <strong>역할이 중요</strong>하다.)</li></ul><h3 id=객체의-협력이라는-관계부터-생각>객체의 협력이라는 관계부터 생각<a hidden class=anchor aria-hidden=true href=#객체의-협력이라는-관계부터-생각>#</a></h3><ul><li>혼자있는 객체는 없다.</li><li>클라이언트: 요청</li><li>서버: 응답</li><li>수 많은 객체 클라이언트와 객체 서버는 서로 협력 관계를 가진다.</li></ul><h3 id=자바-언어의-다형성>자바 언어의 다형성<a hidden class=anchor aria-hidden=true href=#자바-언어의-다형성>#</a></h3><p><img loading=lazy src=/images/notes/spring-core-basic/1.png alt=오버라이딩.png></p><ul><li>오버라이딩을 떠올려보자</li><li>오버라이딩된 메서드가 실행</li><li>다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경할 수 있다.</li><li>물론 상속 관계도 다형성, 오버라이딩 적용 가능</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MemberService</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> MemberRepository memberRepository1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MemoryMemberRepository<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> MemberRepository memberRepository2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> JdbcMemberRepository<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h3 id=다형성의-본질>다형성의 본질<a hidden class=anchor aria-hidden=true href=#다형성의-본질>#</a></h3><ul><li>인터페이스를 구현한 <strong>객체 인스턴스</strong>를 <strong>실행 시점에 유연하게</strong> 변경할 수 있다.</li><li>다형성의 본질을 이해하려면 <strong>협력</strong>이라는 객체 사이의 관계에서 시작해야함</li><li><strong>클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.</strong></li></ul><h3 id=역할과-구현을-분리---정리>역할과 구현을 분리 - 정리<a hidden class=anchor aria-hidden=true href=#역할과-구현을-분리---정리>#</a></h3><ul><li>실세계의 역할과 구현이라는 편리한 컨셉을 다형성을 통해 객체 세상으로 가져올 수 있음</li><li>유연하고, 변경이 용이</li><li>확장 가능한 설계</li><li>클라이언트에 영향을 주지 않는 변경 가능</li><li>인터페이스를 안정적으로 잘 설계하는 것이 중요</li></ul><h3 id=역할과-구현을-분리---한계>역할과 구현을 분리 - 한계<a hidden class=anchor aria-hidden=true href=#역할과-구현을-분리---한계>#</a></h3><ul><li>역할(인터페이스) 자체가 변하면 클라이언트, 서버 모두에 큰 변경이 발생한다.</li><li>자동차를 비행기로 변경해야 한다면?</li><li>대본 자체가 변경된다면?</li><li>USB 인터페이스 자체가 변경된다면?</li><li>인터페이스를 안정적으로 잘 설계하는 것이 중요</li></ul><h3 id=스프링과-객체-지향>스프링과 객체 지향<a hidden class=anchor aria-hidden=true href=#스프링과-객체-지향>#</a></h3><ul><li>다형성이 가장 중요하다!</li><li>스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.</li><li>스프링에서 이야기하는 제어의 역전(IoC), 의존관계 주입(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다.</li><li>스프링을 사용하면 마치 레고 블럭 조립하듯이, 공연 무대의 배우를 선택하듯이, 구현을 편리하게 변경할 수 있다.</li><li>그리고 또 중요한 것 - <strong>SOLID</strong></li></ul><h2 id=3-좋은-객체-지향-설계의-5가지-원칙-solid>3. 좋은 객체 지향 설계의 5가지 원칙 (SOLID)<a hidden class=anchor aria-hidden=true href=#3-좋은-객체-지향-설계의-5가지-원칙-solid>#</a></h2><h3 id=solid>SOLID<a hidden class=anchor aria-hidden=true href=#solid>#</a></h3><p>클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리</p><ul><li><strong>SRP:</strong> 단일 책임 원칙 (Single Responsibility Principle)</li><li><strong>OCP:</strong> 개방 - 폐쇄 원칙 (Open - Closed Principle)</li><li><strong>LSP:</strong> 리스코프 치환 원칙 (Liskov Substitution Principle)</li><li><strong>ISP:</strong> 인터페이스 분리 원칙 (Interface Segregation Principle)</li><li><strong>DIP:</strong> 의존관계 역전 원칙 (Dependency Inversion Principle)</li></ul><h3 id=srp-단일-책임-원칙-single-responsibility-principle><strong>SRP:</strong> 단일 책임 원칙 (Single Responsibility Principle)<a hidden class=anchor aria-hidden=true href=#srp-단일-책임-원칙-single-responsibility-principle>#</a></h3><ul><li>한 클래스는 하나의 책임만 가져야 한다.</li><li>하나의 책임이라는 것은 모호하다.<ul><li>클 수 있고, 작을 수 있다.</li><li>문맥과 상황에 따라 다르다.</li></ul></li><li>중요한 <strong>기준은 변경</strong>이다.<ul><li>변경이 있을 때 파급효과가 적으면 단일 책임 원칙을 잘 따른 것</li><li>Ex) UI 변경, 객체의 생성과 사용을 분리</li></ul></li></ul><h3 id=ocp-개방---폐쇄-원칙-open---closed-principle><strong>OCP:</strong> 개방 - 폐쇄 원칙 (Open - Closed Principle)<a hidden class=anchor aria-hidden=true href=#ocp-개방---폐쇄-원칙-open---closed-principle>#</a></h3><ul><li>가장 중요한 원칙</li><li>소프트웨어 요소는 <strong>확장에는 열려</strong>있으나 <strong>변경에는 닫혀</strong>있어야 한다.</li><li>다형성을 활용<ul><li>인터페이스를 구현한 클래스를 하나 만들어서 새로운 기능을 구현</li><li>지금까지 배운 역할과 구현의 분리를 생각해보자</li><li>Ex) 운전자 - 자동차<ul><li>자동차가 바뀌어도 운전자는 똑같이 운전함 → 확장에 열림</li></ul></li></ul></li><li>문제점<ul><li>MemberService 클라이언트가 구현 클래스를 직접 선택</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MemberService</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 기존 코드
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// private MemberRepository memberRepository1 = new MemoryMemberRepository();
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 변경 코드
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>private</span> MemberRepository memberRepository2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> JdbcMemberRepository<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li><strong>구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다.</strong></li><li><strong>다형성을 사용했지만 OCP 원칙을 지킬 수 없다.</strong></li><li>객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.<ul><li>이 역할을 스프링 컨테이너가 해결해줌</li></ul></li></ul></li></ul><h3 id=lsp-리스코프-치환-원칙-liskov-substitution-principle><strong>LSP:</strong> 리스코프 치환 원칙 (Liskov Substitution Principle)<a hidden class=anchor aria-hidden=true href=#lsp-리스코프-치환-원칙-liskov-substitution-principle>#</a></h3><ul><li>프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스를 바꿀 수 있어야 한다.</li><li>다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것<ul><li>다형성을 지원하기 위한 원칙</li><li>인터페이스를 구현한 구현체를 믿고 사용하려면 이 원칙이 필요하다.</li></ul></li><li>단순히 컴파일에 성공하는 것을 넘어서는 이야기</li><li>Ex) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능 → 뒤로가게 구현하면 리스코프 치환 원칙 위반</li></ul><h3 id=isp-인터페이스-분리-원칙-interface-segregation-principle><strong>ISP:</strong> 인터페이스 분리 원칙 (Interface Segregation Principle)<a hidden class=anchor aria-hidden=true href=#isp-인터페이스-분리-원칙-interface-segregation-principle>#</a></h3><ul><li>특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.</li><li>자동차 인터페이스 → 운전 인터페이스, 정비 인터페이스로 분리</li><li>사용자 클라이언트 → 운전자 클라이언트, 정비사 클라이언트로 분리</li><li>분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음</li><li>인터페이스가 명확해지고, 대체 가능성이 높아진다.</li></ul><h3 id=dip-의존관계-역전-원칙-dependency-inversion-principle><strong>DIP:</strong> 의존관계 역전 원칙 (Dependency Inversion Principle)<a hidden class=anchor aria-hidden=true href=#dip-의존관계-역전-원칙-dependency-inversion-principle>#</a></h3><ul><li>“추상화에 의존해야지, 구체화에 의존하면 안된다.”<ul><li>이 원칙을 따르는 방법 중 하나다.</li></ul></li><li>쉽게 이야기 해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻</li><li>앞에서 이야기한 <strong>역할에 의존하게 해야 한다</strong>는 것과 같다.<ul><li>객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다.</li><li>구현체에 의존하게 되면 변경이 아주 어려워진다.</li></ul></li><li>Ex) 운전자 - 자동차<ul><li>운전자는 운전 역할에 의존해야지, 자동차 종류에 의존할 경우 차량이 바뀌면 운전이 어려워짐</li></ul></li><li>그런데 개방 - 폐쇄 원칙에서 설명한 MemberService는 인터페이스에 의존하지만, 구현 클래스도 동시에 의존한다.<ul><li>MemberService가 구현 클래스를 직접 선택 → <strong>DIP 위반</strong></li></ul></li></ul><h3 id=정리>정리<a hidden class=anchor aria-hidden=true href=#정리>#</a></h3><ul><li>객체 지향의 핵심은 다형성</li><li>다형성만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다.</li><li>다형성만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.</li><li><strong>다형성만으로는 개방 - 폐쇄 원칙, 의존관계 역전 원칙을 지킬 수 없다.</strong></li></ul><h2 id=4-객체-지향-설계와-스프링>4. 객체 지향 설계와 스프링<a hidden class=anchor aria-hidden=true href=#4-객체-지향-설계와-스프링>#</a></h2><h3 id=왜-스프링-이야기에-객체-지향이야기가-나오는가>왜 스프링 이야기에 객체 지향이야기가 나오는가?<a hidden class=anchor aria-hidden=true href=#왜-스프링-이야기에-객체-지향이야기가-나오는가>#</a></h3><ul><li>스프링은 다음 기술로 다형성 + 개방 - 폐쇄 원칙, 의존관계 역전 원칙을 가능하게 지원한다.<ul><li>DI (Dependency Injection): 의존관계, 의존성 주입</li><li>DI 컨테이너 제공</li></ul></li><li>클라이언트 코드의 변경 없이 기능 확장</li><li>쉽게 부품을 교체하듯이 개발</li></ul><h3 id=총-정리>총 정리<a hidden class=anchor aria-hidden=true href=#총-정리>#</a></h3><ul><li>모든 설계에 역할과 구현을 분리하자</li><li>자동차, 공연의 예를 떠올려보자</li><li>애플리케이션 설계도 공연을 설계하듯이 배역만 만들어두고, 배우는 언제든지 <strong>유연하게 변경</strong>할 수 있도록 만드는 것이 좋은 객체 지향 설계이다.</li><li>이상적으로는 모든 설계에 인터페이스를 부여하자.</li></ul><h3 id=실무-고민>실무 고민<a hidden class=anchor aria-hidden=true href=#실무-고민>#</a></h3><ul><li>하지만 인터페이스를 도입하면 추상화라는 비용이 발생한다.<ul><li>인터페이스도 만들고 구현체도 만들고</li><li>개발자가 구현된 코드가 안보여서 한 번더 열어봐야 됨</li></ul></li><li>기능을 확장할 가능성이 없다면 구체 클래스를 직접 사용하고, 향후에 꼭 필요할 때 리팩토링을 해서 인터페이스를 도입하는 것도 방법이다.</li></ul><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><ul><li><a href=https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8>인프런 강의 스프링 핵심 원리(김영한)</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://jo-minjun.github.io/tags/spring/>Spring</a></li><li><a href=https://jo-minjun.github.io/tags/oop/>OOP</a></li></ul><nav class=paginav><a class=prev href=https://jo-minjun.github.io/notes/schema-registry/><span class=title>« Prev</span><br><span>Schema registry란?</span></a>
<a class=next href=https://jo-minjun.github.io/notes/kafka/><span class=title>Next »</span><br><span>Kafka란?</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 객체 지향 설계와 스프링 on twitter" href="https://twitter.com/intent/tweet/?text=%ea%b0%9d%ec%b2%b4%20%ec%a7%80%ed%96%a5%20%ec%84%a4%ea%b3%84%ec%99%80%20%ec%8a%a4%ed%94%84%eb%a7%81&amp;url=https%3a%2f%2fjo-minjun.github.io%2fnotes%2fspring-core-basic%2f&amp;hashtags=Spring%2cOOP"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 객체 지향 설계와 스프링 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fjo-minjun.github.io%2fnotes%2fspring-core-basic%2f&amp;title=%ea%b0%9d%ec%b2%b4%20%ec%a7%80%ed%96%a5%20%ec%84%a4%ea%b3%84%ec%99%80%20%ec%8a%a4%ed%94%84%eb%a7%81&amp;summary=%ea%b0%9d%ec%b2%b4%20%ec%a7%80%ed%96%a5%20%ec%84%a4%ea%b3%84%ec%99%80%20%ec%8a%a4%ed%94%84%eb%a7%81&amp;source=https%3a%2f%2fjo-minjun.github.io%2fnotes%2fspring-core-basic%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 객체 지향 설계와 스프링 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fjo-minjun.github.io%2fnotes%2fspring-core-basic%2f&title=%ea%b0%9d%ec%b2%b4%20%ec%a7%80%ed%96%a5%20%ec%84%a4%ea%b3%84%ec%99%80%20%ec%8a%a4%ed%94%84%eb%a7%81"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 객체 지향 설계와 스프링 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjo-minjun.github.io%2fnotes%2fspring-core-basic%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 객체 지향 설계와 스프링 on whatsapp" href="https://api.whatsapp.com/send?text=%ea%b0%9d%ec%b2%b4%20%ec%a7%80%ed%96%a5%20%ec%84%a4%ea%b3%84%ec%99%80%20%ec%8a%a4%ed%94%84%eb%a7%81%20-%20https%3a%2f%2fjo-minjun.github.io%2fnotes%2fspring-core-basic%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 객체 지향 설계와 스프링 on telegram" href="https://telegram.me/share/url?text=%ea%b0%9d%ec%b2%b4%20%ec%a7%80%ed%96%a5%20%ec%84%a4%ea%b3%84%ec%99%80%20%ec%8a%a4%ed%94%84%eb%a7%81&amp;url=https%3a%2f%2fjo-minjun.github.io%2fnotes%2fspring-core-basic%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><div><script src=https://utteranc.es/client.js repo=jo-minjun/my-blog issue-term=pathname label=comment theme=photon-dark crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://jo-minjun.github.io>minjun's memory</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script>const images=Array.from(document.querySelectorAll(".post-content img"));images.forEach(e=>{mediumZoom(e,{margin:0,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.8)"})})</script><script type=module src=https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.esm.js></script>
<script nomodule src=https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.js></script>
<script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>