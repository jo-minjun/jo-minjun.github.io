<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Introduce Kubernetes | minjun's memory</title><meta name=keywords content="Kubernetes"><meta name=description content="What, Why Kubernetes? What 쿠버네티스는 컨테이너들을 운영, 관리하는 컨테이너 오케스트레이터이다. 컨테이너 오케스트레이터는 개별 컨테이너의 배포, 관리, 확장, 네트워킹을 자동화해준다. Why 물리 서버에서 동작하는 서비스는 리소스 관리를 효율적으로 할 수 없다. 3개의 서비스에 트래픽이 몰리는 시간대가 다르다. 각 서비스는 최소 트래픽 때 0.5대, 최대 트래픽 때 3개의 서버가 사용된다. 이 경우 총 9대의 서버가 사용된다. 배포시에도 비효율적이다. 중단이 가능한 경우 모든 서비스를 내린 후, 업데이트하여 다시 올린다. 중단이 불가능하면 서비스를 하나씩 내리고 하나씩 업데이트하여 다시 올린다."><meta name=author content="조민준"><link rel=canonical href=https://jo-minjun.github.io/notes/introduce-kubernetes/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://jo-minjun.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jo-minjun.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jo-minjun.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jo-minjun.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jo-minjun.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Introduce Kubernetes"><meta property="og:description" content="What, Why Kubernetes? What 쿠버네티스는 컨테이너들을 운영, 관리하는 컨테이너 오케스트레이터이다. 컨테이너 오케스트레이터는 개별 컨테이너의 배포, 관리, 확장, 네트워킹을 자동화해준다. Why 물리 서버에서 동작하는 서비스는 리소스 관리를 효율적으로 할 수 없다. 3개의 서비스에 트래픽이 몰리는 시간대가 다르다. 각 서비스는 최소 트래픽 때 0.5대, 최대 트래픽 때 3개의 서버가 사용된다. 이 경우 총 9대의 서버가 사용된다. 배포시에도 비효율적이다. 중단이 가능한 경우 모든 서비스를 내린 후, 업데이트하여 다시 올린다. 중단이 불가능하면 서비스를 하나씩 내리고 하나씩 업데이트하여 다시 올린다."><meta property="og:type" content="article"><meta property="og:url" content="https://jo-minjun.github.io/notes/introduce-kubernetes/"><meta property="article:section" content="notes"><meta property="article:published_time" content="2023-01-10T21:51:30+09:00"><meta property="article:modified_time" content="2023-01-10T21:51:30+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Introduce Kubernetes"><meta name=twitter:description content="What, Why Kubernetes? What 쿠버네티스는 컨테이너들을 운영, 관리하는 컨테이너 오케스트레이터이다. 컨테이너 오케스트레이터는 개별 컨테이너의 배포, 관리, 확장, 네트워킹을 자동화해준다. Why 물리 서버에서 동작하는 서비스는 리소스 관리를 효율적으로 할 수 없다. 3개의 서비스에 트래픽이 몰리는 시간대가 다르다. 각 서비스는 최소 트래픽 때 0.5대, 최대 트래픽 때 3개의 서버가 사용된다. 이 경우 총 9대의 서버가 사용된다. 배포시에도 비효율적이다. 중단이 가능한 경우 모든 서비스를 내린 후, 업데이트하여 다시 올린다. 중단이 불가능하면 서비스를 하나씩 내리고 하나씩 업데이트하여 다시 올린다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Notes","item":"https://jo-minjun.github.io/notes/"},{"@type":"ListItem","position":2,"name":"Introduce Kubernetes","item":"https://jo-minjun.github.io/notes/introduce-kubernetes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Introduce Kubernetes","name":"Introduce Kubernetes","description":"What, Why Kubernetes? What 쿠버네티스는 컨테이너들을 운영, 관리하는 컨테이너 오케스트레이터이다. 컨테이너 오케스트레이터는 개별 컨테이너의 배포, 관리, 확장, 네트워킹을 자동화해준다. Why 물리 서버에서 동작하는 서비스는 리소스 관리를 효율적으로 할 수 없다. 3개의 서비스에 트래픽이 몰리는 시간대가 다르다. 각 서비스는 최소 트래픽 때 0.5대, 최대 트래픽 때 3개의 서버가 사용된다. 이 경우 총 9대의 서버가 사용된다. 배포시에도 비효율적이다. 중단이 가능한 경우 모든 서비스를 내린 후, 업데이트하여 다시 올린다. 중단이 불가능하면 서비스를 하나씩 내리고 하나씩 업데이트하여 다시 올린다.","keywords":["Kubernetes"],"articleBody":"What, Why Kubernetes? What 쿠버네티스는 컨테이너들을 운영, 관리하는 컨테이너 오케스트레이터이다. 컨테이너 오케스트레이터는 개별 컨테이너의 배포, 관리, 확장, 네트워킹을 자동화해준다. Why 물리 서버에서 동작하는 서비스는 리소스 관리를 효율적으로 할 수 없다. 3개의 서비스에 트래픽이 몰리는 시간대가 다르다. 각 서비스는 최소 트래픽 때 0.5대, 최대 트래픽 때 3개의 서버가 사용된다. 이 경우 총 9대의 서버가 사용된다. 배포시에도 비효율적이다. 중단이 가능한 경우 모든 서비스를 내린 후, 업데이트하여 다시 올린다. 중단이 불가능하면 서비스를 하나씩 내리고 하나씩 업데이트하여 다시 올린다. → 쿠버네티스를 사용하면 리소스 관리를 효율적으로 할 수 있다.\n시간대 별로 평균 서버 필요량을 예측하여 다음과 같은 운용이 가능하다. 평균 4개의 서버 A서비스에 트래픽이 몰리는 경우 3개 서버에 A서비스 할당, 1개 서버에 B, C 서비스 할당 서버에 장애가 발생한 경우에 유연하게 대처할 수 있다. 쿠버네티스에는 Auto Healing 기능이 있다. 여분의 서버 1개가 있는 경우 자동으로 여분 서버에 서비스를 옮긴다. 배포할 때는 Deployment Object를 통해서 자동화 해준다. → 서버가 효율적인 개수를 유지하고 자동화 됨으로써 유지보수 비용이 감소한다.\nOverview 서버 한대는 Master, 나머지 서버는 Node가 된다. → 이것이 연결되어 하나의 쿠버네티스 클러스터가 된다.\nMaster는 쿠버네티스의 기능을 컨트롤하고 Node는 리소스를 제공한다. 클러스터의 리소스를 늘리고 싶다면 Node를 추가하면 된다. namespace를 이용해서 쿠버네티스 오브젝트를 독립된 공간으로 분리시켜준다. namespace에는 쿠버네티스 최소 배포 단위인 Pod가 있고, Pod에 IP를 할당되도록 연결되는 Service가 있다. Service는 다른 namespace와는 연결될 수 없다. Pod에는 여러 Container가 있을 수 있다. 또한 Volume을 마운트해서 Pod의 데이터가 증발되지 않도록 한다. namespace에는 ResourceQuota와 LimitRange를 설정해서 namespace의 리소스의 양을 제한시킬 수 있다. ConfigMap과 Secret으로 Pod의 컨테이너에 환경변수를 설정할 수 있게 한다. 여러가지 컨트롤러는 Pod들을 관리한다. Replication Controller, ReplicaSet은 Pod가 죽으면 다시 구동시키거나 스케일 인/아웃을 해준다. Deployment는 배포 후에 Pod를 새 버전으로 업그레이드하고, 문제가 생기면 롤백 해준다. DaemonSet은 한 Node에 하나의 Pod만 사용되도록 해준다. CronJob은 특정 Job을 주기적으로 수행되도록 해준다. Job은 특정 작업만 하고 종료되는 것이다. Components master 노드 kube-apiserver etcd kube-scheduler kube-controller-manager worker 노드 kubelet kube-proxy kube-apiserver 쿠버네티스 클러스터의 API를 사용할 수 있게 해준다. kubectl과 같은 클라이언트로부터 요청 받아낸다. etcd key-value 형식의 데이터 저장소이다. kube-scheduler Node들의 리소스 상태와 kube-apiserver를 확인하면서, Pod에 Node 정보를 할당한다. kube-controller-manager Controller들을 실행한다. kubelet kube-apiserver를 확인하면서 Pod에 자신의 Node 정보가 할당된 것이 있으면 Pod를 생성한다. 컨테이너를 생성하고 kube-proxy에 네트워크 생성 요청을 한다. kube-proxy 네트워크 규칙을 관리하고 컨테이너가 네트워크를 사용할 수 있도록 한다. 실습 환경 구축 강의에서 소개된 환경이 아닌 minikube를 사용한다. minikube start \\ --driver='docker' \\ --kubernetes-version='stable' \\ --nodes=3 # 실습을 위해 dashboard 사용 # 실제 업무에서는 secret 등의 값 노출을 막기위해 dashboard를 잘 사용하지 않는다. minikube dashboard 위와 같은 방법으로 master 1개, worker node 2개를 구축하고 dashboard를 사용할 수 있다. ","wordCount":"403","inLanguage":"en","datePublished":"2023-01-10T21:51:30+09:00","dateModified":"2023-01-10T21:51:30+09:00","author":[{"@type":"Person","name":"조민준"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://jo-minjun.github.io/notes/introduce-kubernetes/"},"publisher":{"@type":"Organization","name":"minjun's memory","logo":{"@type":"ImageObject","url":"https://jo-minjun.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jo-minjun.github.io/ accesskey=h title="minjun's memory (Alt + H)">minjun's memory</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jo-minjun.github.io/search title=" (Alt + /)" accesskey=/><span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="23" y1="23" x2="16.65" y2="16.65"/></svg></span></a></li><li><a href=https://jo-minjun.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jo-minjun.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jo-minjun.github.io/notes/ title=Notes><span>Notes</span></a></li><li><a href=https://jo-minjun.github.io/etc/ title=끄적끄적><span>끄적끄적</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jo-minjun.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://jo-minjun.github.io/notes/>Notes</a></div><h1 class=post-title>Introduce Kubernetes</h1><div class=post-meta><span title='2023-01-10 21:51:30 +0900 +0900'>January 10, 2023</span>&nbsp;·&nbsp;조민준</div></header><br><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>목차 보기</span></summary><div class=inner><ul><li><a href=#what-why-kubernetes aria-label="What, Why Kubernetes?">What, Why Kubernetes?</a><ul><li><a href=#what aria-label=What>What</a></li><li><a href=#why aria-label=Why>Why</a></li></ul></li><li><a href=#overview aria-label=Overview>Overview</a></li><li><a href=#components aria-label=Components>Components</a><ul><li><a href=#kube-apiserver aria-label=kube-apiserver>kube-apiserver</a></li><li><a href=#etcd aria-label=etcd>etcd</a></li><li><a href=#kube-scheduler aria-label=kube-scheduler>kube-scheduler</a></li><li><a href=#kube-controller-manager aria-label=kube-controller-manager>kube-controller-manager</a></li><li><a href=#kubelet aria-label=kubelet>kubelet</a></li><li><a href=#kube-proxy aria-label=kube-proxy>kube-proxy</a></li></ul></li><li><a href=#%ec%8b%a4%ec%8a%b5-%ed%99%98%ea%b2%bd-%ea%b5%ac%ec%b6%95 aria-label="실습 환경 구축">실습 환경 구축</a></li></ul></div></details></div><div class=post-content><h2 id=what-why-kubernetes>What, Why Kubernetes?<a hidden class=anchor aria-hidden=true href=#what-why-kubernetes>#</a></h2><h3 id=what>What<a hidden class=anchor aria-hidden=true href=#what>#</a></h3><ul><li>쿠버네티스는 컨테이너들을 운영, 관리하는 <strong>컨테이너 오케스트레이터</strong>이다.</li><li>컨테이너 오케스트레이터는 개별 컨테이너의 배포, 관리, 확장, 네트워킹을 자동화해준다.</li></ul><h3 id=why>Why<a hidden class=anchor aria-hidden=true href=#why>#</a></h3><ul><li>물리 서버에서 동작하는 서비스는 리소스 관리를 효율적으로 할 수 없다.<ul><li>3개의 서비스에 트래픽이 몰리는 시간대가 다르다.</li><li>각 서비스는 최소 트래픽 때 0.5대, 최대 트래픽 때 3개의 서버가 사용된다.</li><li>이 경우 총 9대의 서버가 사용된다.</li></ul></li><li>배포시에도 비효율적이다.<ul><li>중단이 가능한 경우 모든 서비스를 내린 후, 업데이트하여 다시 올린다.</li><li>중단이 불가능하면 서비스를 하나씩 내리고 하나씩 업데이트하여 다시 올린다.</li></ul></li></ul><p>→ 쿠버네티스를 사용하면 리소스 관리를 효율적으로 할 수 있다.</p><ul><li>시간대 별로 평균 서버 필요량을 예측하여 다음과 같은 운용이 가능하다.<ul><li>평균 4개의 서버</li><li>A서비스에 트래픽이 몰리는 경우 3개 서버에 A서비스 할당, 1개 서버에 B, C 서비스 할당</li></ul></li><li>서버에 장애가 발생한 경우에 유연하게 대처할 수 있다.<ul><li>쿠버네티스에는 Auto Healing 기능이 있다.</li><li>여분의 서버 1개가 있는 경우 자동으로 여분 서버에 서비스를 옮긴다.</li></ul></li><li>배포할 때는 Deployment Object를 통해서 자동화 해준다.</li></ul><p>→ 서버가 효율적인 개수를 유지하고 자동화 됨으로써 유지보수 비용이 감소한다.</p><h2 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>#</a></h2><p><img loading=lazy src=../introduce-kubernetes/1.png alt=1></p><ul><li>서버 한대는 Master, 나머지 서버는 Node가 된다.</li></ul><p>→ 이것이 연결되어 하나의 쿠버네티스 클러스터가 된다.</p><ul><li>Master는 쿠버네티스의 기능을 컨트롤하고 Node는 리소스를 제공한다.<ul><li>클러스터의 리소스를 늘리고 싶다면 Node를 추가하면 된다.</li></ul></li><li>namespace를 이용해서 쿠버네티스 오브젝트를 독립된 공간으로 분리시켜준다.</li><li>namespace에는 쿠버네티스 최소 배포 단위인 Pod가 있고, Pod에 IP를 할당되도록 연결되는 Service가 있다.<ul><li>Service는 다른 namespace와는 연결될 수 없다.</li></ul></li><li>Pod에는 여러 Container가 있을 수 있다. 또한 Volume을 마운트해서 Pod의 데이터가 증발되지 않도록 한다.</li><li>namespace에는 ResourceQuota와 LimitRange를 설정해서 namespace의 리소스의 양을 제한시킬 수 있다.</li><li>ConfigMap과 Secret으로 Pod의 컨테이너에 환경변수를 설정할 수 있게 한다.</li><li>여러가지 컨트롤러는 Pod들을 관리한다.</li><li>Replication Controller, ReplicaSet은 Pod가 죽으면 다시 구동시키거나 스케일 인/아웃을 해준다.</li><li>Deployment는 배포 후에 Pod를 새 버전으로 업그레이드하고, 문제가 생기면 롤백 해준다.</li><li>DaemonSet은 한 Node에 하나의 Pod만 사용되도록 해준다.</li><li>CronJob은 특정 Job을 주기적으로 수행되도록 해준다.<ul><li>Job은 특정 작업만 하고 종료되는 것이다.</li></ul></li></ul><h2 id=components>Components<a hidden class=anchor aria-hidden=true href=#components>#</a></h2><p><img loading=lazy src=../introduce-kubernetes/2.png alt=2></p><ul><li>master 노드<ul><li>kube-apiserver</li><li>etcd</li><li>kube-scheduler</li><li>kube-controller-manager</li></ul></li><li>worker 노드<ul><li>kubelet</li><li>kube-proxy</li></ul></li></ul><h3 id=kube-apiserver>kube-apiserver<a hidden class=anchor aria-hidden=true href=#kube-apiserver>#</a></h3><ul><li>쿠버네티스 클러스터의 API를 사용할 수 있게 해준다.</li><li>kubectl과 같은 클라이언트로부터 요청 받아낸다.</li></ul><h3 id=etcd>etcd<a hidden class=anchor aria-hidden=true href=#etcd>#</a></h3><ul><li>key-value 형식의 데이터 저장소이다.</li></ul><h3 id=kube-scheduler>kube-scheduler<a hidden class=anchor aria-hidden=true href=#kube-scheduler>#</a></h3><ul><li>Node들의 리소스 상태와 kube-apiserver를 확인하면서, Pod에 Node 정보를 할당한다.</li></ul><h3 id=kube-controller-manager>kube-controller-manager<a hidden class=anchor aria-hidden=true href=#kube-controller-manager>#</a></h3><ul><li>Controller들을 실행한다.</li></ul><h3 id=kubelet>kubelet<a hidden class=anchor aria-hidden=true href=#kubelet>#</a></h3><ul><li>kube-apiserver를 확인하면서 Pod에 자신의 Node 정보가 할당된 것이 있으면 Pod를 생성한다.<ul><li>컨테이너를 생성하고 kube-proxy에 네트워크 생성 요청을 한다.</li></ul></li></ul><h3 id=kube-proxy>kube-proxy<a hidden class=anchor aria-hidden=true href=#kube-proxy>#</a></h3><ul><li>네트워크 규칙을 관리하고 컨테이너가 네트워크를 사용할 수 있도록 한다.</li></ul><h2 id=실습-환경-구축>실습 환경 구축<a hidden class=anchor aria-hidden=true href=#실습-환경-구축>#</a></h2><ul><li>강의에서 소개된 환경이 아닌 minikube를 사용한다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>minikube start <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --driver<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;docker&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --kubernetes-version<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;stable&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --nodes<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 실습을 위해 dashboard 사용</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 실제 업무에서는 secret 등의 값 노출을 막기위해 dashboard를 잘 사용하지 않는다.</span>
</span></span><span style=display:flex><span>minikube dashboard
</span></span></code></pre></div><ul><li>위와 같은 방법으로 master 1개, worker node 2개를 구축하고 dashboard를 사용할 수 있다.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://jo-minjun.github.io/tags/kubernetes/>Kubernetes</a></li></ul><nav class=paginav><a class=prev href=https://jo-minjun.github.io/notes/kubernetes-pod-service/><span class=title>« Prev</span><br><span>Kubernetes: pod와 service</span></a>
<a class=next href=https://jo-minjun.github.io/notes/kubectl-command/><span class=title>Next »</span><br><span>kubectl command</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://jo-minjun.github.io/>minjun's memory</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>