<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>네트워크 기초 지식 | minjun's memory</title><meta name=keywords content="Network"><meta name=description content="1. MAC, IP, Port 번호의 식별 MAC, IP, Port는 각 다음과 같은 레이어의 식별자이다. * DoD로 구분한 Layer * user mode ============================================ - Application kernel mode ============================================ - Transport: PORT - Network: IP H/W ============================================ - Access: MAC Transport
Port가 식별자가 된다. Network
Host에 대해서 IP가 식별자가 된다. Host: 네트워크에 연결된 컴퓨터, NIC 하나에 IP 주소를 여러 개 바인딩 할 수 있다.
→ Host에 IP가 여러개 존재한다. Access
Network Interface Card에 대해서 MAC이 식별자가 된다."><meta name=author content="조민준"><link rel=canonical href=https://jo-minjun.github.io/notes/networkbasic/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://jo-minjun.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jo-minjun.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jo-minjun.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jo-minjun.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jo-minjun.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZW1ZBXB1FD"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZW1ZBXB1FD",{anonymize_ip:!1})}</script><meta property="og:title" content="네트워크 기초 지식"><meta property="og:description" content="1. MAC, IP, Port 번호의 식별 MAC, IP, Port는 각 다음과 같은 레이어의 식별자이다. * DoD로 구분한 Layer * user mode ============================================ - Application kernel mode ============================================ - Transport: PORT - Network: IP H/W ============================================ - Access: MAC Transport
Port가 식별자가 된다. Network
Host에 대해서 IP가 식별자가 된다. Host: 네트워크에 연결된 컴퓨터, NIC 하나에 IP 주소를 여러 개 바인딩 할 수 있다.
→ Host에 IP가 여러개 존재한다. Access
Network Interface Card에 대해서 MAC이 식별자가 된다."><meta property="og:type" content="article"><meta property="og:url" content="https://jo-minjun.github.io/notes/networkbasic/"><meta property="article:section" content="notes"><meta property="article:published_time" content="2022-08-17T17:10:48+09:00"><meta property="article:modified_time" content="2022-08-17T17:10:48+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="네트워크 기초 지식"><meta name=twitter:description content="1. MAC, IP, Port 번호의 식별 MAC, IP, Port는 각 다음과 같은 레이어의 식별자이다. * DoD로 구분한 Layer * user mode ============================================ - Application kernel mode ============================================ - Transport: PORT - Network: IP H/W ============================================ - Access: MAC Transport
Port가 식별자가 된다. Network
Host에 대해서 IP가 식별자가 된다. Host: 네트워크에 연결된 컴퓨터, NIC 하나에 IP 주소를 여러 개 바인딩 할 수 있다.
→ Host에 IP가 여러개 존재한다. Access
Network Interface Card에 대해서 MAC이 식별자가 된다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Notes","item":"https://jo-minjun.github.io/notes/"},{"@type":"ListItem","position":3,"name":"네트워크 기초 지식","item":"https://jo-minjun.github.io/notes/networkbasic/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"네트워크 기초 지식","name":"네트워크 기초 지식","description":"1. MAC, IP, Port 번호의 식별 MAC, IP, Port는 각 다음과 같은 레이어의 식별자이다. * DoD로 구분한 Layer * user mode ============================================ - Application kernel mode ============================================ - Transport: PORT - Network: IP H/W ============================================ - Access: MAC Transport\nPort가 식별자가 된다. Network\nHost에 대해서 IP가 식별자가 된다. Host: 네트워크에 연결된 컴퓨터, NIC 하나에 IP 주소를 여러 개 바인딩 할 수 있다.\n→ Host에 IP가 여러개 존재한다. Access\nNetwork Interface Card에 대해서 MAC이 식별자가 된다.","keywords":["Network"],"articleBody":"1. MAC, IP, Port 번호의 식별 MAC, IP, Port는 각 다음과 같은 레이어의 식별자이다. * DoD로 구분한 Layer * user mode ============================================ - Application kernel mode ============================================ - Transport: PORT - Network: IP H/W ============================================ - Access: MAC Transport\nPort가 식별자가 된다. Network\nHost에 대해서 IP가 식별자가 된다. Host: 네트워크에 연결된 컴퓨터, NIC 하나에 IP 주소를 여러 개 바인딩 할 수 있다.\n→ Host에 IP가 여러개 존재한다. Access\nNetwork Interface Card에 대해서 MAC이 식별자가 된다. 하드웨어 식별자지만, MAC 변경이 가능하다. Network Interface Card: 노트북은 유선/무선 랜카드가 2개 → NIC가 2개 2. Host, Switch, Network의 관계 Host는 Network에 연결된 컴퓨터이다.\nNetwork는 다음과 같이 두 가지로 나뉜다.\nNetwork 이용 주체 → End-Point가 된다. (Peer, Server, Client 등) Network 자체 → 이 Computer를 Switch라 한다. (Firewall, Router 등) Network는 Router(L3 Switch)와 DNS의 집합체이다.\n(스위칭 비용 증가) user mode ============================================ L7 -------------------------------------------- L6 -------------------------------------------- L5 -------------------------------------------- kernel mode ============================================ L4 - TCP -------------------------------------------- L3 (Router) - IP -------------------------------------------- H/W ============================================ L2 -------------------------------------------- L1 -------------------------------------------- (스위칭 비용 감소) 3. IPv4 주소 체계 IP 주소 Host에 대한 식별자\nIP 주소는 다음과 같이 두가지 표현 방법이 있다.\nIPv4: 32bit IPv6: 128bit IPv4의 32bit는 다음과 같이 이루어져 있다.\n32bit는 8bit씩 나누어 표기한다. 121.123.223.10 크게 두 부분으로 나뉜다. Net ID, Host ID Net ID Host ID ----------- -- 121.123.223.10 이때 Net ID의 길이를 구분하기 위해 서브넷 마스크를 사용한다. 서브넷 마스크 서브넷 마스크도 32bit로, 8bit씩 나누어 표기한다.\n서브넷 마스크와 IP 주소를 and 연산하면 Net ID를 확인할 수 있다.\n하지만 일반적으로 다음과 같이 Net ID의 길이를 함께 표기한다.\n121.123.223.10/24 → 121.123.223.0은 Net ID, Host는 10이다.\n이 표기하는 것을 CIDR라 한다. 4. Port 번호의 이해 Port는 관점에 따라 여러 의미를 가진다.\nProcess 식별자 Service 식별자 Interface 번호 여기서는 개발자 관점에서 Process 식별자를 알아본다.\nuser mode ============================================ - Process kernel mode ============================================ - TCP - IP - Driver H/W ============================================ - NIC kernel mode는 user mode가 접근이 가능하게 하기 위해 file이라는 인터페이스를 제공한다. 하지만 이를 프로토콜 관점에서 추상화하면 socket이 된다. 이때 socket에 attach되는 정보 중 하나가 Port 번호이다. Port는 다음과 같은 특징이 있다.\nsocket에 attach되는 정보이다. 16bit 정보이다. → 2^16\n→ Port 번호의 범위는 0 ~ 61535 이다. (하지만 0과 61535는 사용할 수 없다.)\n패킷이 하위 레이어에서 상위 레이어로 올라갈 때 Port를 이용해서 프로세스를 식별한다. 5. Switch, Switching Switching은 경로 또는 인터페이스를 선택하는 것이다.\n이 때 선택지가 나오는 곳을 Switch라 한다.\nNetwork는 라우터와 DNS의 집합이다.\n라우터는 L3 스위치이다. 라우터는 라우팅 테이블을 근거로 최적의 경로를 찾아낸다. 6. 네트워크 데이터 단위 user mode ============================================ - Application (Socket 수준) kernel mode ============================================ - TCP - IP H/W ============================================ - 위에서 설명한 user와 kernel 모드 사이의 file(socket)은 Stream이다. 기본적으로 file은 사용자가 계속 데이터를 입력하면 계속해서 데이터가 커진다. TCP에서 다루는 데이터 단위: Segment IP에서 다루는 데이터 단위: Packet IP 아래 단계에서 다루는 데이터 단위: Frame 이 데이터 단위의 흐름은 다음과 같다.\nStream이 Segment로 넘어갈 때 일정한 길이로 데이터를 분해한다. 이때 **Segment의 최대 크기를 Maximum Segment Size(MSS)**라 한다. MSS는 Packet의 최대 크기으로 결정하게 되는데, Packet의 최대 크기를 (Maximum Transport Unit)MTU라 한다. 이 Packet을 Frame 데이터로 캡슐화하여 전달한다. 7. 네트워크 인터페이스 선택 원리와 기준 user mode ============================================ - HTTP (L7) - - SSL kernel mode ============================================ - TCP, UDP (L4) - IP (L3) H/W ============================================ - Ethernet - 아래와 같은 상황에서 인터페이스는 어떻게 선택될까?\n사용자가 브라우저를 켰다. (Socket이 열리고, TCP와 IP가 바인딩 되어야 한다.) KT 유선 인터넷과 SKT 무선 인터넷을 두 개 연결했다. (일반적으로 IP 주소는 2개가 된다.) → 메트릭(쉽게 말해 비용) 값으로 결정한다.\n→ 따라서 위 경우에는 KT 유선과 SKT 무선 중 메트랙 값이 적은 쪽으로 바인딩 된다.\n8. 웹 서비스를 만드신 분에 대해 웹 탄생 배경 영국 물리학 연구원 팀 버너스 리 연구원은 논문을 많이 읽는다. 논문에는 항상 참고문헌이 많았다. 하지만 당시 링크 개념이 존재하지 않았고 문서는 모두 Text 파일이었다. → 문서(Text) + Link 를 이용해서 HTML이라는 문서 형식을 만들었다.\n→ HTML의 인터넷 전달 방법을 위해서 HTTP라는 프로토콜을 만들었다.\n→ 여러 문서들이 계속해서 연결되니, Web이 형성되었다.\n→ 이는 웹 서비스가 되었고, 팀 버너스 리가 창안했다.\n9. 초창기 웹 서비스의 구조 **웹 클라이언트 (브라우저)**는 인터넷을 통해서 웹 서버와 연결된다.\n이때 연결은 HTTP라는 TCP/IP 기반으로 된다.\nHTTP는 Stateless하다. 웹 클라이언트의 IP 주소가 있고 웹 서버에도 IP 주소가 있다.\n→ 이 주소 URL을 알고 리소스(HTML 문서)에 대한 요청을 하면 연결이 되고, 응답을 준다.\n→ 응답을 받은 클라이언트는 HTML 구문 분석을 하고, 내용을 렌더링 한다.\n즉, 이 당시 브라우저는 원격 문서 뷰어 역할(단방향 작용)을 했다.\n10. 웹 서비스 3대 요소 위 구조에는 문제가 있었다.\n문서의 내용과는 별개로 UI를 개선하고 싶었다.\n→ HTML에 기능을 추가하니 유지보수가 불편하다.\n→ CSS와 이미지가 나왔다.\n→ 요청하면 HTML + CSS + IMAGE(서버에 저장되어 있다.)가 순서대로 응답된다.\n문서를 변경해야 했다.\n→ 문서를 변경하기 위해 처리를 담당하는 서버가 생겼다.\n→ 단방향 작용이 양방향 상호 작용이 되면서 상태를 처리해야 했다.\n→ DB를 이용해서 처리하게 되었다.\n문서가 변경되고, 처리가 되니 문서가 복잡해졌다.\n→ 기능에 따라 동적인 움직임을 주는 것이 필요해졌다.\n→ 브라우저에서 렌더링 후에 연산하는 기능을 가지게 되었다. (Javascript)\n즉, 웹 서비스 3대 요소는 다음과 같다.\nHTML 구문 분석 렌더링 연산 11. LAN vs WAN 주의) 이 내용은 명확한 구분은 아니다. user mode ============================================ - HTTP - - SSL kernel mode (Logical == virtual) ============================================ - TCP, UDP - IP(IP 주소) --\u003e [Internet] == [virtual network] -\u003e *WAN H/W (Physical) ============================================ - Ethernet(MAC 주소) --\u003e *LAN - LAN과 WAN은 흔히 범위의 차이로 구분한다.\n하지만 논리/물리적 구성요소로 구분하는 방법은 아래와 같다.\n시스템은 S/W와 H/W로 구분된다. S/W(kernel mode 이상)은 IP(Internet Protocol) 를 이용해서 통신한다. Internet은 virtual network이다. → WAN H/W는 MAC 주소를 이용한다. (이는 물리적인 주소이다.) → 하드웨어로 설명되는 네트워크 → LAN 12. 패킷의 생성 원리와 캡슐화 user mode ============================================ - HTTP - - SSL kernel mode ============================================ - TCP, UDP - IP H/W ============================================ - Ethernet - user mode 영역은 socket에 데이터를 IO한다. socket은 file을 추상화한 것이다. 때문에 데이터를 계속해서 쓰기할 수 있다. 이때 데이터의 단위는 Stream이다. user mode의 Stream이 Kernel mode에서 일정 단위로 나누어진다. 이때 데이터의 단위는 Segment이다. 이 Segment가 한 번 캡슐화되어 Packet이 된다. Packet의 최대 크기: MTU(Maximum Transport Unit) 일반적으로 1500이다. Packet의 구조: Header, Payload Header에는 IP(L3)와 TCP(L4) 데이터가 있다. 이때 크기는 일반적으로 각 20씩으로 총 40이다. MTU 크기 - Header 크기 = 1460이다. 이 크기가 MSS(Maximum Segment Size) 이다. Stream을 1460 크기로 나눈 것이다. H/W영역에서 Packet이 한 번 더 캡슐화된다. Frame이 된다. 13. L2 스위치 L2 스위치는 MAC 주소(48bit)로 스위칭시킨다.\n(multilayer switch) NIC L2 Access L2 Distribution L2 Access NIC | (Up-link) (Up-link) |---------------#---------------| PC1------| | |---------PC3 | | | | | | | | |---------PC4 PC2------| | | | | | | | (Up-link) | (gateway) @ 라우터 | (방화벽) L2 Access: End-Point가 네트워크에서 가장 처음 만나는 스위치 L2 Distribution: L2 Access와 L3 라우터를 연결해주는 스위치 Up-link: 상위 계층 스위치로 연결되는 케이블 14. IP Header 위에서 언급한 것처럼 IP의 헤더는 20바이트이다. (+ @ Opitonal)\n최상단 우측에 Total Length는 16비트인데, 이것은 패킷의 최대 크기를 나타낸다.\n따라서 패킷의 최대 크기는 2^16정도인 65536이다. Identification ~ Fragment Offset은 단편화에 관련된 부분이다.\n단편화는 큰 패킷을 작은 패킷으로 나눈 것을 말한다. MTU가 1400인 곳에 1500짜리 패킷을 보내는 경우 단편화가 일어난다. TTL은 패킷이 라우터 하나를 지날때마다 1씩 감소하고 0이 되면 패킷이 사라진다.\n일반적으로 값은 256이다. (2^8) Protocol은 상위 계층 프로토콜이다.\n이 값을 보고 데이터가 TCP인지 UDP 인지 다른 값인지 확인할 수 있다. Header checksum은 전송간에 오류가 있는지 확인한다.\n15. Proxy 구조와 원리 Proxy는 대리자 역할을 한다.\nHTTPS TCP/IP PC1 (1.1.1.1)--------------Internet--------------------SERVER(9.9.9.9) PC1 (1.1.1.1) SERVER(9.9.9.9) | | | | Internet | | | | (Proxy) | PC2 (2.2.2.2)---------------- Internet---------------------| user mode | PC2 ============================================ - HTTP | Proxy 역할을 하는 - | Process - SSL | (Stream) | socket1 socket2 kernel mode | ============================================ - TCP, UDP | - IP | | H/W | ============================================ - Ethernet | - | socket1은 외부에서 접속하길 대기하고 있다. PC1이 접근 정보가 들어오면 socket2를 이용해서 9.9.9.9에 접근 16. Proxy의 활용 1. 우회 Proxy를 사용하면 SERVER 입장에서 PC2의 아이피를 확인한다.\n그러나 PC2는 PC1의 모든 통신을 감청할 수 있다.\n2. 분석 웹 통신에 SSL을 적용하면 패킷 레벨에서 데이터가 암호화되어 있다.\n때문에 와이어 샤크등 프로그램에서 복호화된 데이터를 확인할 수 없다.\n이때 프록시를 아래와 같이 사용할 수 있다.\nProxy를 127.0.0.1:8080으로 건다. (내 PC) HTTP 요청을 보내면 8080번 포트의 소켓으로 데이터가 지나간다. 이 평문 데이터를 Stream 레벨에서 확인한다. 17. TCP 송신/수신 원리 Stream을 Segment로 나눈다. 이때 TCP Buffer(Window Size)에 데이터를 저장하고, 일정 크기가 되면 Segment로 나눈다. Segment를 Packet으로 캡슐화한다. Packet을 Frame으로 캡슐화한다. Frame을 전달한다. 전체를 보내는 것은 아니다. (n개 만큼 보낸다.) 일반적으로 Frame은 바뀔 수 있다. (Packet은 그대로 이지만) Frame을 전달받고 Segment로 만든다. n개의 Segment를 받으면 TCP Buffer에 저장하고 ackn+1을 송신쪽에 전달한다. ack에는 Window Size가 포함되어 있다. 송신쪽은 ackn+1을 받고 Segment를 n+1번부터 다시 보낸다. 이 과정때문에 속도 지연이 발생한다. (UDP 보다 느리다.) 만약 ack로 받은 수신 측 Window Size가 작으면 Segment를 보내지 않는다. 18. TCP 연결에 대해 TCP는 연결지향 프로토콜이다.\n우선 아래 TCP 헤더를 보자\n출발지/목적지 Port 번호가 가장위에 위치한다. Sequence Number: 32bit → 4GB (2^32), Segment의 순서 TCP Flags: Ack, Sync 3-way handshake에 사용 3-way handshake\nSeq번호와 MSS를 교환하는 행위 혼잡 제어 정책 교환 19. Unicast, Broadcast, Multicast NIC L2 Access L2 Distribution L2 Access NIC | (Up-link) (Up-link) |---------------#---------------| PC1------| | |---------PC3 | | | | | | | | |---------PC4 PC2------| | | | | | | | (Up-link) | @ 라우터 (gateway) (방화벽) Unicast\nL2 스위치 내부에서 연결이 끝나는 것 (라우터 이전) 한번에 한 지점에게만 신호를 보낸다. Broadcast\n어떤 지점에서 다수의 지점에 신호를 보내는 것 네트워크 효율을 떨어뜨린다. 2진수 IP의 끝자리가 모두 1이다. (210.153.0.255) Multicast\nBroadcast와 유사하나 관심이 없는 지점은 신호를 보내지 않음 Group을 등록해서 Group에 전달함 20. IP의 종류 Global\n인터넷(public, global network)에서 라우터가 라우팅 시켜주는 IP이다. Private\n작은 소규모 사설 인터넷을 구축할 때 사용한다. 공유기에서도 자주 사용한다. 공유기는 하나의 Global IP를 Private IP에 공유해주는 역할을 한다. 4개의 클래스로 나뉜다. A: network id: 8bit host id: 24bit 10.xxx.xxx.xxx B network id: 12bit host id: 20bit 172.16.xxx.xxx C network id: 16bit host id: 16bit 192.168.xxx.xxx D multicast를 할 때 사용한다. Loopback\n127.0.0.1 호스트 자신을 의미한다. 패킷이 만들어지지만 L2로 가지는 않는다. Broadcast\n다수의 지점에 신호를 보낼 때 사용한다. 21. DNS Domain Name\n숫자로된 IP를 사람이 보기 편하도록 해준다. naver.com google.com DNS\nIP와 Domain Name을 연결하는 테이블 역할 DNS는 계층적 구조로 되어 있다. (분산형 DB 구조) 가장 상위 DNS인 root DNS는 전세계에 13대가 있다. Domain Name으로 IP를 찾는 과정\n컴퓨터 캐시에서 검색 host file에서 검색 DNS에서 검색 root DNS에서 .com, co.kr 등을 관리하는 DNS 목록을 검색 DNS 목록에서 검색 … 22. TCP/IP 통신과 MAC 주소 TCP/IP 통신을 할 때의 MAC 주소의 변화\n패킷이 프레임으로 캡슐화된다. 프레임 헤더에도 시작/목적 지점이 있다. L2 구간(라우터)을 지나면 프레임 헤더가 새로 교체된다. L2구간에 새로 접근할 때마다 프레임 헤더의 시작/목적 지점도 계속해서 변경된다. MAC 주소만 고려하고, IP 주소는 고려하지 않는다. 23. MTU와 Packet 단편화 위 그림에서 2번째 줄(Identification, Fragment Offset)이 단편화 관련 부분이다. MTU는 1500이 기본값인 경우가 많다. MTU - 20(IP 헤더) - 20(TCP 헤더) = MSS이다. 아래와 같은 경우에는 단편화가 어떻게 이루어 질까?\nMTU:1500 MTU:1500 MTU:1400 MTU:1500 MTU:1500 PC1 ---|---#-----R1-------------R2-------------R3-----SERVER 위 경우 R1 → R2에서 단편화가 이루어져야 한다. 1500짜리 패킷을 어느 지점에서 자른다. A와 B가 생긴다. 헤더와 A를 붙이고, 헤더와 B를 붙여서 2개의 패킷을 만든다. 이때 두 패킷 헤더의 Idenfication이 같은 값이 된다. Fragment Offset 값은 A는 0, B는 A의 길이만큼이 된다. 수신하는 쪽에서 단편화를 조립한다. (SERVER) 24. 서브넷팅 ISP(Internet Service Provider)에게 어떤 회사가 100개의 사설 IP를 요청하면 어떻게 될까?\nC레벨(Net ID: 24, Host ID: 8)인 private IP를 할당한다. 그런데 C레벨 private IP를 할당하면 2^8 - 100 = 146개의 IP를 낭비하게 되는 것이다. 이런 경우 서브넷팅을 사용할 수 있다. 서브넷팅은 Net ID에 몇 개의 비트를 더 할당하는 것이다.\n192.168.0.1/25라면 마지막 4번째 자리의 1의 가장 앞부분 비트를 Net ID로 할당 시킨다. (192.168.0.0)0000001 (192.168.0.1)0000001 하지만 Host ID가 0인 경우는 아무것도 가리키지 않고, 2진수에서 모두 1인 경우는 broadcast IP 이므로 서브넷 하나마다 2개의 IP를 손실보게 된다. 예를 들어 이 경우라면 192.168.0.1/25 192.168.0.00000000, 192.168.0.01111111 192.168.0.10000000, 192.168.0.11111111 위 4가지 IP를 손실보게 된다. Reference https://www.youtube.com/watch?v=k1gyh9BlOT8\u0026list=PLXvgR_grOs1BFH-TuqFsfHqbh-gpMbFoy ","wordCount":"1907","inLanguage":"en","datePublished":"2022-08-17T17:10:48+09:00","dateModified":"2022-08-17T17:10:48+09:00","author":[{"@type":"Person","name":"조민준"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://jo-minjun.github.io/notes/networkbasic/"},"publisher":{"@type":"Organization","name":"minjun's memory","logo":{"@type":"ImageObject","url":"https://jo-minjun.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jo-minjun.github.io accesskey=h title="minjun's memory (Alt + H)">minjun's memory</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jo-minjun.github.io/search title=" (Alt + /)" accesskey=/><span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="23" y1="23" x2="16.65" y2="16.65"/></svg></span></a></li><li><a href=https://jo-minjun.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://jo-minjun.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jo-minjun.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jo-minjun.github.io/notes/ title=Notes><span>Notes</span></a></li><li><a href=https://jo-minjun.github.io/doodles/ title=끄적끄적><span>끄적끄적</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jo-minjun.github.io>Home</a>&nbsp;»&nbsp;<a href=https://jo-minjun.github.io/notes/>Notes</a></div><h1 class=post-title>네트워크 기초 지식</h1><div class=post-meta><span title='2022-08-17 17:10:48 +0900 +0900'>August 17, 2022</span>&nbsp;·&nbsp;조민준&nbsp;|&nbsp;<a href=https://github.com/jo-minjun/my-blog/issues/new rel="noopener noreferrer" target=_blank>변경 요청 &lt;-- 내용이 잘못되었다면?</a></div></header><br><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>목차 보기</span></summary><div class=inner><ul><li><a href=#1-mac-ip-port-%eb%b2%88%ed%98%b8%ec%9d%98-%ec%8b%9d%eb%b3%84 aria-label="1. MAC, IP, Port 번호의 식별">1. MAC, IP, Port 번호의 식별</a><ul><li><a href=#mac-ip-port%eb%8a%94-%ea%b0%81-%eb%8b%a4%ec%9d%8c%ea%b3%bc-%ea%b0%99%ec%9d%80-%eb%a0%88%ec%9d%b4%ec%96%b4%ec%9d%98-%ec%8b%9d%eb%b3%84%ec%9e%90%ec%9d%b4%eb%8b%a4 aria-label="MAC, IP, Port는 각 다음과 같은 레이어의 식별자이다.">MAC, IP, Port는 각 다음과 같은 레이어의 식별자이다.</a></li></ul></li><li><a href=#2-host-switch-network%ec%9d%98-%ea%b4%80%ea%b3%84 aria-label="2. Host, Switch, Network의 관계">2. Host, Switch, Network의 관계</a></li><li><a href=#3-ipv4-%ec%a3%bc%ec%86%8c-%ec%b2%b4%ea%b3%84 aria-label="3. IPv4 주소 체계">3. IPv4 주소 체계</a><ul><li><a href=#ip-%ec%a3%bc%ec%86%8c aria-label="IP 주소">IP 주소</a></li><li><a href=#%ec%84%9c%eb%b8%8c%eb%84%b7-%eb%a7%88%ec%8a%a4%ed%81%ac aria-label="서브넷 마스크">서브넷 마스크</a></li></ul></li><li><a href=#4-port-%eb%b2%88%ed%98%b8%ec%9d%98-%ec%9d%b4%ed%95%b4 aria-label="4. Port 번호의 이해">4. Port 번호의 이해</a></li><li><a href=#5-switch-switching aria-label="5. Switch, Switching">5. Switch, Switching</a></li><li><a href=#6-%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac-%eb%8d%b0%ec%9d%b4%ed%84%b0-%eb%8b%a8%ec%9c%84 aria-label="6. 네트워크 데이터 단위">6. 네트워크 데이터 단위</a></li><li><a href=#7-%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac-%ec%9d%b8%ed%84%b0%ed%8e%98%ec%9d%b4%ec%8a%a4-%ec%84%a0%ed%83%9d-%ec%9b%90%eb%a6%ac%ec%99%80-%ea%b8%b0%ec%a4%80 aria-label="7. 네트워크 인터페이스 선택 원리와 기준">7. 네트워크 인터페이스 선택 원리와 기준</a></li><li><a href=#8-%ec%9b%b9-%ec%84%9c%eb%b9%84%ec%8a%a4%eb%a5%bc-%eb%a7%8c%eb%93%9c%ec%8b%a0-%eb%b6%84%ec%97%90-%eb%8c%80%ed%95%b4 aria-label="8. 웹 서비스를 만드신 분에 대해">8. 웹 서비스를 만드신 분에 대해</a><ul><li><a href=#%ec%9b%b9-%ed%83%84%ec%83%9d-%eb%b0%b0%ea%b2%bd aria-label="웹 탄생 배경">웹 탄생 배경</a></li></ul></li><li><a href=#9-%ec%b4%88%ec%b0%bd%ea%b8%b0-%ec%9b%b9-%ec%84%9c%eb%b9%84%ec%8a%a4%ec%9d%98-%ea%b5%ac%ec%a1%b0 aria-label="9. 초창기 웹 서비스의 구조">9. 초창기 웹 서비스의 구조</a></li><li><a href=#10-%ec%9b%b9-%ec%84%9c%eb%b9%84%ec%8a%a4-3%eb%8c%80-%ec%9a%94%ec%86%8c aria-label="10. 웹 서비스 3대 요소">10. 웹 서비스 3대 요소</a></li><li><a href=#11-lan-vs-wan aria-label="11. LAN vs WAN">11. LAN vs WAN</a></li><li><a href=#12-%ed%8c%a8%ed%82%b7%ec%9d%98-%ec%83%9d%ec%84%b1-%ec%9b%90%eb%a6%ac%ec%99%80-%ec%ba%a1%ec%8a%90%ed%99%94 aria-label="12. 패킷의 생성 원리와 캡슐화">12. 패킷의 생성 원리와 캡슐화</a></li><li><a href=#13-l2-%ec%8a%a4%ec%9c%84%ec%b9%98 aria-label="13. L2 스위치">13. L2 스위치</a></li><li><a href=#14-ip-header aria-label="14. IP Header">14. IP Header</a></li><li><a href=#15-proxy-%ea%b5%ac%ec%a1%b0%ec%99%80-%ec%9b%90%eb%a6%ac aria-label="15. Proxy 구조와 원리">15. Proxy 구조와 원리</a></li><li><a href=#16-proxy%ec%9d%98-%ed%99%9c%ec%9a%a9 aria-label="16. Proxy의 활용">16. Proxy의 활용</a><ul><li><a href=#1-%ec%9a%b0%ed%9a%8c aria-label="1. 우회">1. 우회</a></li><li><a href=#2-%eb%b6%84%ec%84%9d aria-label="2. 분석">2. 분석</a></li></ul></li><li><a href=#17-tcp-%ec%86%a1%ec%8b%a0%ec%88%98%ec%8b%a0-%ec%9b%90%eb%a6%ac aria-label="17. TCP 송신/수신 원리">17. TCP 송신/수신 원리</a></li><li><a href=#18-tcp-%ec%97%b0%ea%b2%b0%ec%97%90-%eb%8c%80%ed%95%b4 aria-label="18. TCP 연결에 대해">18. TCP 연결에 대해</a></li><li><a href=#19-unicast-broadcast-multicast aria-label="19. Unicast, Broadcast, Multicast">19. Unicast, Broadcast, Multicast</a></li><li><a href=#20-ip%ec%9d%98-%ec%a2%85%eb%a5%98 aria-label="20. IP의 종류">20. IP의 종류</a></li><li><a href=#21-dns aria-label="21. DNS">21. DNS</a></li><li><a href=#22-tcpip-%ed%86%b5%ec%8b%a0%ea%b3%bc-mac-%ec%a3%bc%ec%86%8c aria-label="22. TCP/IP 통신과 MAC 주소">22. TCP/IP 통신과 MAC 주소</a></li><li><a href=#23-mtu%ec%99%80-packet-%eb%8b%a8%ed%8e%b8%ed%99%94 aria-label="23. MTU와 Packet 단편화">23. MTU와 Packet 단편화</a></li><li><a href=#24-%ec%84%9c%eb%b8%8c%eb%84%b7%ed%8c%85 aria-label="24. 서브넷팅">24. 서브넷팅</a></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h2 id=1-mac-ip-port-번호의-식별>1. MAC, IP, Port 번호의 식별<a hidden class=anchor aria-hidden=true href=#1-mac-ip-port-번호의-식별>#</a></h2><h3 id=mac-ip-port는-각-다음과-같은-레이어의-식별자이다>MAC, IP, Port는 각 다음과 같은 레이어의 식별자이다.<a hidden class=anchor aria-hidden=true href=#mac-ip-port는-각-다음과-같은-레이어의-식별자이다>#</a></h3><pre tabindex=0><code>* DoD로 구분한 Layer *

user mode
============================================
- Application

kernel mode
============================================
- Transport: PORT
- Network: IP

H/W
============================================
- Access: MAC
</code></pre><p>Transport</p><ul><li>Port가 식별자가 된다.</li></ul><p>Network</p><ul><li>Host에 대해서 IP가 식별자가 된다.<ul><li>Host: 네트워크에 연결된 컴퓨터, NIC 하나에 IP 주소를 여러 개 바인딩 할 수 있다.<br>→ Host에 IP가 여러개 존재한다.</li></ul></li></ul><p>Access</p><ul><li>Network Interface Card에 대해서 MAC이 식별자가 된다.<ul><li>하드웨어 식별자지만, MAC 변경이 가능하다.</li><li>Network Interface Card: 노트북은 유선/무선 랜카드가 2개
→ NIC가 2개</li></ul></li></ul><h2 id=2-host-switch-network의-관계>2. Host, Switch, Network의 관계<a hidden class=anchor aria-hidden=true href=#2-host-switch-network의-관계>#</a></h2><p><strong>Host</strong>는 Network에 연결된 컴퓨터이다.</p><p>Network는 다음과 같이 두 가지로 나뉜다.</p><ul><li>Network 이용 주체
→ <strong>End-Point</strong>가 된다. (Peer, Server, Client 등)</li><li>Network 자체
→ 이 Computer를 <strong>Switch</strong>라 한다. (Firewall, Router 등)</li></ul><p><strong>Network</strong>는 <strong>Router(L3 Switch)와 DNS의 집합체</strong>이다.</p><pre tabindex=0><code>(스위칭 비용 증가)

user mode
============================================
L7
--------------------------------------------
L6
--------------------------------------------
L5
--------------------------------------------

kernel mode
============================================
L4
- TCP
--------------------------------------------
L3 (Router)
- IP
--------------------------------------------

H/W
============================================
L2
--------------------------------------------
L1
--------------------------------------------

(스위칭 비용 감소)
</code></pre><h2 id=3-ipv4-주소-체계>3. IPv4 주소 체계<a hidden class=anchor aria-hidden=true href=#3-ipv4-주소-체계>#</a></h2><h3 id=ip-주소>IP 주소<a hidden class=anchor aria-hidden=true href=#ip-주소>#</a></h3><p>Host에 대한 식별자</p><p>IP 주소는 다음과 같이 두가지 표현 방법이 있다.</p><ul><li>IPv4: 32bit</li><li>IPv6: 128bit</li></ul><p>IPv4의 32bit는 다음과 같이 이루어져 있다.</p><ul><li>32bit는 8bit씩 나누어 표기한다.<ul><li>121.123.223.10</li></ul></li><li>크게 두 부분으로 나뉜다.<ul><li>Net ID, Host ID</li></ul><pre tabindex=0><code>Net ID   Host ID
----------- --
121.123.223.10
</code></pre><ul><li>이때 Net ID의 길이를 구분하기 위해 서브넷 마스크를 사용한다.</li></ul></li></ul><h3 id=서브넷-마스크>서브넷 마스크<a hidden class=anchor aria-hidden=true href=#서브넷-마스크>#</a></h3><p>서브넷 마스크도 32bit로, 8bit씩 나누어 표기한다.</p><p>서브넷 마스크와 IP 주소를 and 연산하면 Net ID를 확인할 수 있다.</p><p>하지만 일반적으로 다음과 같이 Net ID의 길이를 함께 표기한다.</p><ul><li>121.123.223.10/24</li></ul><p>→ 121.123.223.0은 Net ID, Host는 10이다.</p><ul><li>이 표기하는 것을 CIDR라 한다.</li></ul><h2 id=4-port-번호의-이해>4. Port 번호의 이해<a hidden class=anchor aria-hidden=true href=#4-port-번호의-이해>#</a></h2><p>Port는 관점에 따라 여러 의미를 가진다.</p><ul><li>Process 식별자</li><li>Service 식별자</li><li>Interface 번호</li></ul><p>여기서는 개발자 관점에서 Process 식별자를 알아본다.</p><pre tabindex=0><code>user mode
============================================
- Process

kernel mode
============================================
- TCP
- IP

- Driver
H/W
============================================
- NIC
</code></pre><ul><li>kernel mode는 user mode가 접근이 가능하게 하기 위해 file이라는 인터페이스를 제공한다.</li><li>하지만 이를 프로토콜 관점에서 추상화하면 socket이 된다.</li><li>이때 socket에 attach되는 정보 중 하나가 Port 번호이다.</li></ul><p>Port는 다음과 같은 특징이 있다.</p><ul><li>socket에 attach되는 정보이다.</li><li>16bit 정보이다.</li></ul><p>→ 2^16</p><p>→ Port 번호의 범위는 0 ~ 61535 이다. (하지만 0과 61535는 사용할 수 없다.)</p><ul><li>패킷이 하위 레이어에서 상위 레이어로 올라갈 때 Port를 이용해서 프로세스를 식별한다.</li></ul><h2 id=5-switch-switching>5. Switch, Switching<a hidden class=anchor aria-hidden=true href=#5-switch-switching>#</a></h2><p><strong>Switching은 경로 또는 인터페이스를 선택</strong>하는 것이다.</p><p>이 때 <strong>선택지가 나오는 곳을 Switch</strong>라 한다.</p><p>Network는 라우터와 DNS의 집합이다.</p><ul><li>라우터는 L3 스위치이다.</li><li>라우터는 <strong>라우팅 테이블</strong>을 근거로 최적의 경로를 찾아낸다.</li></ul><h2 id=6-네트워크-데이터-단위>6. 네트워크 데이터 단위<a hidden class=anchor aria-hidden=true href=#6-네트워크-데이터-단위>#</a></h2><pre tabindex=0><code>user mode
============================================
- Application (Socket 수준)

kernel mode
============================================
- TCP
- IP

H/W
============================================
-
</code></pre><ul><li>위에서 설명한 user와 kernel 모드 사이의 file(socket)은 <strong>Stream</strong>이다.<ul><li>기본적으로 file은 사용자가 계속 데이터를 입력하면 계속해서 데이터가 커진다.</li></ul></li><li>TCP에서 다루는 데이터 단위: <strong>Segment</strong></li><li>IP에서 다루는 데이터 단위: <strong>Packet</strong></li><li>IP 아래 단계에서 다루는 데이터 단위: <strong>Frame</strong></li></ul><p>이 데이터 단위의 흐름은 다음과 같다.</p><ul><li>Stream이 Segment로 넘어갈 때 일정한 길이로 데이터를 분해한다.<ul><li>이때 **Segment의 최대 크기를 Maximum Segment Size(MSS)**라 한다.</li></ul></li><li>MSS는 Packet의 최대 크기으로 결정하게 되는데, <strong>Packet의 최대 크기를 (Maximum Transport Unit)MTU</strong>라 한다.</li><li>이 Packet을 Frame 데이터로 캡슐화하여 전달한다.</li></ul><h2 id=7-네트워크-인터페이스-선택-원리와-기준>7. 네트워크 인터페이스 선택 원리와 기준<a hidden class=anchor aria-hidden=true href=#7-네트워크-인터페이스-선택-원리와-기준>#</a></h2><pre tabindex=0><code>user mode
============================================
- HTTP (L7)
-
- SSL

kernel mode
============================================
- TCP, UDP (L4)
- IP (L3)

H/W
============================================
- Ethernet
-
</code></pre><p>아래와 같은 상황에서 인터페이스는 어떻게 선택될까?</p><ul><li>사용자가 브라우저를 켰다. (Socket이 열리고, TCP와 IP가 바인딩 되어야 한다.)</li><li>KT 유선 인터넷과 SKT 무선 인터넷을 두 개 연결했다. (일반적으로 IP 주소는 2개가 된다.)</li></ul><p>→ 메트릭(쉽게 말해 비용) 값으로 결정한다.</p><p>→ 따라서 위 경우에는 KT 유선과 SKT 무선 중 메트랙 값이 적은 쪽으로 바인딩 된다.</p><h2 id=8-웹-서비스를-만드신-분에-대해>8. 웹 서비스를 만드신 분에 대해<a hidden class=anchor aria-hidden=true href=#8-웹-서비스를-만드신-분에-대해>#</a></h2><h3 id=웹-탄생-배경>웹 탄생 배경<a hidden class=anchor aria-hidden=true href=#웹-탄생-배경>#</a></h3><ol><li>영국 물리학 연구원 <strong>팀 버너스 리</strong></li><li>연구원은 논문을 많이 읽는다.</li><li>논문에는 항상 참고문헌이 많았다.</li><li>하지만 당시 링크 개념이 존재하지 않았고 문서는 모두 Text 파일이었다.</li></ol><p>→ 문서(Text) + Link 를 이용해서 <strong>HTML</strong>이라는 문서 형식을 만들었다.</p><p>→ <strong>HTML</strong>의 인터넷 전달 방법을 위해서 <strong>HTTP</strong>라는 프로토콜을 만들었다.</p><p>→ 여러 문서들이 계속해서 연결되니, Web이 형성되었다.</p><p>→ 이는 웹 서비스가 되었고, 팀 버너스 리가 창안했다.</p><h2 id=9-초창기-웹-서비스의-구조>9. 초창기 웹 서비스의 구조<a hidden class=anchor aria-hidden=true href=#9-초창기-웹-서비스의-구조>#</a></h2><p>**웹 클라이언트 (브라우저)**는 인터넷을 통해서 <strong>웹 서버</strong>와 연결된다.</p><p>이때 연결은 HTTP라는 TCP/IP 기반으로 된다.</p><ul><li>HTTP는 Stateless하다.</li></ul><p>웹 클라이언트의 IP 주소가 있고 웹 서버에도 IP 주소가 있다.</p><p>→ 이 주소 URL을 알고 리소스(HTML 문서)에 대한 <strong>요청</strong>을 하면 연결이 되고, <strong>응답</strong>을 준다.</p><p>→ 응답을 받은 클라이언트는 HTML <strong>구문 분석</strong>을 하고, 내용을 <strong>렌더링</strong> 한다.</p><p>즉, 이 당시 브라우저는 원격 문서 뷰어 역할(단방향 작용)을 했다.</p><h2 id=10-웹-서비스-3대-요소>10. 웹 서비스 3대 요소<a hidden class=anchor aria-hidden=true href=#10-웹-서비스-3대-요소>#</a></h2><p>위 구조에는 문제가 있었다.</p><ol><li><p><strong>문서의 내용과는 별개로 UI를 개선하고 싶었다.</strong></p><p>→ HTML에 기능을 추가하니 유지보수가 불편하다.</p><p>→ CSS와 이미지가 나왔다.</p><p>→ 요청하면 HTML + CSS + IMAGE(서버에 저장되어 있다.)가 순서대로 응답된다.</p></li><li><p><strong>문서를 변경해야 했다.</strong></p><p>→ 문서를 변경하기 위해 처리를 담당하는 서버가 생겼다.</p><p>→ 단방향 작용이 양방향 상호 작용이 되면서 상태를 처리해야 했다.</p><p>→ DB를 이용해서 처리하게 되었다.</p></li><li><p><strong>문서가 변경되고, 처리가 되니 문서가 복잡해졌다.</strong></p><p>→ 기능에 따라 동적인 움직임을 주는 것이 필요해졌다.</p><p>→ 브라우저에서 렌더링 후에 <strong>연산</strong>하는 기능을 가지게 되었다. (Javascript)</p></li></ol><p>즉, 웹 서비스 3대 요소는 다음과 같다.</p><ul><li>HTML 구문 분석</li><li>렌더링</li><li>연산</li></ul><h2 id=11-lan-vs-wan>11. LAN vs WAN<a hidden class=anchor aria-hidden=true href=#11-lan-vs-wan>#</a></h2><ul><li>주의) 이 내용은 명확한 구분은 아니다.</li></ul><pre tabindex=0><code>user mode
============================================
- HTTP
-
- SSL

kernel mode (Logical == virtual)
============================================
- TCP, UDP
- IP(IP 주소) --&gt; [Internet] == [virtual network] -&gt; *WAN

H/W (Physical)
============================================
- Ethernet(MAC 주소) --&gt; *LAN
-
</code></pre><p>LAN과 WAN은 흔히 범위의 차이로 구분한다.</p><p>하지만 논리/물리적 구성요소로 구분하는 방법은 아래와 같다.</p><ul><li>시스템은 S/W와 H/W로 구분된다.</li><li>S/W(kernel mode 이상)은 IP(Internet Protocol) 를 이용해서 통신한다.<ul><li>Internet은 virtual network이다.
→ WAN</li></ul></li><li>H/W는 MAC 주소를 이용한다. (이는 물리적인 주소이다.)
→ 하드웨어로 설명되는 네트워크
→ LAN</li></ul><h2 id=12-패킷의-생성-원리와-캡슐화>12. 패킷의 생성 원리와 캡슐화<a hidden class=anchor aria-hidden=true href=#12-패킷의-생성-원리와-캡슐화>#</a></h2><pre tabindex=0><code>user mode
============================================
- HTTP
-
- SSL

kernel mode
============================================
- TCP, UDP
- IP

H/W
============================================
- Ethernet
-
</code></pre><ol><li>user mode 영역은 socket에 데이터를 IO한다.<ul><li>socket은 file을 추상화한 것이다. 때문에 데이터를 계속해서 쓰기할 수 있다.</li><li>이때 데이터의 단위는 Stream이다.</li></ul></li><li>user mode의 Stream이 Kernel mode에서 일정 단위로 나누어진다.<ul><li>이때 데이터의 단위는 Segment이다.</li><li>이 Segment가 한 번 캡슐화되어 Packet이 된다.<ul><li>Packet의 최대 크기: MTU(Maximum Transport Unit)<ul><li>일반적으로 1500이다.</li></ul></li><li>Packet의 구조: Header, Payload</li><li>Header에는 IP(L3)와 TCP(L4) 데이터가 있다.<ul><li>이때 크기는 일반적으로 각 20씩으로 총 40이다.</li></ul></li><li>MTU 크기 - Header 크기 = 1460이다.<ul><li>이 크기가 MSS(Maximum Segment Size) 이다.</li><li>Stream을 1460 크기로 나눈 것이다.</li></ul></li></ul></li></ul></li><li>H/W영역에서 Packet이 한 번 더 캡슐화된다.<ul><li>Frame이 된다.</li></ul></li></ol><h2 id=13-l2-스위치>13. L2 스위치<a hidden class=anchor aria-hidden=true href=#13-l2-스위치>#</a></h2><p>L2 스위치는 MAC 주소(48bit)로 스위칭시킨다.</p><pre tabindex=0><code>                (multilayer switch)
 NIC  L2 Access   L2 Distribution    L2 Access    NIC
         |  (Up-link)        (Up-link)
         |---------------#---------------|
PC1------|               |               |---------PC3
         |               |               |
         |               |               |
         |               |               |---------PC4
PC2------|               |               |
         |               |               |
                         |
                         | (Up-link)
                         |
                     (gateway)
                         @
                       라우터
                         |
                       (방화벽)
</code></pre><ul><li>L2 Access: End-Point가 네트워크에서 가장 처음 만나는 스위치</li><li>L2 Distribution: L2 Access와 L3 라우터를 연결해주는 스위치</li><li>Up-link: 상위 계층 스위치로 연결되는 케이블</li></ul><h2 id=14-ip-header>14. IP Header<a hidden class=anchor aria-hidden=true href=#14-ip-header>#</a></h2><p><img loading=lazy src=../networkbasic/0.png alt=0.png></p><p>위에서 언급한 것처럼 IP의 헤더는 20바이트이다. (+ @ Opitonal)</p><p>최상단 우측에 Total Length는 16비트인데, 이것은 패킷의 최대 크기를 나타낸다.</p><ul><li>따라서 패킷의 최대 크기는 2^16정도인 65536이다.</li></ul><p>Identification ~ Fragment Offset은 단편화에 관련된 부분이다.</p><ul><li>단편화는 큰 패킷을 작은 패킷으로 나눈 것을 말한다.</li><li>MTU가 1400인 곳에 1500짜리 패킷을 보내는 경우 단편화가 일어난다.</li></ul><p>TTL은 패킷이 라우터 하나를 지날때마다 1씩 감소하고 0이 되면 패킷이 사라진다.</p><ul><li>일반적으로 값은 256이다. (2^8)</li></ul><p>Protocol은 상위 계층 프로토콜이다.</p><ul><li>이 값을 보고 데이터가 TCP인지 UDP 인지 다른 값인지 확인할 수 있다.</li></ul><p>Header checksum은 전송간에 오류가 있는지 확인한다.</p><h2 id=15-proxy-구조와-원리>15. Proxy 구조와 원리<a hidden class=anchor aria-hidden=true href=#15-proxy-구조와-원리>#</a></h2><p>Proxy는 대리자 역할을 한다.</p><p>&lt;Proxy 미적용></p><pre tabindex=0><code>										    HTTPS TCP/IP
PC1 (1.1.1.1)--------------Internet--------------------SERVER(9.9.9.9)
</code></pre><p>&lt;Proxy 적용></p><pre tabindex=0><code>PC1 (1.1.1.1)                                          SERVER(9.9.9.9)
  |                                                        |
  |                                                        |
Internet                                                   |
  |                                                        |
  | (Proxy)                                                |
PC2 (2.2.2.2)---------------- Internet---------------------|
</code></pre><p>&lt;PC2의 역할></p><pre tabindex=0><code>user mode    |          PC2
============================================
- HTTP       |   Proxy 역할을 하는
-            |       Process
- SSL        |       (Stream)
             |   socket1  socket2
kernel mode  |
============================================
- TCP, UDP   |
- IP         |
             |
H/W          |
============================================
- Ethernet   |
-            |
</code></pre><ol><li>socket1은 외부에서 접속하길 대기하고 있다.</li><li>PC1이 접근</li><li>정보가 들어오면 socket2를 이용해서 9.9.9.9에 접근</li></ol><h2 id=16-proxy의-활용>16. Proxy의 활용<a hidden class=anchor aria-hidden=true href=#16-proxy의-활용>#</a></h2><h3 id=1-우회>1. 우회<a hidden class=anchor aria-hidden=true href=#1-우회>#</a></h3><p>Proxy를 사용하면 SERVER 입장에서 PC2의 아이피를 확인한다.</p><p>그러나 PC2는 PC1의 모든 통신을 감청할 수 있다.</p><h3 id=2-분석>2. 분석<a hidden class=anchor aria-hidden=true href=#2-분석>#</a></h3><p>웹 통신에 SSL을 적용하면 패킷 레벨에서 데이터가 암호화되어 있다.</p><p>때문에 와이어 샤크등 프로그램에서 복호화된 데이터를 확인할 수 없다.</p><p>이때 프록시를 아래와 같이 사용할 수 있다.</p><ul><li>Proxy를 127.0.0.1:8080으로 건다. (내 PC)</li><li>HTTP 요청을 보내면 8080번 포트의 소켓으로 데이터가 지나간다.</li><li>이 평문 데이터를 Stream 레벨에서 확인한다.</li></ul><h2 id=17-tcp-송신수신-원리>17. TCP 송신/수신 원리<a hidden class=anchor aria-hidden=true href=#17-tcp-송신수신-원리>#</a></h2><ol><li>Stream을 Segment로 나눈다.<ul><li>이때 TCP Buffer(Window Size)에 데이터를 저장하고, 일정 크기가 되면 Segment로 나눈다.</li></ul></li><li>Segment를 Packet으로 캡슐화한다.</li><li>Packet을 Frame으로 캡슐화한다.</li><li>Frame을 전달한다.<ul><li>전체를 보내는 것은 아니다. (n개 만큼 보낸다.)</li><li>일반적으로 Frame은 바뀔 수 있다. (Packet은 그대로 이지만)</li></ul></li><li>Frame을 전달받고 Segment로 만든다.</li><li>n개의 Segment를 받으면 TCP Buffer에 저장하고 ackn+1을 송신쪽에 전달한다.<ul><li>ack에는 Window Size가 포함되어 있다.</li></ul></li><li>송신쪽은 ackn+1을 받고 Segment를 n+1번부터 다시 보낸다.<ul><li>이 과정때문에 속도 지연이 발생한다. (UDP 보다 느리다.)</li><li>만약 ack로 받은 수신 측 Window Size가 작으면 Segment를 보내지 않는다.</li></ul></li></ol><h2 id=18-tcp-연결에-대해>18. TCP 연결에 대해<a hidden class=anchor aria-hidden=true href=#18-tcp-연결에-대해>#</a></h2><p>TCP는 연결지향 프로토콜이다.</p><p>우선 아래 TCP 헤더를 보자</p><p><img loading=lazy src=../networkbasic/1.png alt=1.png></p><ul><li>출발지/목적지 Port 번호가 가장위에 위치한다.</li><li>Sequence Number: 32bit → 4GB (2^32), Segment의 순서</li><li>TCP Flags: Ack, Sync<ul><li>3-way handshake에 사용</li></ul></li></ul><p>3-way handshake</p><ul><li>Seq번호와 MSS를 교환하는 행위</li><li>혼잡 제어 정책 교환</li></ul><h2 id=19-unicast-broadcast-multicast>19. Unicast, Broadcast, Multicast<a hidden class=anchor aria-hidden=true href=#19-unicast-broadcast-multicast>#</a></h2><pre tabindex=0><code> NIC  L2 Access   L2 Distribution    L2 Access    NIC
         |  (Up-link)        (Up-link)
         |---------------#---------------|
PC1------|               |               |---------PC3
         |               |               |
         |               |               |
         |               |               |---------PC4
PC2------|               |               |
         |               |               |
                         |
                         | (Up-link)
                         |
                         @ 라우터 (gateway)
                       (방화벽)
</code></pre><p>Unicast</p><ul><li>L2 스위치 내부에서 연결이 끝나는 것 (라우터 이전)</li><li>한번에 한 지점에게만 신호를 보낸다.</li></ul><p>Broadcast</p><ul><li>어떤 지점에서 다수의 지점에 신호를 보내는 것</li><li>네트워크 효율을 떨어뜨린다.</li><li>2진수 IP의 끝자리가 모두 1이다. (210.153.0.255)</li></ul><p>Multicast</p><ul><li>Broadcast와 유사하나 관심이 없는 지점은 신호를 보내지 않음</li><li>Group을 등록해서 Group에 전달함</li></ul><h2 id=20-ip의-종류>20. IP의 종류<a hidden class=anchor aria-hidden=true href=#20-ip의-종류>#</a></h2><p><strong>Global</strong></p><ul><li>인터넷(public, global network)에서 라우터가 라우팅 시켜주는 IP이다.</li></ul><p><strong>Private</strong></p><ul><li>작은 소규모 사설 인터넷을 구축할 때 사용한다.</li><li>공유기에서도 자주 사용한다.<ul><li>공유기는 하나의 Global IP를 Private IP에 공유해주는 역할을 한다.</li></ul></li><li>4개의 클래스로 나뉜다.<ul><li>A:<ul><li>network id: 8bit</li><li>host id: 24bit</li><li>10.xxx.xxx.xxx</li></ul></li><li>B<ul><li>network id: 12bit</li><li>host id: 20bit</li><li>172.16.xxx.xxx</li></ul></li><li>C<ul><li>network id: 16bit</li><li>host id: 16bit</li><li>192.168.xxx.xxx</li></ul></li><li>D<ul><li>multicast를 할 때 사용한다.</li></ul></li></ul></li></ul><p><strong>Loopback</strong></p><ul><li>127.0.0.1</li><li>호스트 자신을 의미한다.</li><li>패킷이 만들어지지만 L2로 가지는 않는다.</li></ul><p><strong>Broadcast</strong></p><ul><li>다수의 지점에 신호를 보낼 때 사용한다.</li></ul><h2 id=21-dns>21. DNS<a hidden class=anchor aria-hidden=true href=#21-dns>#</a></h2><p>Domain Name</p><ul><li>숫자로된 IP를 사람이 보기 편하도록 해준다.</li><li>naver.com</li><li>google.com</li></ul><p>DNS</p><ul><li>IP와 Domain Name을 연결하는 테이블 역할</li><li>DNS는 계층적 구조로 되어 있다. (분산형 DB 구조)<ul><li>가장 상위 DNS인 root DNS는 전세계에 13대가 있다.</li></ul></li></ul><p>Domain Name으로 IP를 찾는 과정</p><ol><li>컴퓨터 캐시에서 검색</li><li>host file에서 검색</li><li>DNS에서 검색</li><li>root DNS에서 .com, co.kr 등을 관리하는 DNS 목록을 검색</li><li>DNS 목록에서 검색</li><li>…</li></ol><h2 id=22-tcpip-통신과-mac-주소>22. TCP/IP 통신과 MAC 주소<a hidden class=anchor aria-hidden=true href=#22-tcpip-통신과-mac-주소>#</a></h2><p>TCP/IP 통신을 할 때의 MAC 주소의 변화</p><ol><li>패킷이 프레임으로 캡슐화된다.<ul><li>프레임 헤더에도 시작/목적 지점이 있다.</li></ul></li><li>L2 구간(라우터)을 지나면 프레임 헤더가 새로 교체된다.<ul><li>L2구간에 새로 접근할 때마다 프레임 헤더의 시작/목적 지점도 계속해서 변경된다.</li><li>MAC 주소만 고려하고, IP 주소는 고려하지 않는다.</li></ul></li></ol><h2 id=23-mtu와-packet-단편화>23. MTU와 Packet 단편화<a hidden class=anchor aria-hidden=true href=#23-mtu와-packet-단편화>#</a></h2><p><img loading=lazy src=../networkbasic/2.png alt=2.png></p><ul><li>위 그림에서 2번째 줄(Identification, Fragment Offset)이 단편화 관련 부분이다.</li><li>MTU는 1500이 기본값인 경우가 많다.</li><li>MTU - 20(IP 헤더) - 20(TCP 헤더) = MSS이다.</li></ul><p>아래와 같은 경우에는 단편화가 어떻게 이루어 질까?</p><pre tabindex=0><code>MTU:1500     MTU:1500       MTU:1400       MTU:1500  MTU:1500
PC1 ---|---#-----R1-------------R2-------------R3-----SERVER
</code></pre><ul><li>위 경우 R1 → R2에서 단편화가 이루어져야 한다.<ol><li>1500짜리 패킷을 어느 지점에서 자른다. A와 B가 생긴다.</li><li>헤더와 A를 붙이고, 헤더와 B를 붙여서 2개의 패킷을 만든다.<ul><li>이때 두 패킷 헤더의 Idenfication이 같은 값이 된다.</li><li>Fragment Offset 값은 A는 0, B는 A의 길이만큼이 된다.</li></ul></li><li>수신하는 쪽에서 단편화를 조립한다. (SERVER)</li></ol></li></ul><h2 id=24-서브넷팅>24. 서브넷팅<a hidden class=anchor aria-hidden=true href=#24-서브넷팅>#</a></h2><p>ISP(Internet Service Provider)에게 어떤 회사가 100개의 사설 IP를 요청하면 어떻게 될까?</p><ul><li>C레벨(Net ID: 24, Host ID: 8)인 private IP를 할당한다.</li><li>그런데 C레벨 private IP를 할당하면 2^8 - 100 = 146개의 IP를 낭비하게 되는 것이다.</li><li>이런 경우 서브넷팅을 사용할 수 있다.</li></ul><p>서브넷팅은 Net ID에 몇 개의 비트를 더 할당하는 것이다.</p><ul><li>192.168.0.1/25라면 마지막 4번째 자리의 1의 가장 앞부분 비트를 Net ID로 할당 시킨다.<ul><li>(192.168.0.0)0000001</li><li>(192.168.0.1)0000001</li></ul></li><li>하지만 Host ID가 0인 경우는 아무것도 가리키지 않고, 2진수에서 모두 1인 경우는 broadcast IP 이므로 서브넷 하나마다 2개의 IP를 손실보게 된다.<ul><li>예를 들어 이 경우라면 192.168.0.1/25</li><li>192.168.0.00000000, 192.168.0.01111111</li><li>192.168.0.10000000, 192.168.0.11111111</li><li>위 4가지 IP를 손실보게 된다.</li></ul></li></ul><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><ul><li><a href="https://www.youtube.com/watch?v=k1gyh9BlOT8&amp;list=PLXvgR_grOs1BFH-TuqFsfHqbh-gpMbFoy">https://www.youtube.com/watch?v=k1gyh9BlOT8&amp;list=PLXvgR_grOs1BFH-TuqFsfHqbh-gpMbFoy</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://jo-minjun.github.io/tags/network/>Network</a></li></ul><nav class=paginav><a class=prev href=https://jo-minjun.github.io/notes/msa-stack-quick-peek/><span class=title>« Prev</span><br><span>MSA 개발 스택 빠르게 훑어보기</span></a>
<a class=next href=https://jo-minjun.github.io/notes/avro-schema/><span class=title>Next »</span><br><span>Avro schema</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 네트워크 기초 지식 on twitter" href="https://twitter.com/intent/tweet/?text=%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac%20%ea%b8%b0%ec%b4%88%20%ec%a7%80%ec%8b%9d&amp;url=https%3a%2f%2fjo-minjun.github.io%2fnotes%2fnetworkbasic%2f&amp;hashtags=Network"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 네트워크 기초 지식 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fjo-minjun.github.io%2fnotes%2fnetworkbasic%2f&amp;title=%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac%20%ea%b8%b0%ec%b4%88%20%ec%a7%80%ec%8b%9d&amp;summary=%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac%20%ea%b8%b0%ec%b4%88%20%ec%a7%80%ec%8b%9d&amp;source=https%3a%2f%2fjo-minjun.github.io%2fnotes%2fnetworkbasic%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 네트워크 기초 지식 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fjo-minjun.github.io%2fnotes%2fnetworkbasic%2f&title=%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac%20%ea%b8%b0%ec%b4%88%20%ec%a7%80%ec%8b%9d"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 네트워크 기초 지식 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjo-minjun.github.io%2fnotes%2fnetworkbasic%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 네트워크 기초 지식 on whatsapp" href="https://api.whatsapp.com/send?text=%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac%20%ea%b8%b0%ec%b4%88%20%ec%a7%80%ec%8b%9d%20-%20https%3a%2f%2fjo-minjun.github.io%2fnotes%2fnetworkbasic%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 네트워크 기초 지식 on telegram" href="https://telegram.me/share/url?text=%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac%20%ea%b8%b0%ec%b4%88%20%ec%a7%80%ec%8b%9d&amp;url=https%3a%2f%2fjo-minjun.github.io%2fnotes%2fnetworkbasic%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><div><script src=https://utteranc.es/client.js repo=jo-minjun/my-blog issue-term=pathname label=comment theme=photon-dark crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://jo-minjun.github.io>minjun's memory</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>