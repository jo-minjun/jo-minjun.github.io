<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>DevOps on minjun's blog</title><link>https://jo-minjun.github.io/categories/devops/</link><description>Recent content in DevOps on minjun's blog</description><image><title>minjun's blog</title><url>https://jo-minjun.github.io/logo.png</url><link>https://jo-minjun.github.io/logo.png</link></image><generator>Hugo -- gohugo.io</generator><language>kr</language><lastBuildDate>Wed, 11 Jan 2023 23:51:30 +0900</lastBuildDate><atom:link href="https://jo-minjun.github.io/categories/devops/index.xml" rel="self" type="application/rss+xml"/><item><title>Kubernetes: pod와 service</title><link>https://jo-minjun.github.io/notes/kubernetes-pod-service/</link><pubDate>Wed, 11 Jan 2023 23:51:30 +0900</pubDate><guid>https://jo-minjun.github.io/notes/kubernetes-pod-service/</guid><description>Pod container Pod에는 container가 여러개 있을 수 있으며, localhost로 접근할 수 있다. Pod가 생성될 때는 IP가 할당되며, 이 IP를 통해 Pod에 접근할 수 있다. 쿠버네티스 클러스터 내에서만 IP로 접근 가능하다. Pod가 재생성되면 IP 주소가 바뀐다. apiVersion: v1 # 하나의 Pod kind: Pod metadata: name: pod-1 spec: # 여러 개의 container containers: - name: container1 image: image1 ports: - containerPort: 8000 - name: container2 image: image2 ports: - containerPort: 8080 label Pod 뿐만 아니라 다른 오브젝트에도 사용할 수 있지만, Pod에서 가장 많이 사용된다.</description><content:encoded><![CDATA[<h2 id="pod">Pod</h2>
<h3 id="container">container</h3>
<ul>
<li>Pod에는 container가 여러개 있을 수 있으며, localhost로 접근할 수 있다.</li>
<li>Pod가 생성될 때는 IP가 할당되며, 이 IP를 통해 Pod에 접근할 수 있다.
<ul>
<li>쿠버네티스 클러스터 내에서만 IP로 접근 가능하다.</li>
</ul>
</li>
<li>Pod가 재생성되면 IP 주소가 바뀐다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 하나의 Pod</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Pod</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">name</span>: <span style="color:#ae81ff">pod-1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># 여러 개의 container</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">containers</span>:
</span></span><span style="display:flex;"><span>		- <span style="color:#f92672">name</span>: <span style="color:#ae81ff">container1</span>
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">image</span>: <span style="color:#ae81ff">image1</span>
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>			- <span style="color:#f92672">containerPort</span>: <span style="color:#ae81ff">8000</span>
</span></span><span style="display:flex;"><span>		- <span style="color:#f92672">name</span>: <span style="color:#ae81ff">container2</span>
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">image</span>: <span style="color:#ae81ff">image2</span>
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>			- <span style="color:#f92672">containerPort</span>: <span style="color:#ae81ff">8080</span>
</span></span></code></pre></div><h3 id="label">label</h3>
<ul>
<li>Pod 뿐만 아니라 다른 오브젝트에도 사용할 수 있지만, Pod에서 가장 많이 사용된다.</li>
<li>목적에 따라 오브젝트를 분류하고 분류된 오브젝트만 연결하기 위해서 사용한다.</li>
<li>key:value</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Pod1                      Pod2                      Pod3
</span></span><span style="display:flex;"><span>type:web                  type:db                   type:server
</span></span><span style="display:flex;"><span>env:dev                   env:dev                   env:dev
</span></span><span style="display:flex;"><span><span style="color:#f92672">================================================================</span>
</span></span><span style="display:flex;"><span>Pod4                      Pod5                      Pod6
</span></span><span style="display:flex;"><span>type:web                  type:db                   type:server
</span></span><span style="display:flex;"><span>env:prod                  env:prod                  env:prod
</span></span></code></pre></div><ul>
<li>위와 같은 dev/prod 환경에서 web/db/server 종류가 있는 경우
<ul>
<li>웹 개발자가 web만 보고 싶다면 type:web label인 Pod만 서비스에 연결해서 확인하면 된다.</li>
<li>prod환경 운영자는 env:prod label인 Pod만 서비스에 연결해서 확인하면 된다.</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e"># Pod 생성</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Pod</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">name</span>: <span style="color:#ae81ff">pod-2</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">type</span>: <span style="color:#ae81ff">db</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">env</span>: <span style="color:#ae81ff">dev</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">containers</span>:
</span></span><span style="display:flex;"><span>		- <span style="color:#f92672">name</span>: <span style="color:#ae81ff">container</span>
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">image</span>: <span style="color:#ae81ff">image</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e"># Service 생성</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Service</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">name</span>: <span style="color:#ae81ff">svc-1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">selector</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">type</span>: <span style="color:#ae81ff">web</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">-port</span>: <span style="color:#ae81ff">8080</span>
</span></span></code></pre></div><h3 id="node-scheduler">node scheduler</h3>
<ul>
<li>Pod는 Node들 중 하나에 올라가야 한다.</li>
<li>수동으로 지정하는 방법과 자동으로 지정되는 방법이 있다.</li>
<li>수동
<ul>
<li>Node를 생성할 때 label을 설정하고 Pod를 만들 때 Node를 선택한다.</li>
<li><strong>NodeSelector</strong>, NodeAffinity, Pod Affinity, Anti-Affinity, Toleration, Taint…</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Pod</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">name</span>: <span style="color:#ae81ff">pod-3</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">nodeSelector</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">hostname</span>: <span style="color:#ae81ff">node1</span> <span style="color:#75715e"># node에 지정한 label의 key, value</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">containers</span>:
</span></span><span style="display:flex;"><span>		- <span style="color:#f92672">name</span>: <span style="color:#ae81ff">container</span>
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">image</span>: <span style="color:#ae81ff">image</span>
</span></span></code></pre></div></li>
<li>자동
<ul>
<li>Pod가 요구하는 리소스 할당량과 각 Node의 리소스 할당 가능량을 계산해서 scheduler가 선택한다.</li>
</ul>
</li>
</ul>
<h2 id="service">Service</h2>
<ul>
<li>Service는 자신의 IP를 가지고 있다.</li>
<li>Service를 Pod에 연결해 놓으면 Service의 IP를 가지고 Pod에 접근할 수 있다.
<ul>
<li>Pod의 IP를 가지고 접근할 수도 있지만, Pod의 IP는 변경될 수 있다.</li>
</ul>
</li>
</ul>
<h3 id="clusterip">ClusterIP</h3>
<ul>
<li>가장 기본적인 Service이다.</li>
<li>클러스터 내에서만 접근이 가능한 IP이다.
<ul>
<li>클러스터 내의 오브젝트에서는 접근 가능하지만 외부에서는 접근할 수 없다.</li>
</ul>
</li>
<li>하나의 Pod 뿐만아니라 여러개의 Pod를 연결할 수 있다.
<ul>
<li>요청이 오면 여러개의 Pod로 분산도 해준다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Service</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">name</span>: <span style="color:#ae81ff">svc-1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># label을 이용해서 Pod 연결</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">selector</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">app</span>: <span style="color:#ae81ff">pod</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># 9000번 포트로 요청이 들어오면 8080번 포트로 연결이도 된다.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>		- <span style="color:#f92672">port</span>: <span style="color:#ae81ff">9000</span>
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">targetPort</span>: <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">type</span>: <span style="color:#ae81ff">ClusterIP</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Pod</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">name</span>: <span style="color:#ae81ff">pod-1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">app</span>: <span style="color:#ae81ff">pod</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">containers</span>:
</span></span><span style="display:flex;"><span>		- <span style="color:#f92672">name</span>: <span style="color:#ae81ff">container</span>
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">image</span>: <span style="color:#ae81ff">tmkube:app</span>
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>				<span style="color:#f92672">-containerPort</span>: <span style="color:#ae81ff">8080</span>
</span></span></code></pre></div></li>
</ul>
<h3 id="nodeport">NodePort</h3>
<ul>
<li>Service에 IP가 포함되어 있어 ClusterIP와 같은 기능이 포함되어 있다.</li>
<li>클러스터 내부 모든 Node에 포트를 할당하여 Node의 IP로 접근을 하면 Service로 트래픽이 전달된다.
<ul>
<li>Service는 다시 자신에게 연결된 Pod로 트래픽을 전달한다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Service</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">name</span>: <span style="color:#ae81ff">svc-2</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">selector</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">app</span>: <span style="color:#ae81ff">pod</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>		- <span style="color:#f92672">port</span>: <span style="color:#ae81ff">9000</span>
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">targetPort</span>: <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">nodePort</span>: <span style="color:#ae81ff">30000</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">type</span>: <span style="color:#ae81ff">NodePort</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># 이 옵션을 사용하면 Service가 요청이 들어온 Node의 Pod로 트래픽을 전달한다.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">externalTrafficPolicy</span>: <span style="color:#ae81ff">local</span>
</span></span></code></pre></div></li>
</ul>
<h3 id="load-balancer">Load Balancer</h3>
<ul>
<li>NodePort의 특징을 포함하고 있다.</li>
<li>Load Balancer라는 오브젝트가 생성되어 각 Node에 트래픽을 분산 시킨다.</li>
<li>외부에서 Load Balancer에 접근하기 위한 IP는 기본적으로 설정되어 있지 않다.
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Service</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">name</span>: <span style="color:#ae81ff">svc-3</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">selector</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">app</span>: <span style="color:#ae81ff">pod</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>		- <span style="color:#f92672">port</span>: <span style="color:#ae81ff">9000</span>
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">targetPort</span>: <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">nodePort</span>: <span style="color:#ae81ff">30000</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">type</span>: <span style="color:#ae81ff">LoadBalancer</span>
</span></span></code></pre></div></li>
</ul>
<h3 id="externalname">ExternalName</h3>
<ul>
<li>클러스터 외부 서비스에 접근하기 위해 사용하는 서비스이다.</li>
</ul>
]]></content:encoded></item><item><title>Introduce Kubernetes</title><link>https://jo-minjun.github.io/notes/introduce-kubernetes/</link><pubDate>Tue, 10 Jan 2023 21:51:30 +0900</pubDate><guid>https://jo-minjun.github.io/notes/introduce-kubernetes/</guid><description>What, Why Kubernetes? What 쿠버네티스는 컨테이너들을 운영, 관리하는 컨테이너 오케스트레이터이다. 컨테이너 오케스트레이터는 개별 컨테이너의 배포, 관리, 확장, 네트워킹을 자동화해준다. Why 물리 서버에서 동작하는 서비스는 리소스 관리를 효율적으로 할 수 없다. 3개의 서비스에 트래픽이 몰리는 시간대가 다르다. 각 서비스는 최소 트래픽 때 0.5대, 최대 트래픽 때 3개의 서버가 사용된다. 이 경우 총 9대의 서버가 사용된다. 배포시에도 비효율적이다. 중단이 가능한 경우 모든 서비스를 내린 후, 업데이트하여 다시 올린다. 중단이 불가능하면 서비스를 하나씩 내리고 하나씩 업데이트하여 다시 올린다.</description><content:encoded><![CDATA[<h2 id="what-why-kubernetes">What, Why Kubernetes?</h2>
<h3 id="what">What</h3>
<ul>
<li>쿠버네티스는 컨테이너들을 운영, 관리하는 <strong>컨테이너 오케스트레이터</strong>이다.</li>
<li>컨테이너 오케스트레이터는 개별 컨테이너의 배포, 관리, 확장, 네트워킹을 자동화해준다.</li>
</ul>
<h3 id="why">Why</h3>
<ul>
<li>물리 서버에서 동작하는 서비스는 리소스 관리를 효율적으로 할 수 없다.
<ul>
<li>3개의 서비스에 트래픽이 몰리는 시간대가 다르다.</li>
<li>각 서비스는 최소 트래픽 때 0.5대, 최대 트래픽 때 3개의 서버가 사용된다.</li>
<li>이 경우 총 9대의 서버가 사용된다.</li>
</ul>
</li>
<li>배포시에도 비효율적이다.
<ul>
<li>중단이 가능한 경우 모든 서비스를 내린 후, 업데이트하여 다시 올린다.</li>
<li>중단이 불가능하면 서비스를 하나씩 내리고 하나씩 업데이트하여 다시 올린다.</li>
</ul>
</li>
</ul>
<p>→ 쿠버네티스를 사용하면 리소스 관리를 효율적으로 할 수 있다.</p>
<ul>
<li>시간대 별로 평균 서버 필요량을 예측하여 다음과 같은 운용이 가능하다.
<ul>
<li>평균 4개의 서버</li>
<li>A서비스에 트래픽이 몰리는 경우 3개 서버에 A서비스 할당, 1개 서버에 B, C 서비스 할당</li>
</ul>
</li>
<li>서버에 장애가 발생한 경우에 유연하게 대처할 수 있다.
<ul>
<li>쿠버네티스에는 Auto Healing 기능이 있다.</li>
<li>여분의 서버 1개가 있는 경우 자동으로 여분 서버에 서비스를 옮긴다.</li>
</ul>
</li>
<li>배포할 때는 Deployment Object를 통해서 자동화 해준다.</li>
</ul>
<p>→ 서버가 효율적인 개수를 유지하고 자동화 됨으로써 유지보수 비용이 감소한다.</p>
<h2 id="overview">Overview</h2>
<p><img loading="lazy" src="/images/notes/introduce-kubernetes/1.png" alt="1"  />
</p>
<ul>
<li>서버 한대는 Master, 나머지 서버는 Node가 된다.</li>
</ul>
<p>→ 이것이 연결되어 하나의 쿠버네티스 클러스터가 된다.</p>
<ul>
<li>Master는 쿠버네티스의 기능을 컨트롤하고 Node는 리소스를 제공한다.
<ul>
<li>클러스터의 리소스를 늘리고 싶다면 Node를 추가하면 된다.</li>
</ul>
</li>
<li>namespace를 이용해서 쿠버네티스 오브젝트를 독립된 공간으로 분리시켜준다.</li>
<li>namespace에는 쿠버네티스 최소 배포 단위인 Pod가 있고, Pod에 IP를 할당되도록 연결되는 Service가 있다.
<ul>
<li>Service는 다른 namespace와는 연결될 수 없다.</li>
</ul>
</li>
<li>Pod에는 여러 Container가 있을 수 있다. 또한 Volume을 마운트해서 Pod의 데이터가 증발되지 않도록 한다.</li>
<li>namespace에는 ResourceQuota와 LimitRange를 설정해서 namespace의 리소스의 양을 제한시킬 수 있다.</li>
<li>ConfigMap과 Secret으로 Pod의 컨테이너에 환경변수를 설정할 수 있게 한다.</li>
<li>여러가지 컨트롤러는 Pod들을 관리한다.</li>
<li>Replication Controller, ReplicaSet은 Pod가 죽으면 다시 구동시키거나 스케일 인/아웃을 해준다.</li>
<li>Deployment는 배포 후에 Pod를 새 버전으로 업그레이드하고, 문제가 생기면 롤백 해준다.</li>
<li>DaemonSet은 한 Node에 하나의 Pod만 사용되도록 해준다.</li>
<li>CronJob은 특정 Job을 주기적으로 수행되도록 해준다.
<ul>
<li>Job은 특정 작업만 하고 종료되는 것이다.</li>
</ul>
</li>
</ul>
<h2 id="components">Components</h2>
<p><img loading="lazy" src="/images/notes/introduce-kubernetes/2.png" alt="2"  />
</p>
<ul>
<li>master 노드
<ul>
<li>kube-apiserver</li>
<li>etcd</li>
<li>kube-scheduler</li>
<li>kube-controller-manager</li>
</ul>
</li>
<li>worker 노드
<ul>
<li>kubelet</li>
<li>kube-proxy</li>
</ul>
</li>
</ul>
<h3 id="kube-apiserver">kube-apiserver</h3>
<ul>
<li>쿠버네티스 클러스터의 API를 사용할 수 있게 해준다.</li>
<li>kubectl과 같은 클라이언트로부터 요청 받아낸다.</li>
</ul>
<h3 id="etcd">etcd</h3>
<ul>
<li>key-value 형식의 데이터 저장소이다.</li>
</ul>
<h3 id="kube-scheduler">kube-scheduler</h3>
<ul>
<li>Node들의 리소스 상태와 kube-apiserver를 확인하면서, Pod에 Node 정보를 할당한다.</li>
</ul>
<h3 id="kube-controller-manager">kube-controller-manager</h3>
<ul>
<li>Controller들을 실행한다.</li>
</ul>
<h3 id="kubelet">kubelet</h3>
<ul>
<li>kube-apiserver를 확인하면서 Pod에 자신의 Node 정보가 할당된 것이 있으면 Pod를 생성한다.
<ul>
<li>컨테이너를 생성하고 kube-proxy에 네트워크 생성 요청을 한다.</li>
</ul>
</li>
</ul>
<h3 id="kube-proxy">kube-proxy</h3>
<ul>
<li>네트워크 규칙을 관리하고 컨테이너가 네트워크를 사용할 수 있도록 한다.</li>
</ul>
<h2 id="실습-환경-구축">실습 환경 구축</h2>
<ul>
<li>강의에서 소개된 환경이 아닌 minikube를 사용한다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>minikube start <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  --driver<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;docker&#39;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  --kubernetes-version<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;stable&#39;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  --nodes<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 실습을 위해 dashboard 사용</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 실제 업무에서는 secret 등의 값 노출을 막기위해 dashboard를 잘 사용하지 않는다.</span>
</span></span><span style="display:flex;"><span>minikube dashboard
</span></span></code></pre></div><ul>
<li>위와 같은 방법으로 master 1개, worker node 2개를 구축하고 dashboard를 사용할 수 있다.</li>
</ul>
]]></content:encoded></item><item><title>kubectl command</title><link>https://jo-minjun.github.io/notes/kubectl-command/</link><pubDate>Mon, 09 Jan 2023 23:51:30 +0900</pubDate><guid>https://jo-minjun.github.io/notes/kubectl-command/</guid><description>kubectl command 쿠버네티스 API를 사용하는 CLI 도구이다. kubectl [command] [TYPE] [NAME] [flags] [command] 하나 이상의 리소스에서 수행하는 동작을 지정한다. ex) create get describe delete [TYPE] 리소스 타입을 지정한다. 대소문자를 구분하지 않으며 단수형, 복수형, 약어를 지정할 수 있다. ex) pod pods po [NAME] 하나 이상의 리소스의 이름을 지정한다. 대소문자를 구분하며 리소스 이름을 지정하지 않으면 모든 리소스가 대상이 된다. 리소스가 모두 동일한 TYPE인 경우 ex) kubectl get pod name1 name2 리소스 타입을 개별로 지정하는 경우 ex) kubectl get pod/name1 replicaset/name2 [flags] 플래그를 지정한다.</description><content:encoded><![CDATA[<h2 id="kubectl-command">kubectl command</h2>
<ul>
<li>쿠버네티스 API를 사용하는 CLI 도구이다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>kubectl <span style="color:#f92672">[</span>command<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>TYPE<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>NAME<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>flags<span style="color:#f92672">]</span>
</span></span></code></pre></div><ul>
<li>[command]
<ul>
<li>하나 이상의 리소스에서 수행하는 동작을 지정한다.</li>
<li>ex) <code>create</code> <code>get</code> <code>describe</code> <code>delete</code></li>
</ul>
</li>
<li>[TYPE]
<ul>
<li>리소스 타입을 지정한다.</li>
<li>대소문자를 구분하지 않으며 단수형, 복수형, 약어를 지정할 수 있다.</li>
<li>ex) <code>pod</code> <code>pods</code> <code>po</code></li>
</ul>
</li>
<li>[NAME]
<ul>
<li>하나 이상의 리소스의 이름을 지정한다.</li>
<li>대소문자를 구분하며 리소스 이름을 지정하지 않으면 모든 리소스가 대상이 된다.</li>
<li>리소스가 모두 동일한 TYPE인 경우
<ul>
<li>ex) <code>kubectl get pod name1 name2</code></li>
</ul>
</li>
<li>리소스 타입을 개별로 지정하는 경우
<ul>
<li>ex) <code>kubectl get pod/name1 replicaset/name2</code></li>
</ul>
</li>
</ul>
</li>
<li>[flags]
<ul>
<li>플래그를 지정한다.</li>
<li>ex) <code>-A</code></li>
</ul>
</li>
</ul>
<h3 id="주요-명령어">주요 명령어</h3>
<table>
<thead>
<tr>
<th>command</th>
<th>description</th>
<th>example</th>
</tr>
</thead>
<tbody>
<tr>
<td>get</td>
<td>하나 이상의 리소스를 보여준다.</td>
<td>kubectl get pod</td>
</tr>
<tr>
<td>edit</td>
<td>서버의 리소스를 수정한다.</td>
<td>kubectl edit pod name1</td>
</tr>
<tr>
<td>delete</td>
<td>파일 또는 리소스를 삭제한다.</td>
<td>kubectl delete -f file.yaml kubectl delete pod name1</td>
</tr>
<tr>
<td>scale</td>
<td>deployment, replicaset 등의 scale을 조정한다.</td>
<td>kubectl scale replicaset name1 &ndash;replicas=3</td>
</tr>
<tr>
<td>top</td>
<td>CPU/memory 등 리소스 상태를 보여준다.</td>
<td>kubectl top pod kubectl top node</td>
</tr>
<tr>
<td>describe</td>
<td>리소스의 상세 정보를 보여준다.</td>
<td>kubectl describe -l key=value</td>
</tr>
<tr>
<td>logs</td>
<td>pod의 로그를 보여준다.</td>
<td>kubectl logs -f pod_name</td>
</tr>
<tr>
<td>exec</td>
<td>container에 커맨드를 실행시킨다.</td>
<td>kubectl exec -it pod_name &ndash; /bin/bash</td>
</tr>
<tr>
<td>port-forward</td>
<td>pod의 포트로 local 포트를 포워드한다.</td>
<td>kubectl port-forward pod_name 13231:80 kubectl replicaset/replicaset_name 13231:80 kubectl deployment/deployment_name 13231:80</td>
</tr>
<tr>
<td>cp</td>
<td>파일 또는 디렉터리를 복사한다. pod_name을 명시하지 않으면 local로 설정된다.</td>
<td>kubectl cp pod_name:path path</td>
</tr>
<tr>
<td>apply</td>
<td>리소스를 생성하거나 업데이트한다.</td>
<td>kubectl apply -f file.yaml</td>
</tr>
<tr>
<td>config</td>
<td>kubeconfig(~/.kube/config) 파일을 관리한다.</td>
<td>kubectl config view kubectl config use-context dev1</td>
</tr>
</tbody>
</table>
]]></content:encoded></item><item><title>Linux 주요 커맨드와 옵션들</title><link>https://jo-minjun.github.io/notes/linux-command/</link><pubDate>Fri, 06 Jan 2023 00:01:11 +0900</pubDate><guid>https://jo-minjun.github.io/notes/linux-command/</guid><description>Linux 주요 커맨드와 옵션 커맨드 라인 단축키
ctrl + a: 커서를 라인 가장 앞으로 옮긴다. ctrl + e: 커서를 라인 가장 뒤로 옮긴다. ctrl + k: 커서를 기준으로 뒤쪽을 모두 지운다. 유틸리티 piping, redirect
&amp;lt;COMMAND&amp;gt; | &amp;lt;COMMAND&amp;gt; |를 기준으로 앞 커맨드의 표준 출력을 뒷 커맨드의 표준 입력으로 사용한다. curl -s https://apigateway.dev1.meshdev.io/neogeo/management/info | jq &amp;lt;COMMAND&amp;gt; &amp;lt; &amp;lt;FILE&amp;gt; &amp;lt;COMMAND&amp;gt; &amp;gt; &amp;lt;FILE&amp;gt; &amp;lt;COMMAND&amp;gt; 1&amp;gt; &amp;lt;FILE&amp;gt; # 위 명령어와 같다. &amp;lt;COMMAND&amp;gt; 2&amp;gt; &amp;lt;FILE&amp;gt; # 커맨드의 에러 내용을 파일에 덮어 쓴다.</description><content:encoded><![CDATA[<h2 id="linux-주요-커맨드와-옵션">Linux 주요 커맨드와 옵션</h2>
<p><strong>커맨드 라인 단축키</strong></p>
<ul>
<li>ctrl + a: 커서를 라인 가장 앞으로 옮긴다.</li>
<li>ctrl + e: 커서를 라인 가장 뒤로 옮긴다.</li>
<li>ctrl + k: 커서를 기준으로 뒤쪽을 모두 지운다.</li>
</ul>
<h3 id="유틸리티">유틸리티</h3>
<p><strong>piping, redirect</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&lt;COMMAND&gt; | &lt;COMMAND&gt;
</span></span></code></pre></div><ul>
<li><code>|</code>를 기준으로 앞 커맨드의 표준 출력을 뒷 커맨드의 표준 입력으로 사용한다.</li>
<li><code>curl -s https://apigateway.dev1.meshdev.io/neogeo/management/info | jq</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&lt;COMMAND&gt; &lt; &lt;FILE&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>&lt;COMMAND&gt; &gt; &lt;FILE&gt;
</span></span><span style="display:flex;"><span>&lt;COMMAND&gt; 1&gt; &lt;FILE&gt; <span style="color:#75715e"># 위 명령어와 같다.</span>
</span></span><span style="display:flex;"><span>&lt;COMMAND&gt; 2&gt; &lt;FILE&gt; <span style="color:#75715e"># 커맨드의 에러 내용을 파일에 덮어 쓴다.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>&lt;COMMAND&gt; &gt;&gt; &lt;FILE&gt;
</span></span></code></pre></div><ul>
<li><code>&lt;</code>는 뒷 파일의 내용을 커맨드의 입력으로 사용한다.</li>
<li><code>&gt;</code>는 앞 커맨드의 결과를 파일 등에 덮어 쓴다.</li>
<li><code>&gt;&gt;</code>는 앞 커맨드의 결과를 파일 등에 추가한다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cat <span style="color:#e6db74">&lt;&lt; EOT &gt; template.json
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  &#34;tag&#34;: &#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">EOT</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cat template.json
</span></span></code></pre></div><p><strong>grep</strong></p>
<ul>
<li>지정한 패턴이나 문자열에 매칭되는 내용만 출력한다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>grep <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>PATTERN<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>FILE<span style="color:#f92672">]</span>
</span></span></code></pre></div><table>
<thead>
<tr>
<th>-c</th>
<th>패턴이 일치하는 행의 수를 출력한다.</th>
</tr>
</thead>
<tbody>
<tr>
<td>-i</td>
<td>대소문자를 구분하지 않는다.</td>
</tr>
<tr>
<td>-v</td>
<td>패턴이 일치하는 않는 내용만 출력한다.</td>
</tr>
<tr>
<td>-A <!-- raw HTML omitted --></td>
<td>패턴 일치 줄 이후 n개 라인을 출력한다.</td>
</tr>
<tr>
<td>-B <!-- raw HTML omitted --></td>
<td>패턴 일치 줄 이전 n개 라인을 출력한다.</td>
</tr>
</tbody>
</table>
<p><strong>watch</strong></p>
<ul>
<li>COMMAND의 결과를 계속해서 보여준다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>watch <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> &lt;COMMAND&gt;
</span></span></code></pre></div><table>
<thead>
<tr>
<th>-d</th>
<th>변경된 부분을 표시한다.</th>
</tr>
</thead>
<tbody>
<tr>
<td>-n <!-- raw HTML omitted --></td>
<td>m초 주기로 리프레쉬한다.</td>
</tr>
</tbody>
</table>
<p><strong>time</strong></p>
<ul>
<li>특정 명령어 또는 프로그램의 수행 시간을 보여준다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>time &lt;COMMAND&gt;
</span></span></code></pre></div><ul>
<li>real: 총 수행 시간</li>
<li>user: CPU가 사용자 영역에서 보낸 시간</li>
<li>sys: CPU가 커널 영역에서 보낸 시간</li>
</ul>
<p><strong>xargs</strong></p>
<ul>
<li>앞 커맨드의 수행 결과를 뒤 커맨드의 인자로 넘긴다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&lt;COMMAND&gt; | xargs &lt;COMMAND&gt;
</span></span></code></pre></div><ul>
<li>아무 커맨드를 입력하지 않으면 <code>echo</code>가 수행된다.</li>
</ul>
<h3 id="파일dir">파일/DIR</h3>
<p><strong>cat</strong></p>
<ul>
<li>파일 이름을 받아서 내용을 터미널에 출력한다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cat <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> &lt;FILE_NAME&gt;
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cat name <span style="color:#75715e"># name 파일의 내용을 터미널에 출력한다.</span>
</span></span><span style="display:flex;"><span>cat name1 name2 <span style="color:#75715e"># name1, name2 파일의 내용을 터미널에 출력한다.</span>
</span></span></code></pre></div><table>
<thead>
<tr>
<th>-b</th>
<th>줄번호를 출력한다. 비어있는 행은 포함하지 않는다.</th>
</tr>
</thead>
<tbody>
<tr>
<td>-n</td>
<td>줄번호를 출력한다. 비어있는 행을 포함한다.</td>
</tr>
<tr>
<td>-s</td>
<td>2개 이상의 빈 행을 한 행으로 출력한다.</td>
</tr>
</tbody>
</table>
<p><strong>touch</strong></p>
<ul>
<li>파일의 날짜와 시간을 수정하는 명령어다.</li>
<li>빈 파일을 생성하기 위해 자주 사용된다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>touch <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> &lt;FILE_NAME&gt; <span style="color:#75715e"># 파일이 없으면 생성하고, 접근 시간, 상태 변경 시간, 수정 시간을 현재로 변경</span>
</span></span></code></pre></div><p><strong>mkdir</strong></p>
<ul>
<li>디렉토리를 생성한다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>mkdir <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> &lt;DIRECTORY_NAME&gt;
</span></span></code></pre></div><table>
<thead>
<tr>
<th>-m &ndash;mode</th>
<th>권한을 함께 부여한다.</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p &ndash;parent</td>
<td>상위 디렉토리를 같이 생성한다.</td>
</tr>
</tbody>
</table>
<p><strong>rm</strong></p>
<ul>
<li>파일이나 디렉토리를 삭제한다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>rm <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> &lt;FILE_NAME | DIRECTORY_NAME&gt;
</span></span></code></pre></div><table>
<thead>
<tr>
<th>-f &ndash;force</th>
<th>삭제 여부를 묻지 않는다.</th>
</tr>
</thead>
<tbody>
<tr>
<td>-r &ndash;recursive</td>
<td>해당 디렉토리와 해당 디렉토리 하위의 모든 파일과 디렉토리를 삭제한다.</td>
</tr>
</tbody>
</table>
<p><strong>tree</strong></p>
<ul>
<li>디렉토리의 하위 구조를 계층적으로 보여준다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>tree <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> &lt;DIRECTORY_NAME&gt;
</span></span></code></pre></div><table>
<thead>
<tr>
<th>-L <!-- raw HTML omitted --></th>
<th>하위 구조의 레벨을 지정한다. (해당 레벨까지 출력)</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>파일은 제외하고 디렉토리만 출력한다.</td>
</tr>
</tbody>
</table>
<p><strong>echo</strong></p>
<ul>
<li>텍스트를 터미널에 출력한다.</li>
<li>텍스트에 특수문자가 있는 경우 <code>&quot;&lt;text&gt;&quot;</code>로 명시해주어야 한다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>echo <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> &lt;TEXT&gt;
</span></span></code></pre></div><p><strong>sed</strong></p>
<p><a href="https://www.computerhope.com/unix/used.htm">Linux sed command help and examples</a></p>
<ul>
<li>파일을 수정하는 stream editor이다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sed OPTIONS... <span style="color:#f92672">[</span>SCRIPT<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>INPUT_FILE<span style="color:#f92672">]</span>
</span></span></code></pre></div><table>
<thead>
<tr>
<th>-i</th>
<th>결과를 터미널에 출력하지 않고 파일에서 처리한다.</th>
</tr>
</thead>
<tbody>
<tr>
<td>-r</td>
<td>정규식을 사용한다.</td>
</tr>
<tr>
<td>-n</td>
<td>적용 부분만 구분해서 출력한다.</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>&rsquo;s/문자1/문자2/'</th>
<th>문자1을 문자2로 대체한다. (/은 (공백)</th>
<th>. 으로 사용해도 된다.)</th>
</tr>
</thead>
<tbody>
<tr>
<td>&rsquo;n,ms/문자1/문자2/'</td>
<td>n ~ m 번 줄에서 문자1을 문자2로 대체한다.</td>
<td></td>
</tr>
<tr>
<td>&rsquo;n,mp'</td>
<td>n ~ m 번 줄을 출력한다.</td>
<td></td>
</tr>
<tr>
<td>&rsquo;n,md'</td>
<td>n ~ m 번 줄을 지운다.</td>
<td></td>
</tr>
</tbody>
</table>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>gsed <span style="color:#e6db74">&#39;s/&#34;tag&#34;: ./&#34;tag&#34;: &#34;latest&#34;/g&#39;</span> template.json &gt; output.json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cat output.json
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>file: mail
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>billy@example.org
</span></span><span style="display:flex;"><span>tom@example.org
</span></span><span style="display:flex;"><span>jay@example.org
</span></span><span style="display:flex;"><span>root@example.org
</span></span></code></pre></div><ul>
<li>billy와 tom의 example.org만 example.com으로 변경하고 싶은 경우</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>gsed -i -r <span style="color:#e6db74">&#39;s/^(billy|tom)@example.org/\1@example.com/&#39;</span> file
</span></span></code></pre></div><ul>
<li>1~2번 라인만 출력하고 싶은 경우</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>gsed -n <span style="color:#e6db74">&#39;1,2p&#39;</span> file
</span></span></code></pre></div><ul>
<li>1~2번 라인을 지우고 출력하고 싶은 경우</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>gsed <span style="color:#e6db74">&#39;1,2d&#39;</span> file
</span></span></code></pre></div><p><strong>tee</strong></p>
<ul>
<li>입력과 출력을 동시에 한다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>tee <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>FILE<span style="color:#f92672">]</span>
</span></span></code></pre></div><ul>
<li>출력을 redirection할 경우 파일이 root 권한이라면 실패한다.</li>
<li>이 경우 tee를 사용할 수 있다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo echo <span style="color:#e6db74">&#34;TEXT&#34;</span> &gt; ROOT_FILE <span style="color:#75715e"># permission denied</span>
</span></span><span style="display:flex;"><span>sudo echo <span style="color:#e6db74">&#34;TEXT&#34;</span> | tee ROOT_FILE
</span></span></code></pre></div><p><strong>less</strong></p>
<ul>
<li>내용을 터미널에 출력한다.</li>
<li>위 → 아래, 아래 → 위 방향으로 이동할 수 있다.</li>
<li>종료하려면 q를 눌러야 한다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>less file
</span></span></code></pre></div><p><strong>more</strong></p>
<ul>
<li>파일의 내용을 터미널에 출력한다.</li>
<li>위 → 아래 방향으로만 이동 가능하다.</li>
<li>가장 아래로 이동하면 more가 종료된다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>more file
</span></span></code></pre></div><p><strong>ls</strong></p>
<ul>
<li>디렉토리에 있는 파일이나 디렉토리를 출력한다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ls <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>DIRECTORY<span style="color:#f92672">]</span>
</span></span></code></pre></div><table>
<thead>
<tr>
<th>-a</th>
<th>모든 파일과 디렉토리를 보여준다.</th>
</tr>
</thead>
<tbody>
<tr>
<td>-l</td>
<td>사용자의 권한, 소유자, 크기, 날짜 등 디테일 정보를 보여준다.</td>
</tr>
</tbody>
</table>
<p><strong>which</strong></p>
<ul>
<li>특정 명령어의 위치를 출력한다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>which <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> COMMAND
</span></span></code></pre></div><table>
<thead>
<tr>
<th>-n <!-- raw HTML omitted --></th>
<th>옵션은 모든 위치에서의 명령어를 찾는다.</th>
</tr>
</thead>
</table>
<p><strong>head</strong></p>
<ul>
<li>파일의 앞 부분을 출력한다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>head <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> FILE
</span></span></code></pre></div><table>
<thead>
<tr>
<th>-n <!-- raw HTML omitted --></th>
<th>파일의 앞 부분 m줄 만큼 출력한다.</th>
</tr>
</thead>
</table>
<p><strong>tail</strong></p>
<ul>
<li>파일의 끝 부분을 출력한다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>tail <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> FILE
</span></span></code></pre></div><table>
<thead>
<tr>
<th>-n <!-- raw HTML omitted --></th>
<th>파일의 끝 부분 m줄 만큼 출력한다.</th>
</tr>
</thead>
<tbody>
<tr>
<td>-f</td>
<td>파일의 끝부터 10줄을 출력하고, 새로 입력되는 정보를 계속해서 출력한다.</td>
</tr>
<tr>
<td>-F</td>
<td>파일이 변경되어도 계속해서 추적하며 출력한다. (삭제되어도 다시 파일이 생기면 출력)</td>
</tr>
</tbody>
</table>
<p><strong>tar</strong></p>
<ul>
<li>여러개의 파일과 디렉토리를 하나의 파일로 묶거나 해제한다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>tar <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> &lt;TARGET&gt;
</span></span><span style="display:flex;"><span>tar cvf name.tar ./dir <span style="color:#75715e"># tar 생성</span>
</span></span><span style="display:flex;"><span>tar xvf name.tar <span style="color:#75715e"># tar 해제</span>
</span></span></code></pre></div><table>
<thead>
<tr>
<th>c</th>
<th>tar 파일 생성</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>tar 파일 해제</td>
</tr>
<tr>
<td>v</td>
<td>생성 또는 해제 시 파일 리스트 출력</td>
</tr>
<tr>
<td>t</td>
<td>tar에 포함된 내용 확인</td>
</tr>
<tr>
<td>f</td>
<td>파일 이름 지정</td>
</tr>
</tbody>
</table>
<p><strong>gzip / gunzip</strong></p>
<ul>
<li>gzip: 파일을 압축한다.</li>
<li>gunzip: gz파일을 해제한다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>gzip <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> &lt;TARGET&gt;
</span></span></code></pre></div><table>
<thead>
<tr>
<th>-<!-- raw HTML omitted --></th>
<th>n(1 ~ 9)은 압축 속도이다. 압축 속도가 빠르면 압축률이 낮아진다. (1: 빠름, 9: 느림)</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>압축 결과를 출력하고 원본은 유지한다.</td>
</tr>
<tr>
<td>-d</td>
<td>압축을 해제한다.</td>
</tr>
<tr>
<td>-v</td>
<td>압축 시 자세한 정보를 출력한다. (진행률 등)</td>
</tr>
<tr>
<td>-r</td>
<td>디렉토리의 모든 파일을 압축한다.</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>gunzip <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> &lt;TARGET&gt;
</span></span></code></pre></div><table>
<thead>
<tr>
<th>-l</th>
<th>압축 파일 정보를 출력한다.</th>
</tr>
</thead>
<tbody>
<tr>
<td>-v</td>
<td>해제 시 자세한 정보를 출력한다. (진행률 등)</td>
</tr>
<tr>
<td>-r</td>
<td>디렉토리의 모든 파일을 해제한다.</td>
</tr>
</tbody>
</table>
<p><strong>zip / unzip</strong></p>
<ul>
<li>zip: 파일 또는 디렉토리를 압축한다.</li>
<li>unzip: zip 파일을 해제한다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>zip <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> &lt;ZIP_NAME.zip&gt; &lt;TARGET...&gt;
</span></span></code></pre></div><table>
<thead>
<tr>
<th>-<!-- raw HTML omitted --></th>
<th>압축 정도 (0: store only ~ 9: compress better)</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>-e</td>
<td>압축 파일에 암호 적용</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>-s &lt;n(k</td>
<td>m</td>
<td>g</td>
<td>t)&gt;</td>
<td>분할 압축 (k: kilobytes, m: megabytes, g: gigabytes, t: terabytes)</td>
</tr>
<tr>
<td>-q</td>
<td>메시지 출력 제한</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>-r</td>
<td>하위 디렉토리의 파일과 숨겨진 파일을 포함한다.</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>upzip <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> &lt;TARGET&gt;
</span></span></code></pre></div><table>
<thead>
<tr>
<th>-d</th>
<th>특정 디렉토리에 zip을 해제한다.</th>
</tr>
</thead>
</table>
<p><strong>chmod</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>chmod <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> &lt;MODE&gt; &lt;TARGET&gt;
</span></span></code></pre></div><ul>
<li>파일 또는 디렉토리의 권한 등을 변경한다.</li>
</ul>
<table>
<thead>
<tr>
<th>-R</th>
<th>지정한 모드를 하위 디렉토리 및 파일에 전부 적용한다.</th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th>000</th>
<th>모든 사용자가 r/w/x 불가능</th>
</tr>
</thead>
<tbody>
<tr>
<td>440</td>
<td>소유자 및 그룹은 r 가능, 그 외에는 불가능</td>
</tr>
<tr>
<td>664</td>
<td>소유자 및 그룹은 r/w 가능, 그 외에는 r만 가능</td>
</tr>
<tr>
<td>755</td>
<td>소유자는 r/w/x 가능, 그룹 및 그 외에는 r/x만 가능</td>
</tr>
<tr>
<td>777</td>
<td>모든 사용자가 r/w/x 가능</td>
</tr>
</tbody>
</table>
<h3 id="네트워크">네트워크</h3>
<p><strong>curl</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>curl <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> &lt;URL&gt;
</span></span></code></pre></div><ul>
<li>여러 통신 프로토콜을 이용해서 데이터를 전송한다.</li>
</ul>
<table>
<thead>
<tr>
<th>-X <!-- raw HTML omitted --></th>
<th>HTTP METHOD를 지정한다.</th>
</tr>
</thead>
<tbody>
<tr>
<td>-H <!-- raw HTML omitted --></td>
<td>HEADER 값을 지정한다.</td>
</tr>
<tr>
<td>-d <!-- raw HTML omitted --></td>
<td>BODY에 들어갈 값을 지정한다.</td>
</tr>
<tr>
<td>-T <!-- raw HTML omitted --></td>
<td>PUT 방식으로 파일을 업로드 한다.</td>
</tr>
<tr>
<td>-b <!-- raw HTML omitted --></td>
<td>쿠키를 지정한다.</td>
</tr>
<tr>
<td>-s</td>
<td>진행 상태, 에러 메세지 등을 보여주지 않는다.</td>
</tr>
<tr>
<td>-v</td>
<td>헤어 등의 데이터를 추가로 보여준다.</td>
</tr>
</tbody>
</table>
<p><strong>wget</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>wget <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> &lt;URL&gt;
</span></span></code></pre></div><ul>
<li>웹에서 파일 다운로드를 한다.</li>
</ul>
<table>
<thead>
<tr>
<th>-c</th>
<th>중단된 파일 다운로드를 다시 시작한다.</th>
</tr>
</thead>
<tbody>
<tr>
<td>-b</td>
<td>파일 다운로드를 백그라운드로 한다.</td>
</tr>
<tr>
<td>-O <!-- raw HTML omitted --></td>
<td>파일의 이름을 지정한다.</td>
</tr>
</tbody>
</table>
<p><strong>nc</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nc <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>HOST<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>PORT<span style="color:#f92672">]</span>
</span></span></code></pre></div><ul>
<li>TCP 또는 UDP 프로토콜을 사용하는 네트워크 환경에서 데이터를 읽고 쓴다.</li>
<li>일반적으로 서버의 포트 상태를 확인과 접속 가능 여부를 확인하기 위해 사용한다.</li>
</ul>
<table>
<thead>
<tr>
<th>-z</th>
<th>포트 스캔만 진행한다.</th>
</tr>
</thead>
<tbody>
<tr>
<td>-v</td>
<td>더 많은 정보를 출력한다.</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nc -z google.com <span style="color:#ae81ff">80</span>
</span></span></code></pre></div><p><strong>telnet</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>telnet <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>HOST<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>PORT<span style="color:#f92672">]</span>
</span></span></code></pre></div><ul>
<li>원격으로 호스트에 접속한다.</li>
</ul>
<table>
<thead>
<tr>
<th>-l <!-- raw HTML omitted --></th>
<th>접속할 ID를 지정</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>현재 사용자를 ID로 지정</td>
</tr>
</tbody>
</table>
<ul>
<li><code>telnet</code>만 입력하면 LINEMODE로 진입한다.</li>
</ul>
<table>
<thead>
<tr>
<th>?</th>
<th>사용법을 출력한다.</th>
</tr>
</thead>
<tbody>
<tr>
<td>logout</td>
<td>사용자가 로그아웃하며 접속을 해제한다.</td>
</tr>
<tr>
<td>open</td>
<td>지정한 호스트로 연결한다.</td>
</tr>
<tr>
<td>quit</td>
<td>텔넷을 종료한다.</td>
</tr>
<tr>
<td>status</td>
<td>텔넷의 상태를 출력한다.</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
</tbody>
</table>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>telnet google.com <span style="color:#ae81ff">80</span>
</span></span><span style="display:flex;"><span>GET / HTTP/1.1
</span></span></code></pre></div><p><strong>openssl</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># rsa 개인키 생성</span>
</span></span><span style="display:flex;"><span>openssl genrsa <span style="color:#f92672">[</span>-des3<span style="color:#f92672">]</span> -out PRIVATE_KEY_NAME.key <span style="color:#f92672">[</span>BIT_SIZE;1024, 2048<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># rsa 공개키 생성</span>
</span></span><span style="display:flex;"><span>openssl rsa -in PRIVATE_KEY_NAME.key -pubout -out PUBLIC_KEY_NAME.key
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 인증서 생성</span>
</span></span><span style="display:flex;"><span>openssl req -new -key PRIVATE_KEY_NAME.key <span style="color:#f92672">[</span>-days n<span style="color:#f92672">]</span> -out certification.csr
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># HTTPS 통신</span>
</span></span><span style="display:flex;"><span>openssl s_client -connect google.com:443
</span></span></code></pre></div><ul>
<li>SSL/TLS 프로토콜을 이용하기 위한 오픈소스 라이브러리이다.</li>
<li><code># rsa 비밀키 생성</code>
<ul>
<li>공개키 암호화 방식의 개인키를 생성한다.</li>
<li><code>-des3</code> 옵션을 넣으면 des3 대칭키 알고리즘으로 한 번 더 암호화 해준다.
<ul>
<li>비밀키를 추가로 요구한다.</li>
</ul>
</li>
</ul>
</li>
<li><code># rsa 공개키 생성</code>
<ul>
<li>공개키 암호화 방식의 공개키를 생성한다.</li>
</ul>
</li>
<li><code># 인증서 생성</code>
<ul>
<li>개인키로 서명한 인증서를 생성한다.</li>
<li><code>-days</code> 옵션으로 유효한 기간을 설정할 수 있다.</li>
<li>인증서는 공개키와 발급자 정보를 식별하는 정보를 가지고 있다.</li>
<li>이 명령어를 수행하면 몇 가지 정보를 요청한다. (국가, 회사, 이메일 등)</li>
</ul>
</li>
</ul>
<p><strong>ab</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ab <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> &lt;HOST&gt;<span style="color:#f92672">[</span>:PORT<span style="color:#f92672">][</span>/PATH<span style="color:#f92672">]</span>
</span></span></code></pre></div><ul>
<li>아파치가 제공하는 HTTP 서버 성능 검증 도구이다.</li>
</ul>
<table>
<thead>
<tr>
<th>-n <!-- raw HTML omitted --></th>
<th>요청의 전체 수, m번 만큼 전체 요청을 수행한다.</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c <!-- raw HTML omitted --></td>
<td>동시에 요청하는 수, n개의 요청을 동시에 한다.</td>
</tr>
<tr>
<td>-H</td>
<td>요청 헤더를 지정한다.</td>
</tr>
<tr>
<td>-C</td>
<td>요청 쿠키를 지정한다.</td>
</tr>
<tr>
<td>-T</td>
<td>요청 Content-type을 지정한다.</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ab -n <span style="color:#ae81ff">10</span> -c <span style="color:#ae81ff">2</span> https://apigateway.dev1.meshdev.io/neogeo/management/info
</span></span></code></pre></div><p><strong>nslookup</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nslookup <span style="color:#f92672">[</span>-type<span style="color:#f92672">=</span>&lt;TYPE&gt;<span style="color:#f92672">]</span> DOMAIN_NAME <span style="color:#f92672">[</span>DNS<span style="color:#f92672">]</span>
</span></span></code></pre></div><ul>
<li>DNS 서버에서 도메인의 정보를 조회한다.</li>
</ul>
<table>
<thead>
<tr>
<th>-type=soa</th>
<th>origin DNS를 조회한다.</th>
</tr>
</thead>
</table>
<p><strong>host</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>host <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> NAME
</span></span></code></pre></div><ul>
<li>DNS 서버에서 도메인의 정보를 조회한다.</li>
</ul>
<p><strong>netstat</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>netstat <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span>
</span></span></code></pre></div><ul>
<li>네트워크 연결상태, 인터페이스 상태 등을 보여준다.</li>
</ul>
<table>
<thead>
<tr>
<th>옵션</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>모든 소켓 확인한다.</td>
</tr>
<tr>
<td>-r</td>
<td>라우팅 테이블 확인한다.</td>
</tr>
<tr>
<td>-n</td>
<td>호스트 이름을 ip 주소로 보여준다.</td>
</tr>
<tr>
<td>-t</td>
<td>TCP 소켓을 확인한다.</td>
</tr>
<tr>
<td>-u</td>
<td>UDP 소켓을 확인한다.</td>
</tr>
<tr>
<td>-p</td>
<td>PID/program name을 확인한다.</td>
</tr>
</tbody>
</table>
<p><strong>traceroute</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>traceroute <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> HOST
</span></span></code></pre></div><ul>
<li>HOST까지 가는 네트워크 경로를 확인해준다.</li>
</ul>
<h3 id="프로세스">프로세스</h3>
<p><strong>top</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>top <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span>
</span></span></code></pre></div><ul>
<li>실시간으로 시스템의 프로세스 상태를 확인한다.</li>
</ul>
<table>
<thead>
<tr>
<th>-b</th>
<th>배치 모드</th>
</tr>
</thead>
<tbody>
<tr>
<td>-n <!-- raw HTML omitted --></td>
<td>m 후에 인터렉션 종료 (top 화면을 나간다.)</td>
</tr>
<tr>
<td>-d <!-- raw HTML omitted --></td>
<td>화면 새로고침 주기</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>shift + p</th>
<th>CPU 사용률 내림차순</th>
</tr>
</thead>
<tbody>
<tr>
<td>shift + m</td>
<td>메모리 사용률 내림차순</td>
</tr>
<tr>
<td>shift + t</td>
<td>프로세스 런타임 내림차순</td>
</tr>
<tr>
<td>k</td>
<td>PID 작성시 kill</td>
</tr>
</tbody>
</table>
<p><strong>ps</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ps <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span>
</span></span></code></pre></div><ul>
<li>현재 실행중인 프로세스의 목록과 상태를 보여준다.</li>
</ul>
<table>
<thead>
<tr>
<th>-A</th>
<th>모든 프로세스를 출력한다.</th>
</tr>
</thead>
<tbody>
<tr>
<td>-f</td>
<td>풀 포맷으로 보여준다. (UID, PPID 등)</td>
</tr>
<tr>
<td>-r</td>
<td>현재 실행 중인 프로세스를 보여준다.</td>
</tr>
<tr>
<td>-e</td>
<td>커널 프로세스를 제외한 모든 프로세스를 출력한다.</td>
</tr>
</tbody>
</table>
<p><strong>kill / pkill</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>kill <span style="color:#f92672">[</span>SIGNAL<span style="color:#f92672">]</span> PID
</span></span></code></pre></div><ul>
<li>PID를 이용해서 프로세스에 signal을 보낸다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>pkill <span style="color:#f92672">[</span>SIGNAL<span style="color:#f92672">]</span> NAME
</span></span></code></pre></div><ul>
<li>프로세스 이름을 이용해서 프로세스에 signal을 보낸다.</li>
</ul>
<table>
<thead>
<tr>
<th>9</th>
<th>SIGKILL</th>
<th>강제 종료 시그널</th>
</tr>
</thead>
<tbody>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>정상 종료 시그널 (termination)</td>
</tr>
</tbody>
</table>
<pre tabindex="0"><code>kill vs terminate
- kill
	- It is more like pressing PC power and reset button.
		It wont save any logs or other data.
- terminate
		- it will store all your data before shutting down
		(write data from RAM to disk, logs, etc)
</code></pre><p><strong>pgrep</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>pgrep <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>PATTERN<span style="color:#f92672">]</span>
</span></span></code></pre></div><ul>
<li>패턴에 일치하는 프로세스 정보를 출력한다.</li>
</ul>
<table>
<thead>
<tr>
<th>-u <!-- raw HTML omitted --></th>
<th>특정 유저가 실행시킨 프로세스를 검색한다. (이름)</th>
</tr>
</thead>
<tbody>
<tr>
<td>-U <!-- raw HTML omitted --></td>
<td>특정 유저가 실행시킨 프로세스를 검색한다. (UID)</td>
</tr>
<tr>
<td>-g</td>
<td>특정 그룹이 실행시킨 프로세스를 검색한다. (이름)</td>
</tr>
<tr>
<td>-G</td>
<td>특정 그룹이 실행시킨 프로세스를 검색한다. (이름)</td>
</tr>
<tr>
<td>-l</td>
<td>프로세스 이름을 같이 출력한다.</td>
</tr>
</tbody>
</table>
]]></content:encoded></item><item><title>Linux 배포판 별 패키지 매니저</title><link>https://jo-minjun.github.io/notes/linux-package-manager/</link><pubDate>Thu, 05 Jan 2023 20:45:12 +0900</pubDate><guid>https://jo-minjun.github.io/notes/linux-package-manager/</guid><description>배포판 별 패키지 매니저 alpine 참고: Working with the Alpine Package Keeper (apk)
apk [&amp;lt;OPTIONS&amp;gt;...] COMMAND [&amp;lt;ARGUMENTS&amp;gt;...] 존재하는 리포지터리(repository)는 다음과 같다. main 공식적으로 지원하는 패키지들 community testing 리포지터리에서 테스트된 패키지들 testing 새롭거나, 손상됐거나, 오래된 테스트가 필요한 패키지들 Updating repository
apk update 리포지터리 인덱스를 업데이트한다. Searching
apk search [&amp;lt;OPTIONS&amp;gt;...] PATTERN... 리포지터리에서 PATTERN을 검색한다. Option Description &amp;ndash;description -d 설명에서 PATTERN을 검색한다. &amp;ndash;exact -e 패키지 이름을 정확하게 매칭시킨다. Installing
apk add [&amp;lt;OPTIONS&amp;gt;...] PACKAGES... 패키지를 설치한다.</description><content:encoded><![CDATA[<h2 id="배포판-별-패키지-매니저">배포판 별 패키지 매니저</h2>
<h3 id="alpine">alpine</h3>
<p>참고: <a href="https://docs.alpinelinux.org/user-handbook/0.1a/Working/apk.html">Working with the Alpine Package Keeper (apk)</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>apk <span style="color:#f92672">[</span>&lt;OPTIONS&gt;...<span style="color:#f92672">]</span> COMMAND <span style="color:#f92672">[</span>&lt;ARGUMENTS&gt;...<span style="color:#f92672">]</span>
</span></span></code></pre></div><ul>
<li>존재하는 리포지터리(repository)는 다음과 같다.
<ul>
<li>main
<ul>
<li>공식적으로 지원하는 패키지들</li>
</ul>
</li>
<li>community
<ul>
<li>testing 리포지터리에서 테스트된 패키지들</li>
</ul>
</li>
<li>testing
<ul>
<li>새롭거나, 손상됐거나, 오래된 테스트가 필요한 패키지들</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Updating repository</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>apk update
</span></span></code></pre></div><ul>
<li>리포지터리 인덱스를 업데이트한다.</li>
</ul>
<p><strong>Searching</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>apk search <span style="color:#f92672">[</span>&lt;OPTIONS&gt;...<span style="color:#f92672">]</span> PATTERN...
</span></span></code></pre></div><ul>
<li>리포지터리에서 PATTERN을 검색한다.</li>
</ul>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>&ndash;description -d</td>
<td>설명에서 PATTERN을 검색한다.</td>
</tr>
<tr>
<td>&ndash;exact -e</td>
<td>패키지 이름을 정확하게 매칭시킨다.</td>
</tr>
</tbody>
</table>
<p><strong>Installing</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>apk add <span style="color:#f92672">[</span>&lt;OPTIONS&gt;...<span style="color:#f92672">]</span> PACKAGES...
</span></span></code></pre></div><ul>
<li>패키지를 설치한다.</li>
<li>이미 존재하면 업그레이드를 시도한다.</li>
</ul>
<p><strong>Upgrading</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>apk upgrade <span style="color:#f92672">[</span>&lt;OPTIONS&gt;...<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>&lt;PACKAGES&gt;...<span style="color:#f92672">]</span>
</span></span></code></pre></div><ul>
<li>설치된 패키지를 업그레이드 한다.</li>
<li>특정 패키지가 명시되지 않으면 설치된 패키지 중 가능한 패키지를 업그레이드 한다.</li>
</ul>
<p><strong>Removing</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>apk del <span style="color:#f92672">[</span>&lt;OPTIONS&gt;...<span style="color:#f92672">]</span> PACKAGES...
</span></span></code></pre></div><ul>
<li>설치된 패키지를 제거한다.</li>
</ul>
<h3 id="centosamazon-linux-2-amazon-linux-2022">centos(Amazon Linux 2, Amazon Linux 2022)</h3>
<p>참고: <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/ch-yum#doc-wrapper">Chapter 9. Yum Red Hat Enterprise Linux 7 | Red Hat Customer Portal</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>yum <span style="color:#f92672">[</span>&lt;OPTIONS&gt;...<span style="color:#f92672">]</span> COMMAND <span style="color:#f92672">[</span>&lt;ARGUMENTS&gt;...<span style="color:#f92672">]</span>
</span></span></code></pre></div><p><strong>Searching</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>yum search PATTERN
</span></span></code></pre></div><ul>
<li>패키지 이름은 모르지만 관련 용어를 알고 있을 때 편리한 패키지 검색 명령어이다.</li>
</ul>
<p><strong>Listing</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>yum list all
</span></span></code></pre></div><ul>
<li>설치 되었거나 설치 가능한 패키지 목록을 보여준다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>yum list installed
</span></span></code></pre></div><ul>
<li>설치된 패키지 목록을 보여준다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>yum list available
</span></span></code></pre></div><ul>
<li>설치 가능한 패키지 목록을 보여준다.</li>
</ul>
<p><strong>Installing</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>yum install PACKAGE
</span></span></code></pre></div><ul>
<li>패키지를 설치한다.</li>
</ul>
<p><strong>Updating packages</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>yum check-update
</span></span></code></pre></div><ul>
<li>설치된 패키지 중 업데이트가 가능한 패키지를 확인한다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>yum update PACKAGE
</span></span></code></pre></div><ul>
<li>한 개 이상 패키지에 대한 업데이트를 진행한다.</li>
<li>패키지를 입력하지 않으면 모든 패키지에 대해 업데이트를 진행한다.</li>
</ul>
<p><strong>Removing</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>yum remove PACKAGE
</span></span></code></pre></div><ul>
<li>패키지를 제거한다.</li>
</ul>
<p><strong>History</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>yum history list
</span></span></code></pre></div><ul>
<li>실행되었던 yum 관련 명령어들을 확인한다.</li>
</ul>
<p><strong>Rollback</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>yum history rollback HISTORY_ID
</span></span></code></pre></div><ul>
<li>history에서 확인한 ID로 해당 명령어를 수행하기 전으로 되돌린다.</li>
</ul>
<h3 id="ubuntudebian">ubuntu(debian)</h3>
<p>참고: <a href="https://manpages.ubuntu.com/manpages/xenial/man8/apt.8.html#description">Ubuntu Manpage: apt - command-line interface</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>apt <span style="color:#f92672">[</span>options<span style="color:#f92672">]</span> command
</span></span></code></pre></div><p><strong>Updating</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>apt update
</span></span></code></pre></div><ul>
<li>리포지터리의 설치 가능한 목록을 업데이트 한다.</li>
</ul>
<p><strong>Listing</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>apt list PATTERN
</span></span></code></pre></div><ul>
<li>패키지 이름으로 목록을 검색해서 보여준다.</li>
<li><code>apt -i list</code> 로 설치된 목록을 확인 할 수 있다.</li>
</ul>
<p><strong>Searching</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>apt search PATTERN
</span></span></code></pre></div><ul>
<li>패키지 설명, 이름 등으로 목록을 검색해서 보여준다.</li>
</ul>
<p><strong>Installing</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>apt install PACKAGE
</span></span></code></pre></div><ul>
<li>패키지를 설치한다.</li>
</ul>
<p><strong>Removing</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>apt remove PACKAGE
</span></span></code></pre></div><ul>
<li>패키지를 제거한다.</li>
</ul>
<p><strong>Upgrading</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>apt upgrade <span style="color:#f92672">[</span>PACKAGE<span style="color:#f92672">]</span>
</span></span></code></pre></div><ul>
<li>설치된 패키지를 업그레이드 한다.</li>
</ul>
]]></content:encoded></item><item><title>Docker 스터디</title><link>https://jo-minjun.github.io/notes/docker-study/</link><pubDate>Wed, 04 Jan 2023 23:51:30 +0900</pubDate><guid>https://jo-minjun.github.io/notes/docker-study/</guid><description>Docker Docker란 애플리케이션 개발, 실행, 공유를 위한 오픈 플랫폼이다. 호스트 시스템과 격리된 환경에서 애플리케이션을 패키징하고 실행할 수 있게 해준다. (컨테이너) 협업 시 각 로컬에 개발환경을 설치하지 않아도 된다. 서버 관리에 편리하다. https://docs.docker.com/get-started/overview/
도커 명령어 크게 4가지 종류의 명령어가 있다. Registry 관련 Image 관련 Container 관련 Compose 관련 명령어의 자세한 옵션과 설명은 아래 문서를 참조
docker
Registry 관련 login
docker login Registry에 로그인한다. logout
docker logout Registry에서 로그아웃한다. search
docker search [OPTIONS] &amp;lt;TERM&amp;gt; Registry에 있는 이미지를 검색한다.</description><content:encoded><![CDATA[<h1 id="docker">Docker</h1>
<h3 id="docker란">Docker란</h3>
<ul>
<li>애플리케이션 개발, 실행, 공유를 위한 오픈 플랫폼이다.</li>
<li>호스트 시스템과 격리된 환경에서 애플리케이션을 패키징하고 실행할 수 있게 해준다. (컨테이너)
<ul>
<li>협업 시 각 로컬에 개발환경을 설치하지 않아도 된다.</li>
<li>서버 관리에 편리하다.</li>
</ul>
</li>
</ul>
<p><img loading="lazy" src="/images/notes/docker-study/1.svg" alt="1"  />
</p>
<p><a href="https://docs.docker.com/get-started/overview/">https://docs.docker.com/get-started/overview/</a></p>
<h2 id="도커-명령어">도커 명령어</h2>
<ul>
<li>크게 4가지 종류의 명령어가 있다.
<ul>
<li>Registry 관련</li>
<li>Image 관련</li>
<li>Container 관련</li>
<li>Compose 관련</li>
</ul>
</li>
</ul>
<p>명령어의 자세한 옵션과 설명은 아래 문서를 참조</p>
<p><a href="https://docs.docker.com/engine/reference/commandline/docker/">docker</a></p>
<h3 id="registry-관련">Registry 관련</h3>
<p><strong>login</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker login
</span></span></code></pre></div><ul>
<li>Registry에 로그인한다.</li>
</ul>
<p><strong>logout</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker logout
</span></span></code></pre></div><ul>
<li>Registry에서 로그아웃한다.</li>
</ul>
<p><strong>search</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker search <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> &lt;TERM&gt;
</span></span></code></pre></div><ul>
<li>Registry에 있는 이미지를 검색한다.</li>
</ul>
<table>
<thead>
<tr>
<th>Option</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>&ndash;filter -f</td>
<td></td>
<td>key=value 포맷으로 검색을 필터링 한다.</td>
</tr>
</tbody>
</table>
<ul>
<li>stars: star의 개수 (int)</li>
<li>is-automated: 자동 빌드 여부 (boolean)</li>
<li>is-official: 공식 여부 (boolean) |
| &ndash;limit | 25 | 검색 결과의 최대 개수 |
| &ndash;no-trunc | | 검색 결과 텍스트를 생략하지 않고 전부 보여준다. |</li>
</ul>
<p><strong>pull</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker pull <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> &lt;IMAGE&gt;
</span></span></code></pre></div><ul>
<li>Registry에서 이미지를 내려 받는다.</li>
<li><!-- raw HTML omitted -->에 사용자 명을 지정하지 않으면 공식 이미지를 내려 받는다.</li>
</ul>
<p><strong>push</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker push <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> &lt;IMAGE&gt;
</span></span></code></pre></div><ul>
<li>이미지를 Registry에 업로드 한다.</li>
</ul>
<h3 id="image-관련">Image 관련</h3>
<p><strong>build</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker image build <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>Dockerfile PATH | URL<span style="color:#f92672">]</span>
</span></span></code></pre></div><ul>
<li>Dockerfile을 이용해서 이미지를 빌드한다.</li>
</ul>
<p><strong>ls</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker image ls <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span>
</span></span></code></pre></div><ul>
<li>이미지 목록를 보여준다.</li>
</ul>
<p><strong>rm</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker image rm <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> &lt;IMAGE&gt; <span style="color:#f92672">[</span>IMAGE...<span style="color:#f92672">]</span>
</span></span></code></pre></div><ul>
<li>하나 또는 하나 이상의 이미지를 제거한다.</li>
</ul>
<table>
<thead>
<tr>
<th>Option</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>&ndash;force -f</td>
<td></td>
<td>이미지를 강제로 제거한다.</td>
</tr>
</tbody>
</table>
<p><strong>tag</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker image tag SOURCE_IMAGE TARGET_IMAGE
</span></span></code></pre></div><ul>
<li>이미지에 태그를 설정한다. (IMAGE_ID에 별칭을 부여한다.)</li>
<li>숫자 및 <code>_</code> <code>-</code> <code>.</code> 으로 이름을 시작할 수 없다.</li>
</ul>
<h3 id="container-관련">Container 관련</h3>
<p><strong>commit</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker container commit <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> CONTAINER
</span></span></code></pre></div><ul>
<li>컨테이너의 변경사항을 이미지로 생성한다.</li>
</ul>
<table>
<thead>
<tr>
<th>Option</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>&ndash;author -a</td>
<td></td>
<td>커밋한 사용자를 작성한다.</td>
</tr>
<tr>
<td>&ndash;message -m</td>
<td></td>
<td>커밋 메시지를 작성한다.</td>
</tr>
</tbody>
</table>
<p><strong>diff</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker container diff CONTAINER
</span></span></code></pre></div><ul>
<li>컨테이너의 변경사항을 확인한다.</li>
<li>A: 추가, C: 변경, D: 삭제</li>
</ul>
<p><strong>exec</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker container exec <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> CONTAINER COMMAND <span style="color:#f92672">[</span>ARG...<span style="color:#f92672">]</span>
</span></span></code></pre></div><ul>
<li><code>docker exec</code> 명령어와 같다.</li>
<li>실행 중인 컨테이너에 명령어를 실행한다.</li>
</ul>
<table>
<thead>
<tr>
<th>Option</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>&ndash;detach -d</td>
<td></td>
<td>명령어를 백그라운드로 실행한다.</td>
</tr>
<tr>
<td>&ndash;interactive -i</td>
<td></td>
<td>표준입력을 유지한다.</td>
</tr>
<tr>
<td>&ndash;tty -t</td>
<td></td>
<td>터미널(pseudo-TTY)을 할당한다.</td>
</tr>
</tbody>
</table>
<p><strong>logs</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker container logs CONTAINER
</span></span></code></pre></div><ul>
<li><code>docker logs</code> 명령어와 같다.</li>
<li>컨테이너의 로그를 보여준다.</li>
</ul>
<table>
<thead>
<tr>
<th>Option</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>&ndash;follow -f</td>
<td></td>
<td>로그를 계속 추적하면서 출력한다.</td>
</tr>
<tr>
<td>&ndash;timestamps -t</td>
<td></td>
<td>시간 데이터를 보여준다.</td>
</tr>
</tbody>
</table>
<p><strong>ls</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker container ls <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span>
</span></span></code></pre></div><ul>
<li>컨테이너 목록을 보여준다.</li>
</ul>
<table>
<thead>
<tr>
<th>Option</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>&ndash;all -a</td>
<td>running container</td>
<td>모든 컨테이너를 보여준다.</td>
</tr>
<tr>
<td>&ndash;size -s</td>
<td></td>
<td>사이즈를 같이 보여준다.</td>
</tr>
</tbody>
</table>
<p><strong>prune</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker container prune
</span></span></code></pre></div><ul>
<li>stop 상태인 모든 컨테이너를 제거한다.</li>
</ul>
<p><strong>rename</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker container rename CONTAINER NEW_NAME
</span></span></code></pre></div><ul>
<li>컨테이너 이름을 변경한다.</li>
</ul>
<p><strong>rm</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker container rm <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> CONTAINER <span style="color:#f92672">[</span>CONTAINER...<span style="color:#f92672">]</span>
</span></span></code></pre></div><ul>
<li>하나 또는 하나 이상 컨테이너를 제거한다.</li>
</ul>
<table>
<thead>
<tr>
<th>Option</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>&ndash;force -f</td>
<td></td>
<td>동작 중인 컨테이너를 강제로 제거한다.</td>
</tr>
</tbody>
</table>
<p><strong>run</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker container run <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> IMAGE <span style="color:#f92672">[</span>COMMAND<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>ARG...<span style="color:#f92672">]</span>
</span></span></code></pre></div><ul>
<li>이미지를 컨테이너로 생성하고 실행한다.</li>
</ul>
<table>
<thead>
<tr>
<th>Option</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>—detach -d</td>
<td></td>
<td>컨테이너의 ID를 출력하고 백그라운드로 실행한다.</td>
</tr>
<tr>
<td>&ndash;interactive -i</td>
<td></td>
<td>표준입력을 유지한다.</td>
</tr>
<tr>
<td>&ndash;tty -t</td>
<td></td>
<td>터미널(pseudo-TTY)을 할당한다.</td>
</tr>
<tr>
<td>&ndash;name</td>
<td>random</td>
<td>컨테이너에 이름을 지정한다.</td>
</tr>
<tr>
<td>&ndash;env -e</td>
<td></td>
<td>환경변수를 설정한다.</td>
</tr>
<tr>
<td>&ndash;publish -p</td>
<td></td>
<td>host(port):container(port) 포맷으로 publish와 bind를 설정한다.</td>
</tr>
<tr>
<td>&ndash;volume -v</td>
<td></td>
<td>볼륨을 마운트 시킨다.</td>
</tr>
<tr>
<td>&ndash;rm</td>
<td></td>
<td>종료되면 해당 컨테이너를 삭제한다.</td>
</tr>
</tbody>
</table>
<p><strong>start, restart</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker container start <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> CONTAINER <span style="color:#f92672">[</span>CONTAINER...<span style="color:#f92672">]</span>
</span></span></code></pre></div><ul>
<li>하나 또는 하나 이상의 컨테이너를 시작한다.</li>
<li>이미 실행 중인 컨테이너를 다시 시작하려면 <code>restart</code>를 사용한다.</li>
</ul>
<p><strong>stop</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker container stop <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> CONTAINER <span style="color:#f92672">[</span>CONTAINER...<span style="color:#f92672">]</span>
</span></span></code></pre></div><ul>
<li>하나 또는 하나 이상의 컨테이너를 중지시킨다.</li>
</ul>
<h3 id="compose-관련">Compose 관련</h3>
<p><strong>up</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker compose up
</span></span></code></pre></div><ul>
<li>컴포즈 파일의 컨테이너들을 생성하고 시작한다.</li>
</ul>
<p><strong>down</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker compose down
</span></span></code></pre></div><ul>
<li>컨테이너를 중단하고 제거한다.</li>
</ul>
<table>
<thead>
<tr>
<th>Option</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>&ndash;rmi</td>
<td></td>
<td>서비스에 사용된 이미지를 제거한다.</td>
</tr>
<tr>
<td>&ndash;volumnes -v</td>
<td></td>
<td>이름이 지정된 volume을 제거한다.</td>
</tr>
</tbody>
</table>
<h2 id="dockerfile">Dockerfile</h2>
<ul>
<li>Dockerfile을 이용해서 Docker 이미지를 빌드할 수 있다.</li>
<li><code>docker image build</code> 명령어를 사용해서 Dockerfile에 명시된 command line을 수행하도록 할 수 있다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker image build <span style="color:#f92672">[</span>Dockerfile 경로<span style="color:#f92672">]</span>
</span></span></code></pre></div><p><strong>Format</strong></p>
<ul>
<li>Dockerfile 포맷은 다음과 같다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-docker" data-lang="docker"><span style="display:flex;"><span><span style="color:#75715e"># Comment</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>INSTRUCTION arguments<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><ul>
<li>INSTRUCTION은 대/소문자를 구분하지 않지만, 대문자로 작성하는 것이 컨벤션이다.</li>
<li>Dockerfile은 반드시 <code>FROM</code> INSTRUCTION으로 시작해야 한다.</li>
</ul>
<p><strong>Environment replacement</strong></p>
<ul>
<li>환경변수는 <code>$variable_name</code> 또는 <code>${variable_name}</code> 방식으로 사용할 수 있다.</li>
<li><code>${variable_name}</code> 는 다음과 같은 연산자를 지원한다.
<ul>
<li><code>${variable_name:-word}</code> 는 <code>variable_name</code> 이 정의되어있지 않다면 <code>word</code> 로 대체된다.</li>
<li><code>${variable_name:+word}</code> 는 <code>variable_name</code> 이 정의되어 있다면 <code>word</code> 가 그 값으로 대체되고 정의되어있지 않다면 빈 문자열로 대체된다.</li>
</ul>
</li>
</ul>
<p><strong>FROM</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-docker" data-lang="docker"><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> [--platform=&lt;platform&gt;] &lt;IMAGE&gt; [AS &lt;name&gt;]</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> [--platform=&lt;platform&gt;] &lt;IMAGE&gt;[:&lt;TAG&gt;] [AS &lt;name&gt;]</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> [--platform=&lt;platform&gt;] &lt;IMAGE&gt;[@&lt;DIGEST&gt;] [AS &lt;name&gt;]</span><span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><ul>
<li>생성할 이미지의 베이스 이미지를 설정한다.</li>
<li>멀티 플랫폼 이미지를 참조할 때 <code>--platform</code> 사용하여 플랫폼을 특정할 수 있다.
<ul>
<li>linux/amd64</li>
<li>linux/arm64</li>
<li>windows/amd64</li>
<li>…</li>
</ul>
</li>
<li><!-- raw HTML omitted --> 뒤에 <code>TAG</code>와 <code>DIGEST</code>는 선택적으로 사용한다. 둘 다 생략했다면 <code>TAG</code>로 latest가 사용된다.</li>
<li>AS를 사용해서 빌드 단계에 이름을 줄 수 있다.</li>
</ul>
<p><strong>RUN</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-docker" data-lang="docker"><span style="display:flex;"><span><span style="color:#66d9ef">RUN</span> &lt;command&gt; <span style="color:#75715e"># shell 형식</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;executable&#34;</span>, <span style="color:#e6db74">&#34;param1&#34;</span>, <span style="color:#e6db74">&#34;param2&#34;</span><span style="color:#f92672">]</span> <span style="color:#75715e"># exec 형식</span><span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><ul>
<li>현재 이미지의 새 레이어에서 실행되고 결과를 커밋되고, 커밋된 이미지는 Dockerfile의 다음 스텝에서 사용된다.</li>
<li>RUN 명령어는 두 가지 방식을 따른다.
<ul>
<li>shell 형식
<ul>
<li>내부적으로 shell 명령어를 호출하여 <!-- raw HTML omitted -->를 호출한다.</li>
</ul>
</li>
<li>exec 형식
<ul>
<li>사용자가 executable(<code>/bin/sh</code>, <code>/bin/bash</code>…) 을 명시하여 명령어를 실행할 수 있다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>CMD</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-docker" data-lang="docker"><span style="display:flex;"><span><span style="color:#66d9ef">CMD</span> &lt;command&gt; param1 param2 <span style="color:#75715e"># shell 형식</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">CMD</span> [<span style="color:#e6db74">&#34;executable&#34;</span>, <span style="color:#e6db74">&#34;param1&#34;</span>, <span style="color:#e6db74">&#34;param2&#34;</span>] <span style="color:#75715e"># exec 형식</span><span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><ul>
<li>컨테이너가 실행될 때 수행될 default 명령어를 설정한다.</li>
<li>컨테이너 실행시 override가 가능하다.</li>
<li>CMD는 두 가지 방식을 따른다.
<ul>
<li>shell 형식
<ul>
<li>내부적으로 shell 명령어를 호출하여 <!-- raw HTML omitted -->를 호출한다.</li>
</ul>
</li>
<li>exec 형식
<ul>
<li>사용자가 executable(<code>/bin/sh</code>, <code>/bin/bash</code>…) 을 명시하여 명령어를 실행할 수 있다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>ENTIRYPOINT</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-docker" data-lang="docker"><span style="display:flex;"><span><span style="color:#66d9ef">ENTRYPOINT</span> command param1 param2 <span style="color:#75715e"># shell 형식</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ENTRYPOINT</span> [<span style="color:#e6db74">&#34;executable&#34;</span>, <span style="color:#e6db74">&#34;param1&#34;</span>, <span style="color:#e6db74">&#34;param2&#34;</span>] <span style="color:#75715e">#exec 형식</span><span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><ul>
<li>컨테이너가 실행될 때 가장 먼저 수행되는 명령어를 지정한다.</li>
<li>ENTIRYPOINT 명령어는 두 가지 방식을 따른다.
<ul>
<li>shell 형식
<ul>
<li>내부적으로 shell 명령어를 호출하여 <!-- raw HTML omitted -->를 호출한다.</li>
</ul>
</li>
<li>exec 형식
<ul>
<li>사용자가 executable(<code>/bin/sh</code>, <code>/bin/bash</code>…) 을 명시하여 명령어를 실행할 수 있다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>LABEL</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-docker" data-lang="docker"><span style="display:flex;"><span><span style="color:#66d9ef">LABEL</span> &lt;key&gt;<span style="color:#f92672">=</span>&lt;value&gt; &lt;key&gt;<span style="color:#f92672">=</span>&lt;value&gt; &lt;key&gt;<span style="color:#f92672">=</span>&lt;value&gt; ... <span style="color:#75715e"># 한 줄에 작성</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">LABEL</span> &lt;key&gt;<span style="color:#f92672">=</span>&lt;value&gt; <span style="color:#ae81ff">\ </span><span style="color:#75715e"># 여러 줄에 작성</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>			&lt;key&gt;<span style="color:#f92672">=</span>&lt;value&gt; <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>			&lt;key&gt;<span style="color:#f92672">=</span>&lt;value&gt; <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>			...<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><ul>
<li>키=밸류 방식으로 이미지에 메타데이터를 추가한다.</li>
<li>LABEL은 기본 또는 상위 이미지의 LABEL을 현재 이미지에 상속 받는다.</li>
<li>이미지의 라벨은 <code>docker image inspect</code> 명령어로 확인할 수 있다.</li>
</ul>
<p><strong>EXPOSE</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-docker" data-lang="docker"><span style="display:flex;"><span><span style="color:#66d9ef">EXPOSE</span><span style="color:#e6db74"> &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span><span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><ul>
<li>Docker에게 컨테이너가 런타임에서 어떤 네트워크 포트를 사용할 지 알려준다.</li>
<li>TCP, UDP를 사용할 수 있고, 명시하지 않는다면 TCP가 사용된다.</li>
<li>실제로 포트를 공개하지는 않지만 <code>docker run -P</code> 명령어를 사용하면 호스트의 랜덤 포트가 컨테이너의 EXPOSE로 명시한 포트에 매핑된다.</li>
</ul>
<p><strong>ENV</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-docker" data-lang="docker"><span style="display:flex;"><span><span style="color:#66d9ef">ENV</span> &lt;key&gt; &lt;value&gt;<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ENV</span> &lt;key&gt;<span style="color:#f92672">=</span>&lt;value&gt; ...<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><ul>
<li>환경변수 <!-- raw HTML omitted -->를 <!-- raw HTML omitted -->로 설정한다.</li>
<li>컨테이너 실행 시 <code>docker container run —env</code> 명령어로 변경할 수 있다.</li>
</ul>
<p><strong>ADD</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-docker" data-lang="docker"><span style="display:flex;"><span><span style="color:#66d9ef">ADD</span> <span style="color:#f92672">[</span>--chown<span style="color:#f92672">=</span>&lt;user&gt;;&lt;group&gt;<span style="color:#f92672">]</span> &lt;src&gt;... &lt;dest&gt;<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ADD</span> <span style="color:#f92672">[</span>--chown<span style="color:#f92672">=</span>&lt;user&gt;;&lt;group&gt;<span style="color:#f92672">]</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;&lt;src&gt;&#34;</span>,... <span style="color:#e6db74">&#34;&lt;dest&gt;&#34;</span><span style="color:#f92672">]</span><span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><ul>
<li><!-- raw HTML omitted -->의 파일, 디렉토리, 리모트 파일의 URL을 <!-- raw HTML omitted -->에 추가한다.</li>
<li><code>*</code>과 <code>?</code> 과 같은 패턴을 사용할 수도 있다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-docker" data-lang="docker"><span style="display:flex;"><span><span style="color:#75715e"># hom으로 시작하는 모든 파일 추가</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ADD</span> home* /dir/<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># ?는 단일 문자 대체</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ADD</span> hom?.txt /dir/<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><p><strong>COPY</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-docker" data-lang="docker"><span style="display:flex;"><span><span style="color:#66d9ef">COPY</span> <span style="color:#f92672">[</span>--chown<span style="color:#f92672">=</span>&lt;user&gt;:&lt;group&gt;<span style="color:#f92672">]</span> &lt;src&gt;... &lt;dest&gt;<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> <span style="color:#f92672">[</span>--chown<span style="color:#f92672">=</span>&lt;user&gt;:&lt;group&gt;<span style="color:#f92672">]</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;&lt;src&gt;&#34;</span>,... <span style="color:#e6db74">&#34;&lt;dest&gt;&#34;</span><span style="color:#f92672">]</span><span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><ul>
<li>이미지에 호스트의 파일이나 디렉토리를 복사한다.</li>
<li><code>ADD</code>는 대상이 압축파일인 경우 해체하여 복사하는 등 기능을 제공하지만, COPY는 복사만 수행한다.</li>
</ul>
<p><strong>WORKDIR</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-docker" data-lang="docker"><span style="display:flex;"><span><span style="color:#66d9ef">WORKDIR</span><span style="color:#e6db74"> /path/to/workdir</span><span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><ul>
<li>Dockerfile에서 정의한 명령을 실행하기 위한 디렉토리를 지정하며, 경로가 존재하지 않으면 생성한다.</li>
</ul>
<p><strong>ARG</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-docker" data-lang="docker"><span style="display:flex;"><span><span style="color:#66d9ef">ARG</span> &lt;name&gt;<span style="color:#f92672">[=</span>&lt;default value&gt;<span style="color:#f92672">]</span><span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><ul>
<li>Dockerfile에서 사용할 변수를 정의한다.</li>
<li><code>ENV</code>와 달리 Dockerfile 내부에서만 사용 가능하다.</li>
</ul>
<p><strong>HEALTHCHECK</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-docker" data-lang="docker"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">HEALTHCHECK</span> <span style="color:#f92672">[</span>OPTIONS<span style="color:#f92672">]</span> CMD command <span style="color:#75715e"># 사용할 명령을 지정 (curl 등)</span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">HEALTHCHECK</span> NONE <span style="color:#75715e">#기본 이미지에서 상속된 healthcheck 사용 안함</span><span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><ul>
<li>컨테이너가 잘 동작하는지 확인한다.</li>
<li>옵션은 다음과 같다.</li>
</ul>
<table>
<thead>
<tr>
<th>Option</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>&ndash;interval=n</td>
<td>30s</td>
<td>헬스 체크 간격</td>
</tr>
<tr>
<td>&ndash;timeout=n</td>
<td>30s</td>
<td>헬스 체크 타임아웃 기준</td>
</tr>
<tr>
<td>&ndash;retries=n</td>
<td>3</td>
<td>타임아웃 횟수</td>
</tr>
<tr>
<td>&ndash;start_period=n</td>
<td>0s</td>
<td>컨테이너 실행 후 대기 시간</td>
</tr>
</tbody>
</table>
<h2 id="compose-file">Compose file</h2>
<p><a href="https://docs.docker.com/compose/compose-file/">Compose specification</a></p>
<h3 id="compose-file-versions">Compose file versions</h3>
<table>
<thead>
<tr>
<th>Reference file</th>
<th>What changed in this version</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a> (most current, and recommended)</td>
<td><a href="https://docs.docker.com/compose/compose-file/compose-versioning/#versioning">https://docs.docker.com/compose/compose-file/compose-versioning/#versioning</a></td>
</tr>
<tr>
<td><a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></td>
<td><a href="https://docs.docker.com/compose/compose-file/compose-versioning/#version-3">https://docs.docker.com/compose/compose-file/compose-versioning/#version-3</a></td>
</tr>
<tr>
<td><a href="https://docs.docker.com/compose/compose-file/compose-file-v2/">https://docs.docker.com/compose/compose-file/compose-file-v2/</a></td>
<td><a href="https://docs.docker.com/compose/compose-file/compose-versioning/#version-2">https://docs.docker.com/compose/compose-file/compose-versioning/#version-2</a></td>
</tr>
<tr>
<td>Version 1 (Deprecated)</td>
<td><a href="https://docs.docker.com/compose/compose-file/compose-versioning/#version-1-deprecated">https://docs.docker.com/compose/compose-file/compose-versioning/#version-1-deprecated</a></td>
</tr>
</tbody>
</table>
<h3 id="compose-specification">Compose specification</h3>
<ul>
<li>Compose specification은 도커가 다중 컨테이너 애플리케이션을 정의하기 위해 만든 <strong>새로운 표준 규격</strong>이다.</li>
<li>**YAML(YML)**을 이용해서 다음과 같은 항목을 정의한다.
<ul>
<li>service(필수), network, volume, config, secret</li>
</ul>
</li>
<li>Compose file의 이름은 compose.yaml 또는 docker-compose.yaml을 사용한다.</li>
<li>만약 둘 다 존재하는 경우 Compose spec의 컨벤션인 <strong>compose.yaml을 권장</strong>한다.</li>
</ul>
<h3 id="compose-애플리케이션-모델">Compose 애플리케이션 모델</h3>
<ul>
<li>Compose file은 플랫폼에 의존하지 않는 컨테이너 집합 기반 애플리케이션을 정의한다.</li>
<li><strong>서비스(service)</strong>
<ul>
<li>애플리케이션 컴포넌트를 구성한다.</li>
<li>컨테이너를 실행해서 플랫폼에 구현되는 추상 개념이다.</li>
<li>어떤 서비스는 런타임 또는 플랫폼에 의존적인 **설정(config)**을 필요로 한다.</li>
</ul>
</li>
<li><strong>네트워크(network)</strong>
<ul>
<li>서비스간 통신을 구성한다.</li>
<li>서로 연결된 서비스 컨테이너 간에 IP 라우팅을 위한 플랫폼 기능 추상체이다.</li>
</ul>
</li>
<li><strong>볼륨(volume)</strong>
<ul>
<li>서비스는 볼륨에 데이터를 저장하고 공유한다.</li>
</ul>
</li>
<li>config와 secret을 이용해서 컨테이너에 필요한 정책과 보안을 설정할 수 있다.</li>
</ul>
<h3 id="profile">Profile</h3>
<ul>
<li>프로필을 사용해서 환경에 맞게 Compose 애플리케이션 모델을 조정할 수 있다.</li>
<li><code>services</code>는 요소로 서비스 <code>name</code>을 제공하고 그 하위에 <code>profiles</code> 속성을 제공한다.
<ul>
<li>profiles 속성으로 프로필 목록을 정의한다.</li>
<li>profiles 속성이 설정되지 않은 서비스는 항상 활성화 된다.</li>
<li>특정 서비스를 실행하는 경우 지정한 프로필이 활성화 된다.</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">services</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># 모든 프로필에서 활성화 된다.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">foo</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">image</span>: <span style="color:#ae81ff">foo</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># test 프로필에서 활성화 된다.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">bar</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">image</span>: <span style="color:#ae81ff">bar</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">profiles</span>:
</span></span><span style="display:flex;"><span>			- <span style="color:#ae81ff">test</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># test 및 debug 프로필에서 활성화 된다.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">baz</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">image</span>: <span style="color:#ae81ff">baz</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">depends_on</span>:
</span></span><span style="display:flex;"><span>			- <span style="color:#ae81ff">bar</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">profiles</span>:
</span></span><span style="display:flex;"><span>			- <span style="color:#ae81ff">test</span>
</span></span><span style="display:flex;"><span>			- <span style="color:#ae81ff">debug</span>
</span></span></code></pre></div><h3 id="service의-구성-요소">service의 구성 요소</h3>
<ul>
<li>service의 주요 하위 요소
<ul>
<li><code>build</code> <code>image</code> <code>command</code> <code>container_name</code> <code>depends_on</code> <code>environment</code> <code>expose</code> <code>ports</code> <code>healthcheck</code> <code>volumes</code></li>
</ul>
</li>
<li>다른 구성 요소는 문서를 참고</li>
</ul>
<p><strong>build</strong></p>
<ul>
<li>컨테이너 이미지를 생성하기 위한 빌드 구성을 지정한다.</li>
<li><code>build</code> 요소는 문자열 값을 가지거나 하위 요소를 가질 수 있다.</li>
<li>아래와 같이 build에 문자열 값을 가지면 Dockerfile의 context만 가질 수 있다.
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">services</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">webapp</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">build</span>: <span style="color:#ae81ff">./dir</span>
</span></span></code></pre></div></li>
<li><code>build</code> 요소의 하위 요소는 다음과 같다.
<ul>
<li>context: Dockerfile의 context를 지정한다.</li>
<li>dockerfile: 사용할 Dockerfile의 이름을 지정한다.</li>
<li>args: Dockerfile ARG 값을 정의한다.</li>
<li>…</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">services</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">webapp</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">build</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">context</span>: <span style="color:#ae81ff">./dir</span>
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">dockerfile</span>: <span style="color:#ae81ff">webapp.Dockerfile</span>
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">args</span>:
</span></span><span style="display:flex;"><span>				- <span style="color:#ae81ff">GIT_COMMIT=cdc3b19</span>
</span></span></code></pre></div></li>
</ul>
<p><strong>image</strong></p>
<ul>
<li>컨테이너를 시작할 이미지를 지정한다.</li>
<li><code>[&lt;registry&gt;/][&lt;project&gt;/]&lt;image&gt;[:&lt;tag&gt;|@&lt;digest&gt;]</code> 방식으로 기술해야 한다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">image</span>: <span style="color:#ae81ff">redis</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">image</span>: <span style="color:#ae81ff">redis:5</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">image</span>: <span style="color:#ae81ff">library/redis</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">image</span>: <span style="color:#ae81ff">docker.io/library/redis</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">image</span>: <span style="color:#ae81ff">my_private.registry:5000/redis</span>
</span></span></code></pre></div><p><strong>command</strong></p>
<ul>
<li>컨테이너 이미지(CMD)에 선언된 기본 명령을 재정의 한다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">services</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">webapp</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">command</span>: [<span style="color:#e6db74">&#34;bundle&#34;</span>, <span style="color:#e6db74">&#34;exec&#34;</span>, <span style="color:#e6db74">&#34;thin&#34;</span>, <span style="color:#e6db74">&#34;-p&#34;</span>, <span style="color:#e6db74">&#34;3000&#34;</span>] <span style="color:#75715e"># exec 형식</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">command</span>: <span style="color:#ae81ff">bundle exec thin -p 3000 </span> <span style="color:#75715e"># shell 형식</span>
</span></span></code></pre></div><p><strong>container_name</strong></p>
<ul>
<li>container_name은 컨테이너의 이름을 지정한다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">services</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">webapp</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">container_name</span>: <span style="color:#ae81ff">my-web-container</span>
</span></span></code></pre></div><p>*<strong>*depends_on**</strong></p>
<ul>
<li>서비스 간의 시작 및 종료 종속성을 기술한다.</li>
<li>두 가지 방법으로 기술할 수 있다.</li>
<li>Short syntax
<ul>
<li>종속성 서비스 이름만 지정한다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">services</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">web</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">build</span>: <span style="color:#ae81ff">.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">depends_on</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">db</span>
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">redis</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">redis</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">image</span>: <span style="color:#ae81ff">redis</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">db</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">image</span>: <span style="color:#ae81ff">postgres</span>
</span></span></code></pre></div><ul>
<li>위 예제는 아래와 같은 동작을 의미한다.
<ul>
<li><code>web</code> 보다 <code>db</code> 및 <code>redis</code>가 빨리 생성된다.</li>
<li><code>web</code> 이 <code>db</code> 및 <code>redis</code>보다 빨리 제거된다.</li>
</ul>
</li>
</ul>
</li>
<li>Long syntax
<ul>
<li>이 방법을 사용하면 추가 필드를 사용할 수 있다.</li>
<li><code>condition</code>: 종속성이 충족된 것으로 간주되는 조건
<ul>
<li><code>service_started</code>: (default) 의존하는 서비스가 먼저 시작됨</li>
<li><code>service_healthy</code>: 의존하는 서비스가 먼저 시작되고, healthy 상태임</li>
<li><code>service_completed_successfully</code>: 의존하는 서비스가 성공적으로 종료됨</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">services</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">web</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">build</span>: <span style="color:#ae81ff">.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">depends_on</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">db</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">condition</span>: <span style="color:#ae81ff">service_healthy</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">redis</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">condition</span>: <span style="color:#ae81ff">service_started</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">redis</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">image</span>: <span style="color:#ae81ff">redis</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">db</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">image</span>: <span style="color:#ae81ff">postgres</span>
</span></span></code></pre></div><ul>
<li>위 예제는 아래와 같은 동작을 의미한다.
<ul>
<li><code>web</code> 이 실행되기 전에 <code>db</code> 가 healthy 상태이고 <code>redis</code>가 시작된 상태이다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>environment</strong></p>
<ul>
<li>컨테이너에 설정된 환경변수를 정의한다.</li>
<li>두 가지 방법으로 환경변수를 정의할 수 있다.</li>
<li>Map syntax
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">environment</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">RACK_ENV</span>: <span style="color:#ae81ff">development</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">SHOW</span>: <span style="color:#e6db74">&#34;true&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">USER_INPUT</span>:
</span></span></code></pre></div></li>
<li>Array syntax
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">environment</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#ae81ff">RACK_ENV=development</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#ae81ff">SHOW=true</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#ae81ff">USER_INPUT</span>
</span></span></code></pre></div></li>
</ul>
<p><strong>expose</strong></p>
<ul>
<li>컨테이너에서 노출해야 하는 포트를 정의한다.</li>
<li>호스트 내부의 다른 컨테이너들만 엑세스가 가능하다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">expose</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#e6db74">&#34;3000&#34;</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#e6db74">&#34;8000&#34;</span>
</span></span></code></pre></div><p><strong>ports</strong></p>
<ul>
<li>컨테이너 포트를 노출한다.</li>
<li><code>[HOST:]CONTAINER[/PROTOCOL]</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#e6db74">&#34;3000&#34;</span> <span style="color:#75715e"># 호스트의 랜덤 포트, 컨테이너의 3000번 포트</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#e6db74">&#34;3000-3005&#34;</span> <span style="color:#75715e"># 컨테이너의 포트 번호 범위내에서 할당</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#e6db74">&#34;8000:8000&#34;</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#e6db74">&#34;9090-9091:8080-8081&#34;</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#e6db74">&#34;49100:22&#34;</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#e6db74">&#34;127.0.0.1:8001:8001&#34;</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#e6db74">&#34;127.0.0.1:5000-5010:5000-5010&#34;</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#e6db74">&#34;6060:6060/udp&#34;</span>
</span></span></code></pre></div><pre tabindex="0"><code>expose vs ports
- ports는 호스트와 컨테이너의 포트를 바인딩 시킨다.
- ports는 호스트 포트와 컨테이너 포트를 모두 노출시키기 때문에
	호스트 내부 컨테이너 간에는 노출된 포트로 접근할 수 있지만,
	호스트 외부에서는 컨테이너와 바인딩된 포트로 접근해야 한다.

- expose는 호스트 포트를 공개하지 않고 컨테이너의 포트만 공개한다.
- 따라서 호스트 외부에서는 컨테이너에 접근할 수 없고 컨테이너 끼리만 접근이 가능하다.
</code></pre><p><strong>healthcheck</strong></p>
<ul>
<li>서비스 컨테이너가 healthy 상태인지 확인한다.</li>
<li>healthcheck의 하위 구성 요소는 아래와 같다.</li>
</ul>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>disable</td>
<td>true 또는 false로 healthcheck 여부를 설정</td>
</tr>
<tr>
<td>test</td>
<td>컨테이너 상태를 확인하기 위한 명령 정의. exec 방식과 shell 방식 모두 사용 가능</td>
</tr>
<tr>
<td>interval</td>
<td>헬스 체크 간격</td>
</tr>
<tr>
<td>timeout</td>
<td>헬스 체크 타임아웃 기준</td>
</tr>
<tr>
<td>retries</td>
<td>타임아웃 횟수</td>
</tr>
<tr>
<td>start_period</td>
<td>컨테이너 시작 후 대기 시간</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">healthcheck</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">test</span>: [<span style="color:#e6db74">&#34;CMD&#34;</span>, <span style="color:#e6db74">&#34;curl&#34;</span>, <span style="color:#e6db74">&#34;-f&#34;</span>, <span style="color:#e6db74">&#34;http://localhost&#34;</span>]
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">interval</span>: <span style="color:#ae81ff">1m30s</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">timeout</span>: <span style="color:#ae81ff">10s</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">retries</span>: <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">start_period</span>: <span style="color:#ae81ff">40s</span>
</span></span></code></pre></div><p><strong>volumes</strong></p>
<ul>
<li>서비스 컨테이너에서 엑세스하는 마운트 호스트 경로 또는 정의한 볼륨을 기술한다.</li>
<li>마운트가 단일 서비스에서만 사용되는 경우 최상위 volumes 요소 대신 services 하위 요소로 선언할 수 있다.</li>
<li>여러 서비스가 볼륨을 재사용하려면 최상위 volumes 요소에서 정의된 볼륨을 기술해야 한다.</li>
<li><code>HOST_VOLUME:CONTAINER_PATH:[ACCESS_MODE]</code>
<ul>
<li><code>HOST_VOLUME</code>: 호스트 경로 또는 최상위 volumes 요소에서 정의한 볼륨 이름</li>
<li><code>CONTAINER_PATH</code>: 컨테이너의 경로</li>
<li><code>ACCESS_MODE</code>: 목록은 <code>,</code>으로 구분된다.
<ul>
<li><code>rw</code> : 읽기 및 쓰기(기본값)</li>
<li><code>ro</code> : 읽기 전용</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">services</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">backend</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">image</span>: <span style="color:#ae81ff">awesome/database</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">volumes</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">db-data:/etc/data</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">backup</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">image</span>: <span style="color:#ae81ff">backup-service</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">volumes</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">db-data:/var/lib/backup/data</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">volumes</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">db-data</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">driver_opts</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">device</span>: <span style="color:#ae81ff">/host/path/to/volume</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">services</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">backend</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">image</span>: <span style="color:#ae81ff">awesome/database</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">volumes</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">/dir1:/etc/data</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">backup</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">image</span>: <span style="color:#ae81ff">backup-service</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">volumes</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">/dir2:/var/lib/backup/data:ro</span>
</span></span></code></pre></div>]]></content:encoded></item><item><title>Avro schema</title><link>https://jo-minjun.github.io/notes/avro-schema/</link><pubDate>Sat, 02 Jul 2022 18:12:21 +0900</pubDate><guid>https://jo-minjun.github.io/notes/avro-schema/</guid><description>1. Avro 란? 아브로(Avro)는 아파치의 하둡 프로젝트에서 개발된 RPC 및 데이터 직렬화 프레임워크이다.
schema를 json으로 정의하여 바이너리 포맷으로 직렬화 한다.
2. 장점 데이터의 타입을 알 수 있다. 스키마가 직렬화되어 네트워크 통신에 자유롭다. 스키마에 설명이 포함되어 schema 구조를 이해하는데 도움을 준다. 다양한 language를 지원한다. (java, c, c++ 등) default 값을 정의할 수 있다. 3. Data Type 이름 태그 null no value boolean a binary value int 32bit signed integer long 62bit signed integer float single precision(단정밀도) 32bit floating-point number double double percision(배정밀도) 64bit floating-point number bytes sequence of 8-bit unsigned bytes string unicode character sequence Enums name, namespace, aliases, doc, symbols, default 등을 가진다.</description><content:encoded><![CDATA[<h2 id="1-avro-란">1. Avro 란?</h2>
<p>아브로(Avro)는 아파치의 하둡 프로젝트에서 개발된 RPC 및 데이터 직렬화 프레임워크이다.<br>
schema를 json으로 정의하여 바이너리 포맷으로 직렬화 한다.</p>
<h2 id="2-장점">2. 장점</h2>
<ol>
<li>데이터의 타입을 알 수 있다.</li>
<li>스키마가 직렬화되어 네트워크 통신에 자유롭다.</li>
<li>스키마에 설명이 포함되어 schema 구조를 이해하는데 도움을 준다.</li>
<li>다양한 language를 지원한다. (java, c, c++ 등)</li>
<li>default 값을 정의할 수 있다.</li>
</ol>
<h2 id="3-data-type">3. Data Type</h2>
<table>
<thead>
<tr>
<th>이름</th>
<th>태그</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>null</code></td>
<td>no value</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>a binary value</td>
</tr>
<tr>
<td><code>int</code></td>
<td>32bit signed integer</td>
</tr>
<tr>
<td><code>long</code></td>
<td>62bit signed integer</td>
</tr>
<tr>
<td><code>float</code></td>
<td>single precision(단정밀도) 32bit floating-point number</td>
</tr>
<tr>
<td><code>double</code></td>
<td>double percision(배정밀도) 64bit floating-point number</td>
</tr>
<tr>
<td><code>bytes</code></td>
<td>sequence of 8-bit unsigned bytes</td>
</tr>
<tr>
<td><code>string</code></td>
<td>unicode character sequence</td>
</tr>
</tbody>
</table>
<h3 id="enums">Enums</h3>
<p>name, namespace, aliases, doc, symbols, default 등을 가진다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;enum&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;Suit&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;symbols&#34;</span>: [<span style="color:#e6db74">&#34;SPADES&#34;</span>, <span style="color:#e6db74">&#34;HEARTS&#34;</span>, <span style="color:#e6db74">&#34;DIAMONDS&#34;</span>, <span style="color:#e6db74">&#34;CLUBS&#34;</span>]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="arrays">Arrays</h3>
<p>items를 가진다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;array&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;items&#34;</span>: <span style="color:#e6db74">&#34;string&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;default&#34;</span>: []
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="maps">Maps</h3>
<p>values를 가진다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;map&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;values&#34;</span>: <span style="color:#e6db74">&#34;long&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;default&#34;</span>: {}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="unions">Unions</h3>
<p>string, int, boolean 등과 같은 여러개의 서로 다른 타입을 가짐으로써 선택적인 값을 저장할 수 있도록 한다.</p>
<h2 id="4-schema-필드">4. Schema 필드</h2>
<table>
<thead>
<tr>
<th>이름</th>
<th>태그</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>json을 지원하는 스키마의 이름</td>
</tr>
<tr>
<td>namespace</td>
<td>name을 구별하는 패키지</td>
</tr>
<tr>
<td>doc</td>
<td>스키마를 설명하는 doc</td>
</tr>
<tr>
<td>aliases</td>
<td>name의 별칭</td>
</tr>
<tr>
<td>fields</td>
<td>name, doc, type, default, order, aliases 등을 가지는 json type object</td>
</tr>
</tbody>
</table>
<h2 id="5-avro-schema-예시">5. Avro Schema 예시</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;record&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;LongList&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;aliases&#34;</span>: [<span style="color:#e6db74">&#34;LinkedLongs&#34;</span>], <span style="color:#75715e">// old name for this
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#f92672">&#34;fields&#34;</span>: [
</span></span><span style="display:flex;"><span>    { <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;value&#34;</span>, <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;long&#34;</span> }, <span style="color:#75715e">// each element has a long
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    { <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;next&#34;</span>, <span style="color:#f92672">&#34;type&#34;</span>: [<span style="color:#e6db74">&#34;null&#34;</span>, <span style="color:#e6db74">&#34;LongList&#34;</span>] } <span style="color:#75715e">// optional next element
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&#34;type&#34;</span> : <span style="color:#e6db74">&#34;record&#34;</span>,
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&#34;namespace&#34;</span> : <span style="color:#e6db74">&#34;tutorialspoint&#34;</span>,
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&#34;name&#34;</span> : <span style="color:#e6db74">&#34;empdetails &#34;</span>,
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&#34;fields&#34;</span> :
</span></span><span style="display:flex;"><span>   [
</span></span><span style="display:flex;"><span>      { <span style="color:#f92672">&#34;name&#34;</span> : <span style="color:#e6db74">&#34;experience&#34;</span>, <span style="color:#f92672">&#34;type&#34;</span>: [<span style="color:#e6db74">&#34;int&#34;</span>, <span style="color:#e6db74">&#34;null&#34;</span>] },
</span></span><span style="display:flex;"><span>      { <span style="color:#f92672">&#34;name&#34;</span> : <span style="color:#e6db74">&#34;age&#34;</span>, <span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;int&#34;</span> }
</span></span><span style="display:flex;"><span>      {<span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;additional&#34;</span>, <span style="color:#f92672">&#34;type&#34;</span>: {<span style="color:#f92672">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;map&#34;</span>, <span style="color:#f92672">&#34;values&#34;</span>: <span style="color:#e6db74">&#34;string&#34;</span>}}
</span></span><span style="display:flex;"><span>   ]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>]]></content:encoded></item><item><title>Schema registry란?</title><link>https://jo-minjun.github.io/notes/schema-registry/</link><pubDate>Fri, 01 Jul 2022 21:42:30 +0900</pubDate><guid>https://jo-minjun.github.io/notes/schema-registry/</guid><description>1. Schema registry 란? 데이터 관리의 중요한 관점들 중 하나는 schema의 버전 관리이다. 응용프로그램의 시간이 지날수록 schema가 정의되기 시작한 시점부터 schema는 점점 바뀌어가고, producer와 consumer는 직접적인 관계가 끊어져있기 때문에 운영상에 발생하는 이슈가 있다.
producer는 consumer가 어떤 메세지를 소비할지 알 수 없다.
consumer는 producer가 어떤 메세지를 생산했는지 알 수 없다.
위와 같은 상황에서 producer가 갑자기 다른 schema를 이용해서 메세지를 생산할 경우, consumer는 이 메세지에 대해서 대처하지 못할 수 있다.
이는 구조적인 결합도는 낮지만, 메세지 schema에 대한 의존성이 높기 때문인데, schema registry는 이를 보완하기 위해 고안되었다.</description><content:encoded><![CDATA[<h2 id="1-schema-registry-란">1. Schema registry 란?</h2>
<p>데이터 관리의 중요한 관점들 중 하나는 schema의 버전 관리이다.
응용프로그램의 시간이 지날수록 schema가 정의되기 시작한 시점부터 schema는 점점 바뀌어가고,
producer와 consumer는 직접적인 관계가 끊어져있기 때문에 운영상에 발생하는 이슈가 있다.</p>
<blockquote>
<p>producer는 consumer가 어떤 메세지를 소비할지 알 수 없다.<br>
consumer는 producer가 어떤 메세지를 생산했는지 알 수 없다.</p>
</blockquote>
<p>위와 같은 상황에서 producer가 갑자기 다른 schema를 이용해서 메세지를 생산할 경우, consumer는 이 메세지에 대해서 대처하지 못할 수 있다.</p>
<p>이는 구조적인 결합도는 낮지만, 메세지 schema에 대한 의존성이 높기 때문인데,
schema registry는 이를 보완하기 위해 고안되었다.</p>
<p>Confluent Schema registry는 Avro, Json, Protobuf 등의 schema 정보의 history를 subjects를 통해 관리하며, REST API를 통해 <strong>compatibility settings</strong>을 결정하고 현재 버전과 이전 버전간의 호환성을 지원한다.</p>
<p><img loading="lazy" src="/images/notes/schema-registry/schema-registry-kafka.png" alt="schema-registry-kafka.png"  />
</p>
<p>Schema registry는 kafka boroker와 독립적으로 존재하며, producer와 consumer는 kafka broker와 읽고 쓰는 동안 Schema registry와 동작하며 데이터 모델을 확인할 수 있다.</p>
<h2 id="2-schemas-subjects-and-topics-란">2. Schemas, Subjects and Topics 란?</h2>
<p>topic은 kafka의 topic을, schema는 Avro, Json, Protobuf 등으로 정의된 데이터 포맷 구조를 의미한다.</p>
<p>Subject는 Schema registry에 schema가 등록된 이름이며, 여러 버전의 schema가 등록될 수 있다.</p>
<p>따라서 Subject를 통해 계속해서 Schema의 정보를 관리할 수 있고, 새로운 버전의 Schema ID와 버전을 확인할 수 있다.</p>
<p><img loading="lazy" src="/images/notes/schema-registry/schema-subject-topic.png" alt="schema registry.png"  />
</p>
<ul>
<li>kafka topic은 메세지가 포함되어 있으며, 각 메세지는 key - value 쌍으로 되어있으며
메세지의 key와 value는 Avro, Json, Protobuf 등으로 직렬화할 수 있다.</li>
<li>Schema는 데이터 포맷의 구조를 정의한다.</li>
<li>kafka의 topic 이름은 schema의 이름과 의존적이지 않다.</li>
<li>Schema의 ID는 전역적이다.</li>
</ul>
<h2 id="3-compatibility-settings-란">3. Compatibility settings 란?</h2>
<p>schema compatibility checking는 모든 schema를 버전화해서 schema registry compatibility type에 의해서 구현된다.</p>
<p>즉, 아래의 schema 전략에 의한 패턴으로 호환성을 유지하게 된다.</p>
<table>
<thead>
<tr>
<th>Compatibility type</th>
<th>허가되는 변경</th>
<th>비교하는 schema</th>
<th>upgrade 순서</th>
</tr>
</thead>
<tbody>
<tr>
<td>BACKWARD</td>
<td>- 필드 삭제<!-- raw HTML omitted -->- Optional 필드 추가</td>
<td>마지막 버전</td>
<td>Consumers</td>
</tr>
<tr>
<td>BACKWARD_TRANSITIVE</td>
<td>- 필드 삭제<!-- raw HTML omitted -->- Optional 필드 추가</td>
<td>모든 이전 버전</td>
<td>Consumers</td>
</tr>
<tr>
<td>FORWARD</td>
<td>- 필드 추가<!-- raw HTML omitted -->- Optional 필드 삭제</td>
<td>마지막 버전</td>
<td>Producers</td>
</tr>
<tr>
<td>FORWARD_TRANSITIVE</td>
<td>- 필드 추가<!-- raw HTML omitted -->- Optional 필드 삭제</td>
<td>모든 이전 버전</td>
<td>Producers</td>
</tr>
<tr>
<td>FULL</td>
<td>- Optional 필드 추가<!-- raw HTML omitted -->- Optional 필드 삭제</td>
<td>마지막 버전</td>
<td>Any order</td>
</tr>
<tr>
<td>FULL_TRANSITIVE</td>
<td>- Optional 필드 추가<!-- raw HTML omitted -->- Optional 필드 삭제</td>
<td>모든 이전 버전</td>
<td>Any order</td>
</tr>
<tr>
<td>NONE</td>
<td>모든 변경 허용</td>
<td>비교하지 않음</td>
<td>Depends</td>
</tr>
</tbody>
</table>
<ul>
<li><code>BACKWARD</code>: (<em>default</em>) consumer가 새로운 스키마를 사용하여 producer가 마지막 버전의 스키마로 생성한 메세지를 읽을 수 있다.
(새로운 스키마로 이전 스키마 메세지를 읽는다.)
(새로운 스키마 필드에 default value가 없으면 오류가 발생한다.)</li>
<li><code>BACKWARD_TRANSITIVE</code>: consumer가 새로운 스키마를 사용하여 producer가 모든 마지막 버전 스키마로 생성한 메세지를 읽을 수 있다.</li>
<li><code>FORWARD</code>: consumer가 마지막 버전의 스키마를 사용하여 producer가 새로운 스키마로 생성한 메세지를 읽을 수 있다.
(이전 스키마로 새로운 스키마 데이터를 읽는다.)
(새로운 스키마에서 필드가 삭제되면, 이전 스키마에 default value가 있어야 한다.)</li>
<li><code>FORWARD_TRANSITIVE</code>: consumer가 모든 마지막 버전의 스키마를 사용하여 producer가 새로운 스키마로 생성한 메세지를 읽을 수 있다.</li>
<li><code>FULL</code>: <code>BACKWARD</code> 와 <code>FORWARD</code> 를 모두 만족한다.</li>
<li><code>FULL_TRANSITIVE</code>: <code>BACKWARD_TRANSITIVE</code> 와 <code>FORWARD_TRANSITIVE</code> 를 모두 만족한다.</li>
<li><code>NONE</code>: schema compatibility checks are disabled</li>
</ul>
<h2 id="4-rest-api-interface-reference---schemas-subjects">4. Rest API Interface Reference - Schemas, Subjects</h2>
<p>Schema Registry REST API 서버는 사용된 API의 버전과 데이터의 직렬화 포맷을 표시하기 위해 요청과 응답에 content type을 사용한다.</p>
<p>현재는 직렬화 포맷은 JSON만을 지원하고 API의 버전은 v1만 사용할 수 있다.
하지만 나중 버전의 호환을 위해서 반드시 content type을 사용해야한다.</p>
<p>추천하는 content type은 <code>application/vnd.schemaregistry.v1+json</code>이다.
v1은 API의 버전이고, json은 직렬화 포맷이다.</p>
<p>모든 API endpoint는 다음과 같은 error message 포맷을 사용한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">422</span> Unprocessable Entity
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;error_code&#34;</span>: 422,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;message&#34;</span>: <span style="color:#e6db74">&#34;schema may not be empty&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><blockquote>
<p>추가적으로 요청시 json은 string 형태로 전달해야 한다.</p>
</blockquote>
<h3 id="schemas-관련">Schemas 관련</h3>
<h4 id="getschemasidsintid"><code>GET /schemas/ids/{int: id}</code></h4>
<p>입력한 id를 이용하여 스키마 정보를 요청한다.</p>
<blockquote>
<p><strong>Parameters:</strong><br>
id (int) - 전역적으로 unique한 스키마 id</p>
</blockquote>
<p><strong>Response JSON Object:</strong>
schema (string) - id로 구분한 schema string</p>
<p><strong>Status Codes:</strong>
404 Not Found - schema not found
500 Internal Server Error - Error in the backend datastore</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /schemas/ids/1 HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;schema&#34;</span>: <span style="color:#e6db74">&#34;{\&#34;type\&#34;: \&#34;string\&#34;}&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h4 id="getschemastypes"><code>GET /schemas/types/</code></h4>
<p>Schema Registry에 저장된 스키마 타입을 요청한다.</p>
<blockquote>
<p><strong>Response JSON Object:</strong>
schema (string) - Schema Registry에서 현재 사용가능한 스키마 타입</p>
</blockquote>
<p><strong>Status Codes:</strong>
404 Not Found - schema not found
500 Internal Server Error - Error in the backend datastore</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /schemas/types HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;JSON&#34;</span>, <span style="color:#e6db74">&#34;PROTOBUF&#34;</span>, <span style="color:#e6db74">&#34;AVRO&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h4 id="getschemasidsintidversions"><code>GET /schemas/ids/{int: id}/versions</code></h4>
<p>Schema Registry에 저장된 스키마 타입을 요청한다.</p>
<blockquote>
<p><strong>Parameters:</strong><br>
id (int) - 전역적으로 unique한 스키마 id</p>
</blockquote>
<p><strong>Response JSON Object:</strong>
subject - subject의 이름
version - return된 subject의 버전</p>
<p><strong>Status Codes:</strong>
404 Not Found - schema not found
500 Internal Server Error - Error in the backend datastore</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /schemas/ids/1/versions HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[{</span><span style="color:#e6db74">&#34;subject&#34;</span>:<span style="color:#e6db74">&#34;test-subject1&#34;</span>,<span style="color:#e6db74">&#34;version&#34;</span>:1<span style="color:#f92672">}]</span>
</span></span></code></pre></div><h3 id="subjects-관련">Subjects 관련</h3>
<blockquote>
<p>subject resource는 Schema Registry에 저장된 모든 subject 목록을 제공한다.<br>
subject는 스키마가 저장된 이름을 나타낸다.<br>
만약 Kafka에 Schema Registry를 사용하고 있다면, subject는 topic에 대한 key 또는 value 스키마를 등록하고 있는지에 따라 <code>&lt;topic&gt;-key</code> 또는 <code>&lt;topic&gt;-value</code>를 참조한다.</p>
</blockquote>
<h4 id="getsubjects"><code>GET /subjects</code></h4>
<p>Schema Registry에 저장된 subject의 목록을 요청한다.</p>
<blockquote>
<p><strong>Parameters:</strong><br>
subject (string) - subject의 이름<br>
deleted (boolean) - default는 false이다. <code>?deleted=true</code>로 요청하면 soft delete된 subject 목록을 함께 return 한다.</p>
</blockquote>
<p><strong>Response JSON Object:</strong>
name (string) - subject</p>
<p><strong>Status Codes:</strong>
500 Internal Server Error - Error in the backend datastore</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /subjects HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span><span style="color:#e6db74">&#34;subject1&#34;</span>, <span style="color:#e6db74">&#34;subject2&#34;</span><span style="color:#f92672">]</span>
</span></span></code></pre></div><h4 id="getsubjectsstring-subjectversions"><code>GET /subjects/(string: subject)/versions</code></h4>
<p>Schema Registry에 저장된 subject의 버전 목록을 요청한다.</p>
<blockquote>
<p><strong>Parameters:</strong><br>
subject (string) - subject의 이름</p>
</blockquote>
<p><strong>Response JSON Object:</strong>
version (int) - subject 아래에 저장된 스키마의 버전</p>
<p><strong>Status Codes:</strong>
404 Not Found - schema not found
500 Internal Server Error - Error in the backend datastore</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /subjects/test/versions HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>  1, 2, 3, <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">]</span>
</span></span></code></pre></div><h4 id="deletesubjectsstringsubject"><code>DELETE /subjects/(string: subject)</code></h4>
<p>등록된 특정 subject를 삭제한다.
이 API는 topic을 재사용하거나 개발 환경에서만 사용하는 것이 권장된다.</p>
<blockquote>
<p><strong>Parameters:</strong><br>
subject (string) - subject의 이름<br>
permanent (boolean) - <code>?permanent=true</code>를 추가하여 hard delete를 표시한다.</p>
</blockquote>
<p><strong>Response JSON Object:</strong>
version (int) - subject 아래에 저장된 스키마의 버전</p>
<p><strong>Status Codes:</strong>
404 Not Found - schema not found
500 Internal Server Error - Error in the backend datastore</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>DELETE /subjects/test HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>  1, 2, 3, <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">]</span>
</span></span></code></pre></div><h4 id="getsubjectsstringsubjectversionsversionidversion"><code>GET /subjects/(string: subject)/versions/(versionId: version)</code></h4>
<p>등록된 특정 subject를 요청한다.</p>
<blockquote>
<p><strong>Parameters:</strong><br>
subject (string) - subject의 이름<br>
version (versionId) - return될 스키마의 버전이다. [1, 2^31 - 1] 또는 latest가 유효한 값이다.</p>
</blockquote>
<p><strong>Response JSON Object:</strong>
subject (string) - subject의 이름
id (int) - 전역적으로 unique한 shema의 id
version (int) - subject 아래에 저장된 return될 스키마의 버전
schemaType (string) - schema의 format (default: AVRO)
schema (string) - schema의 내용</p>
<p><strong>Status Codes:</strong>
404 Not Found - schema not found
422 Unprocessable Entity - Invalid version
500 Internal Server Error - Error in the backend datastore</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /subjects/test/versions/1 HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;test&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;version&#34;</span>: 1,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;schema&#34;</span>: <span style="color:#e6db74">&#34;{\&#34;type\&#34;: \&#34;string\&#34;}&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h4 id="getsubjectsstringsubjectversionsversionidversionschema"><code>GET /subjects/(string: subject)/versions/(versionId: version)/schema</code></h4>
<p>등록된 특정 subject를 요청한다. unescaped schema만 return 된다.?</p>
<blockquote>
<p><strong>Parameters:</strong><br>
subject (string) - subject의 이름<br>
version (versionId) - return될 스키마의 버전이다. [1, 2^31 - 1] 또는 latest가 유효한 값이다.</p>
</blockquote>
<p><strong>Response JSON Object:</strong>
schema (string) - schema의 내용</p>
<p><strong>Status Codes:</strong>
404 Not Found - subject not found or version not found
422 Unprocessable Entity - Invalid version
500 Internal Server Error - Error in the backend datastore</p>
<blockquote>
</blockquote>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /subjects/test/versions/1/schema HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span><span style="color:#e6db74">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;string&#34;</span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h4 id="postsubjectsstringsubjectversions"><code>POST /subjects/(string: subject)/versions</code></h4>
<p>등록된 특정 subject에 새로운 스키마를 등록한다.
만약 성공적으로 등록되면, unique한 스키마의 id가 return 된다.
동일한 스키마가 다른 subject에 등록되면 동일한 id가 return 된다. 그라나 스키마의 버전은 subject에 따라 다를 수 있다.</p>
<blockquote>
<p><strong>Parameters:</strong><br>
subject (string) - subject의 이름<br>
normalize (boolean) - <code>?normalize=true</code>를 추가하여 normalize 상태를 표시한다.?</p>
</blockquote>
<p><strong>Request JSON Object:</strong>
schema (string) - schema의 내용
schemaType - 스키마의 포맷 (default: AVRO)
references - 스키마의 이름 지정 (optional)</p>
<p><strong>Response JSON Object:</strong>
subject (string) - subject의 이름
id (int) - 전역적으로 unique한 스키마의 id
version (int) - return 되는 스키마의 버전
schema (string) - schema의 내용</p>
<p><strong>Status Codes:</strong>
409 Conflic - Incompatible schema
422 Unprocessable Entity - Invalid version
500 Internal Server Error - Error in the backend datastore or Operation timed out or Error while forwarding the request to the primary</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>POST /subjects/test/versions HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;schema&#34;</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">       \&#34;type\&#34;: \&#34;record\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">       \&#34;name\&#34;: \&#34;test\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">       \&#34;fields\&#34;:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         [
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             \&#34;type\&#34;: \&#34;string\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             \&#34;name\&#34;: \&#34;field1\&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           },
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             \&#34;type\&#34;: \&#34;com.acme.Referenced\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             \&#34;name\&#34;: \&#34;int\&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">          ]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     }&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;schemaType&#34;</span>: <span style="color:#e6db74">&#34;AVRO&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;references&#34;</span>: <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>       <span style="color:#e6db74">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;com.acme.Referenced&#34;</span>,
</span></span><span style="display:flex;"><span>       <span style="color:#e6db74">&#34;subject&#34;</span>:  <span style="color:#e6db74">&#34;childSubject&#34;</span>,
</span></span><span style="display:flex;"><span>       <span style="color:#e6db74">&#34;version&#34;</span>: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span><span style="color:#e6db74">&#34;id&#34;</span>:1<span style="color:#f92672">}</span>
</span></span></code></pre></div><h4 id="postsubjectsstringsubject"><code>POST /subjects/(string: subject)</code></h4>
<p>특정 subject에 schema가 이미 등록됐는지 확인한다.
만약 존재하면 전역적으로 unique한 id와 schema를 return 한다.</p>
<blockquote>
<p><strong>Parameters:</strong><br>
subject (string) - subject의 이름<br>
normalize (boolean) - <code>?normalize=true</code>를 추가하여 normalize 상태를 표시한다.</p>
</blockquote>
<p><strong>Request JSON Object:</strong>
schema (string) - schema의 내용
schemaType - 스키마의 포맷 (default: AVRO)
references - 스키마의 이름 지정 (optional)</p>
<p><strong>Response JSON Object:</strong>
subject (string) - subject의 이름
id (int) - 전역적으로 unique한 스키마의 id
version (int) - return 되는 스키마의 버전
schema (string) - schema의 내용</p>
<p><strong>Status Codes:</strong>
404 Not Found - Subject not found
500 Internal Server Error - Internal server error</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>POST /subjects/test HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;schema&#34;</span>:
</span></span><span style="display:flex;"><span>         <span style="color:#e6db74">&#34;{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                \&#34;type\&#34;: \&#34;record\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                \&#34;name\&#34;: \&#34;test\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                \&#34;fields\&#34;:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                  [
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                      \&#34;type\&#34;: \&#34;string\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                      \&#34;name\&#34;: \&#34;field1\&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    },
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                      \&#34;type\&#34;: \&#34;int\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                      \&#34;name\&#34;: \&#34;field2\&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                  ]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">              }&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;subject&#34;</span>: <span style="color:#e6db74">&#34;test&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;id&#34;</span>: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;version&#34;</span>: <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;schema&#34;</span>:
</span></span><span style="display:flex;"><span>         <span style="color:#e6db74">&#34;{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                \&#34;type\&#34;: \&#34;record\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                \&#34;name\&#34;: \&#34;test\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                \&#34;fields\&#34;:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                  [
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                      \&#34;type\&#34;: \&#34;string\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                      \&#34;name\&#34;: \&#34;field1\&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    },
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                      \&#34;type\&#34;: \&#34;int\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                      \&#34;name\&#34;: \&#34;field2\&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                  ]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">              }&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span></code></pre></div><h4 id="deletesubjectsstringsubjectversionsversionidversion"><code>DELETE /subjects/(string: subject)/versions/(versionId: version)</code></h4>
<p>특정 subject에 등록된 schema의 버전을 삭제한다.
이 API는 호환성 목적으로 이전에 등록한 스키마를 삭제하거나 이전에 등록한 스키마를 다시 등록해야 하는 개발 환경이나 극단적인 상황에서만 사용하는 것이 좋다.</p>
<blockquote>
<p><strong>Parameters:</strong><br>
subject (string) - subject의 이름<br>
version (versionId) - 삭제될 schema 버전을 표시한다. [1, 2^31 - 1] 또는 latest가 될 수 있다.<br>
permanent (boolean) - <code>?permanent=true</code>를 추가하여 hard delete를 표시한다.</p>
</blockquote>
<p><strong>Response JSON Object:</strong>
int - 삭제된 schema의 버전</p>
<p><strong>Status Codes:</strong>
404 Not Found - Subject not found or Version not found
422 Unprocessable Entity - Invalid version
500 Internal Server Error - Error in the backend data store</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>DELETE /subjects/test/versions/1 HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span></code></pre></div><h4 id="getsubjectsstringsubjectversionsversionidversionreferencedby"><code>GET /subjects/(string: subject)/versions/{versionId: version}/referencedby</code></h4>
<p>주어진 subject와 버전에 대한 schema의 id의 목록을 요청한다.</p>
<blockquote>
<p><strong>Parameters:</strong><br>
subject (string) - subject의 이름<br>
version (versionId) - return 되는 schema 버전을 표시한다. [1, 2^31 - 1] 또는 latest가 될 수 있다.</p>
</blockquote>
<p><strong>Request JSON Array of Objects:</strong>
id (int) - 전역적으로 unique한 스키마의 id</p>
<p><strong>Status Codes:</strong>
404 Not Found - Subject not found
500 Internal Server Error - Error in the backend data store</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /subjects/test/versions/1/referencedby HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>  1, 2, 3, <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">]</span>
</span></span></code></pre></div><h2 id="5-rest-api-interface-reference---compatibility-config">5. REST API Interface Reference - Compatibility, Config</h2>
<h3 id="compatibility">Compatibility</h3>
<p>compatibility resource는 모든 버전 또는 특정 버전에 대해 사용자가 스키마의 호환성을 검사할 수 있도록 한다.</p>
<h4 id="postcompatibilitysubjectsstringsubjectversionsversionidversion"><code>POST /compatibility/subjects/(string: subject)/versions/(versionId: version)</code></h4>
<p>input 스키마에 대해서 특정 스키마의 버전에 대한 호환성을 검사한다.</p>
<blockquote>
<p><strong>Parameters:</strong>
subject (string) - 호환성을 테스트할 subject의 이름<br>
version (versionId) - 호환성을 테스트할 대상의 schema 버전을 표시한다. [1, 2^31 - 1] 또는 latest가 될 수 있다.<br>
verbose (boolean) - <code>?verbose=true</code>를 추가하여 호환성 테스트에 실패하는 이유를 출력한다.</p>
</blockquote>
<p><strong>Request JSON Object:</strong>
schema - 스키마의 내용
schemaType - 스키마의 포맷 (default: AVRO)
references - 참조된 스키마의 이름을 지정한다. (optional)</p>
<p><strong>Response JSON Object:</strong>
is_compatible (boolean) - 호환가능 여부</p>
<hr>
<p><strong>Status Codes:</strong>
404 Not Found - Subject not found or Version not found
422 Unprocessable Entity - Invalid schema or Invalid version
500 Internal Server Error - Error in the backend data store</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>POST /compatibility/subjects/test/versions/latest HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;schema&#34;</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">       \&#34;type\&#34;: \&#34;record\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">       \&#34;name\&#34;: \&#34;test\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">       \&#34;fields\&#34;:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         [
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             \&#34;type\&#34;: \&#34;string\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             \&#34;name\&#34;: \&#34;field1\&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           },
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             \&#34;type\&#34;: \&#34;int\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             \&#34;name\&#34;: \&#34;field2\&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         ]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     }&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;is_compatible&#34;</span>: true
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h4 id="postcompatibilitysubjectsstringsubjectversions"><code>POST /compatibility/subjects/(string: subject)/versions</code></h4>
<p>호환성 전략에 따라 subject의 하나의 버전 또는 여러 버전의 호환성을 확인한다.</p>
<blockquote>
<p><strong>Parameters:</strong>
subject (string) - 호환성을 테스트할 subject의 이름
verbose (boolean) - **<code>?verbose=true</code>**를 추가하여 호환성 테스트에 실패하는 이유를 출력한다.</p>
</blockquote>
<p><strong>Request JSON Object:</strong>
schema - 스키마의 내용
schemaType - 스키마의 포맷 (default: AVRO)
references - 참조된 스키마의 이름을 지정한다. (optional)</p>
<p><strong>Response JSON Object:</strong>
is_compatible (boolean) - 호환가능 여부</p>
<hr>
<p><strong>Status Codes:</strong>
404 Not Found - Subject not found
422 Unprocessable Entity - Invalid schema
500 Internal Server Error - Error in the backend data store</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>POST /compatibility/subjects/test/versions
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;schema&#34;</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">       \&#34;type\&#34;: \&#34;record\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">       \&#34;name\&#34;: \&#34;test\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">       \&#34;fields\&#34;:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         [
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             \&#34;type\&#34;: \&#34;string\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             \&#34;name\&#34;: \&#34;field1\&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           },
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             \&#34;type\&#34;: \&#34;int\&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             \&#34;name\&#34;: \&#34;field2\&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         ]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     }&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;is_compatible&#34;</span>: true
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="config">Config</h3>
<h4 id="putconfig"><code>PUT /config</code></h4>
<p>전역적 호환성 전략을 변경한다.</p>
<blockquote>
<p><strong>Request JSON Object:</strong><br>
compatibility (string) - 새롭게 변경된 호환성 전략을 표시한다.</p>
</blockquote>
<hr>
<p><strong>Status Codes:</strong>
422 Unprocessable Entity - Invalid compatibility level
500 Internal Server Error - Error in the backend data store or Error while forwarding request to the primary</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>PUT /config HTTP/1.1
</span></span><span style="display:flex;"><span>Host: kafkaproxy.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;compatibility&#34;</span>: <span style="color:#e6db74">&#34;FULL&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;compatibility&#34;</span>: <span style="color:#e6db74">&#34;FULL&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h4 id="get-config"><code>**GET /config**</code></h4>
<p>전역적 호환성 전략을 요청한다.</p>
<blockquote>
<p><strong>Response JSON Object:</strong><br>
compatibility (string) - 현재 호환성 전략을 표시한다.</p>
</blockquote>
<hr>
<p><strong>Status Codes:</strong>
500 Internal Server Error - Error in the backend data store</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /config HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;compatibilityLevel&#34;</span>: <span style="color:#e6db74">&#34;FULL&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h4 id="putconfigstring-subject"><code>PUT /config/(string: subject)</code></h4>
<p>특정 subject에 대한 호환성 전략을 변경한다.</p>
<blockquote>
<p><strong>Parameters:</strong>
subject (string) - subject의 이름</p>
</blockquote>
<p><strong>Request JSON Object:</strong>
compatibility (string) - 새롭게 변경된 호환성 전략을 표시한다.</p>
<hr>
<p><strong>Status Codes:</strong>
422 Unprocessable Entity - Invalid compatibility level
500 Internal Server Error - Error in the backend data store or Error while forwarding request to the primary</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>PUT /config/test HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;compatibility&#34;</span>: <span style="color:#e6db74">&#34;FULL&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;compatibility&#34;</span>: <span style="color:#e6db74">&#34;FULL&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h4 id="get-configstring-subject"><code>GET /config/(string: subject)</code></h4>
<p>특정 subject에 대한 호환성 전략을 요청한다.</p>
<blockquote>
<p><strong>Parameters:</strong><br>
subject (string) - subject의 이름<br>
defaultToGlobal (boolean) - **<code>?defaultToBlobal=false</code>**를 추가하여 호환성을 표시한다.<br>
**<code>?defaultToBlobal=true</code>**를 추가하면 호환성 검사에 필요한 사항을 표시한다.</p>
</blockquote>
<p><strong>Response JSON Object:</strong>
compatibility (string) - 현재 호환성 전략을 표시한다.</p>
<hr>
<p><strong>Status Codes:</strong>
404 Not Found - Subject not found
500 Internal Server Error - Error in the backend data store</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /config/test HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>   <span style="color:#e6db74">&#34;compatibilityLevel&#34;</span>: <span style="color:#e6db74">&#34;FULL&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h4 id="deleteconfigstringsubject"><code>DELETE /config/(string: subject)</code></h4>
<p>특정 subject에 대한 호환성 전략을 삭제하고, 전역적 호환성 전략을 사용한다.</p>
<blockquote>
<p><strong>Parameters:</strong><br>
subject (string) - subject의 이름</p>
</blockquote>
<hr>
<p><strong>Status Codes:</strong>
404 Not Found - Subject not found
500 Internal Server Error - Error in the backend data store</p>
<p><strong>Example request:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>DELETE /config/test HTTP/1.1
</span></span><span style="display:flex;"><span>Host: schemaregistry.example.com
</span></span><span style="display:flex;"><span>Accept: application/vnd.schemaregistry.v1+json, application/vnd.schemaregistry+json, application/json
</span></span></code></pre></div><p><strong>Example response:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Content-Type: application/vnd.schemaregistry.v1+json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>   <span style="color:#e6db74">&#34;compatibility&#34;</span>: <span style="color:#e6db74">&#34;NONE&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h2 id="6-subject-name-strategy">6. Subject Name Strategy</h2>
<p>subject 이름을 만들어 내기 위한 subject naming strategy가 있다.</p>
<table>
<thead>
<tr>
<th>Strategy</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>TopicNameStrategy<!-- raw HTML omitted --> (default)</td>
<td>- topic 이름으로부터 subject의 이름을 만든다.<!-- raw HTML omitted -->- 항상 하나의 topic에 있는 메세지는 같은 schema를 가지는 것을 보장한다.</td>
</tr>
<tr>
<td>RecordNameStrategy</td>
<td>- record 이름으로부터 subject의 이름을 만들고, subject 아래에 서로 다른 schema를 가질 수 있는 논리적으로 관련된 그룹화를 제공한다.<!-- raw HTML omitted -->- 하나의 topic에 여러개의 schema를 가지는 것을 허용한다.<!-- raw HTML omitted -->- 이 전략은 메세지가 서로 다른 데이터 구조를 가질때 유용하게 사용할 수 있다.</td>
</tr>
<tr>
<td>TopicRecordNameStrategy</td>
<td>- topic과 record 이름으로부터 subject의 이름을 만들고, subject 아래에 서로 다른 schema를 가질 수 있는 논리적으로 관련된 그룹화를 제공한다.<!-- raw HTML omitted -->- 하나의 topic에 여러개의 schema를 가지는 것을 허용한다.<!-- raw HTML omitted -->- 이 전략은 메세지가 서로 다른 데이터 구조를 가질때 유용하게 사용할 수 있다.</td>
</tr>
</tbody>
</table>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://docs.confluent.io/platform/current/schema-registry/serdes-develop/index.html#">https://docs.confluent.io/platform/current/schema-registry/serdes-develop/index.html#</a></li>
</ul>
]]></content:encoded></item><item><title>Kafka란?</title><link>https://jo-minjun.github.io/notes/kafka/</link><pubDate>Fri, 01 Jul 2022 12:51:30 +0900</pubDate><guid>https://jo-minjun.github.io/notes/kafka/</guid><description>1. kafka 란? apache kafka는 오픈 소스 분산 이벤트 스트리밍 플랫폼이다.
*데이터 파이프 라인 구성시, 주로 사용되는 오픈 소스로 대용량 실시간 로그 처리에 특화되어 많은 사람들이 사용하고 있다.
*데이터 파이프 라인: 데이터 처리 단계의 출력이 다음 단계의 입력으로 이어지는 형태로 연결된 구조를 가리킨다.
2. kafka의 특성 2.1. Publisher-Subscriber 모델 Publisher-Subscriber 모델은 중간에 데이터 큐를 두고 서로 간 독립적으로 데이터를 생산하고 소비한다.
이러한 구조를 통해, Publisher나 Subscriber에 장애가 생겨도, 독립적이기 때문에 안정적으로 데이터를 처리할 수 있다.</description><content:encoded><![CDATA[<h2 id="1-kafka-란"><strong>1. kafka 란?</strong></h2>
<p>apache kafka는 오픈 소스 분산 이벤트 스트리밍 플랫폼이다.</p>
<p><strong>*데이터 파이프 라인</strong> 구성시, 주로 사용되는 오픈 소스로 대용량 실시간 로그 처리에 특화되어 많은 사람들이 사용하고 있다.</p>
<blockquote>
<p><strong>*데이터 파이프 라인:</strong>
데이터 처리 단계의 출력이 다음 단계의 입력으로 이어지는 형태로 연결된 구조를 가리킨다.</p>
</blockquote>
<h2 id="2-kafka의-특성">2. kafka의 특성</h2>
<h3 id="21-publisher-subscriber-모델">2.1. Publisher-Subscriber 모델</h3>
<p>Publisher-Subscriber 모델은 중간에 데이터 큐를 두고 서로 간 독립적으로 데이터를 생산하고 소비한다.</p>
<p>이러한 구조를 통해, Publisher나 Subscriber에 장애가 생겨도, 독립적이기 때문에 안정적으로 데이터를 처리할 수 있다.</p>
<h3 id="22-고가용성-및-확장성-high-availablility-and-scalability">2.2. 고가용성 및 확장성 (High availablility and Scalability)</h3>
<p>kafka는 cluster 구조로 데이터를 분산하여 저장한다.</p>
<p>따라서 하나의 broker에 장애가 생겨도 가용성이 높다.</p>
<p>또한 클러스터를 수평적으로 늘려 안정성 및 성능을 향상시키는 Scale-out이 가능하다.</p>
<h3 id="23-디스크-순차-저장-및-처리">2.3. 디스크 순차 저장 및 처리</h3>
<p>메세지를 메모리 큐에 적재하는 기존 메세지 시스템과 달리 kafka는 메세지를 디스크에 순차적으로 저장한다.</p>
<p>따라서</p>
<p>서버에 장애가 나도 메세지가 디스크에 저장되어 안정성이 높고 순차적으로 저장되어 I/O작업이 줄어들어 성능이 좋아진다.</p>
<h3 id="24-분산-처리">2.4. 분산 처리</h3>
<p>kafka는 partition을 통해 여러개의 partition을 여러개의 서버에 분산시켜 나누어 처리할 수 있다.</p>
<h2 id="3-kafka의-구조">3. kafka의 구조</h2>
<h3 id="31-publisher-subscriber-모델">3.1. Publisher-Subscriber 모델</h3>
<p>Pub-Sub (발행-구독) 모델은 특정 시스템에 직접 메세지를 전달하는 시스템이 아니다.</p>
<p>publisher은 메세지를 <strong>*Topic</strong>을 통해서 분류하여 관리하고, receiver은 전달받기를 원하는 <strong>*Topic</strong>을 구독하여 메세지를 전달 받는다.</p>
<p>즉 <strong>*kafka cluster</strong>를 중심으로 producer가 push하고, consumer가 메세지를 pull하는 구조이다.</p>
<p><img loading="lazy" src="/images/notes/kafka/pub-sub.png" alt="pub-sub"  />
</p>
<blockquote>
<p><strong>*kafka cluster:</strong>
kafka 서버 (broker)로 이루어진 클러스터를 말한다.</p>
</blockquote>
<p><strong>broker:</strong>
메세지 중계 역할을 하는 kafka서버를 말한다.</p>
<p><strong>*topic:</strong>
kafka cluster에 메세지를 관리할 때, 기준이 되는 논리적 모델이다.
여러개를 생성할 수 있으며, 하나의 topic은 1개 이상의 partition으로 구성되어 있다.</p>
<p><strong>partition:</strong>
토픽에서 메세지를 분산 처리하는 단위이다.
토픽을 partition으로 나누어 나눈 만큼 분산 처리를 한다.
kafka option에서 지정한 replica (replication factor)의 수만큼 partition이 broker들에게 복제된다.</p>
<p><strong>leader &amp; follower:</strong>
kafka 에서는 복제된 partition들 중에서 하나의 leader가 선출된다.
leader는 read, write 연산을 담당하며, follower들은 leader의 메세지를 복사한다.
leader partition이 포함된 broker에서 장애가 발생하면
follower partition들 중 하나가 leader가 된다.</p>
<p><strong>*consumer group - 상세 설명:</strong>
consumer의 집합을 구성하는 단위이다.
kafka에서는 consumer group 단위로 메세지를 처리하고, consumer group의 consumer 수만큼 파티션의 데이터를 분산처리하게 된다.</p>
<p><strong>*offset - 상세 설명:</strong>
consumer group들은 partition의 offset을 기준으로 데이터를 순차적으로 처리한다.</p>
<blockquote>
</blockquote>
<p><strong>3.1.1. consumer group</strong></p>
<p>여러개의 producer 들이 메세지를 전달하는 속도가 consumer가 메세지를 처리하는 속도보다 빠르면 하나의 consumer 만으로는 전달되는 메세지를 모두 처리할 수 없다.</p>
<p>따라서 consumer group을 통해 메세지를 처리한다.</p>
<p>consumer group은 같은 토픽의 여러개의 partition을 분담하여 처리하게 된다.</p>
<p>가령 partition의 수가 4개이고, consumer group의 consumer가 2개라면
각 consumer는 2개씩의 partition을 분담하여 메세지를 처리한다.
또한, partition의 수가 consumer group의 consumer 수보다 적다면
partition을 분담하지 못한 consumer는 idle이 된다.</p>
<p><strong>3.1.2. offset</strong></p>
<p>producer는 메세지를 순차적으로 전달하고 디스크에 순차적으로 저장한다.
따라서 저장된 메세지 뒤에 세로운 메세지를 붙이는 append 방식으로 write를 진행한다.
이 때 partition 들은 각 메세지의 순차적인 위치인 offset으로 구성된다.</p>
<p>따라서 offset은 partition 내에서 메세지의 위치를 표시하는 유니크한 숫자이다.
consumer는 자신이 어디까지 메세지를 처리했는지 offset을 이용해서 관리한다.</p>
<p><img loading="lazy" src="/images/notes/kafka/offset.png" alt="offset"  />
</p>
<h2 id="4-zookeeper-란">4. zookeeper 란?</h2>
<p>zookeeper는 분산 애플리케이션이 안정적으로 서비스될 수 있도록 각 애플리케이션의 구성 정보를 중앙 집중시키고, 네이밍, 동기화 등의 서비스를 지원한다.</p>
<p><img loading="lazy" src="/images/notes/kafka/zookeeper.png" alt="zookeeper"  />
</p>
<blockquote>
<p>zookeeper 여러개를 하나의 클러스터로 구성하고, 각각의 zookeeper 서버는 클라이언트 애플리케이션과 커넥션을 유지하며, 상태 정보를 공유한다.</p>
</blockquote>
<p>상태 정보는 zookeeper의 데이터 레지스터의 공유 계층 name space에 저장된다. 그리고 이 공간을 znode라고 부른다.</p>
<p>znode는 key-value 형태이며, 자식 노드를 가지고 있는 계층형 구조로 구성되어 있다.</p>
<p><img loading="lazy" src="/images/notes/kafka/znode.png" alt="znode"  />
</p>
<p>zookeeper는 클러스터로 구성될 시 몇개의 서버가 다운되더라도 과반수 구조에 의해 서비스가 유지된다.</p>
<p>따라서 일반적으로 클러스터는 홀수개의 서버로 구성된다.</p>
<blockquote>
<p><strong>3대 구성 클러스터:</strong>
1대 down, 2대 up: 서비스가 유지된다.
2대 down, 1대 up: 서비스가 유지되지 않는다.</p>
</blockquote>
]]></content:encoded></item></channel></rss>